--------------------
-- Necro.Base
--------------------

id :: .a -> .a
id x = x

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

fst :: .(a, b) -> .a
fst t =
  case t of
    (x, _) -> x

snd :: .(a, b) -> .b
snd t =
  case t of
    (_, y) -> y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  case lt x y of
    True -> x
    _    -> y

-- TODO: map3, etc
class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

-- class Default a where
--   default :: !a

-- instance (Default a, Default b) => Default (a, b) where
--   default = (default, default)

arrayFrom :: a -> Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share x) a

--------------------
-- Prim Instances
--------------------

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Semigroup F64 where
  append x y = x + y

instance Monoid F64 where
  mempty = 0

-- instance Default a => Default (Array n a) where
--   default = arrayFrom default

-- -- This is getting tripped up in lambda_lift
-- defaulted :: Array 4 (Maybe Int)
-- defaulted = default

-- coolInit :: Array 4 Int
-- coolInit ~ (freezeArray (unsafeEmptyArray ())) = coolInit

-- coolInit2 :: (#Maybe Int, Float#)
-- coolInit2 = x
--   where
--     x ~ (#Just 0, default#) = x

--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

-- TODO: Test this
instance Default a => Default (Maybe a) where
  default = Just default

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> Nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> Nothing
      Just x  ->
        case my of
          Nothing -> Nothing
          Just y  ->
            Just (f x y)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> Nothing
      Just f  ->
        case mx of
          Nothing -> Nothing
          Just x  -> Just (f x)


--------------------
-- Seq
--------------------

data SeqNil     = SeqEnd | SeqBlockEnd | SeqLoopEnd | SeqRest
data SeqValue a = SeqValue Float a | SeqNil Float SeqNil
data Seq a      = Seq (Float -> SeqValue a)

-- midiIn :: Int -> Seq Int

instance Enum SeqNil where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqLoopEnd
      _ -> SeqRest
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqLoopEnd  -> 2
      SeqRest     -> 3

instance Semigroup SeqNil where
  append x y =
    case lt (fromEnum x) (fromEnum y) of
      True -> x
      _    -> y

instance Monoid SeqNil where
  mempty = SeqRest

instance Functor SeqValue where
  map f s =
    case s of
      SeqValue t x -> SeqValue t (f x)
      SeqNil   t n -> SeqNil   t n

instance FunctorN SeqValue where
  map2 f xs ys =
    case xs of
      SeqValue xt xv ->
        case ys of
          SeqValue yt yv -> SeqValue (min xt yt) (f xv yv)
          SeqNil   yt yn -> SeqNil (min xt yt) yn
      SeqNil xt xn ->
        case ys of
          SeqValue yt _  -> SeqNil (min xt yt) xn
          SeqNil   yt yn -> SeqNil (min xt yt) (xn <> yn)

instance Applicative SeqValue where
  pure x   = SeqValue 1 x
  ap fs xs =
    case fs of
      SeqValue ft fv ->
        case xs of
          SeqValue xt xv -> SeqValue (min ft xt) (fv xv)
          SeqNil   xt xn -> SeqNil (min ft xt) xn
      SeqNil ft fn ->
        case xs of
          SeqValue xt _  -> SeqNil (min ft xt) fn
          SeqNil   xt xn -> SeqNil (min ft xt) (fn <> xn)

instance Num a => Num (SeqValue a) where
  fromInt i = SeqValue 1 (fromInt i)
  add x y   = map2 add x y
  sub x y   = map2 sub x y
  mul x y   = map2 mul x y
  signum x  = map signum x
  abs x     = map abs x

instance Fractional a => Fractional (SeqValue a) where
  fromRational r = SeqValue 1 (fromRational r)
  div x y        = map2 div x y
  recip x        = map recip x

runSeq :: Seq a -> Float -> SeqValue a
runSeq s time =
  case s of
    Seq stepFunc -> stepFunc time

instance Functor Seq where
  map f s = Seq (\t -> map f (runSeq s t))

instance Applicative Seq where
  pure x   = Seq (\_ -> SeqValue 1 x)
  ap fs xs = Seq (\t -> ap (runSeq fs t) (runSeq xs t))

instance FunctorN Seq where
  map2 f sx sy = Seq (\t -> map2 f (runSeq sx t) (runSeq sy t))

instance Num a => Num (Seq a) where
  fromInt i = Seq (\_ -> SeqValue 1 (fromInt i))
  add x y   = Seq (\t -> map2 add (runSeq x t) (runSeq y t))
  sub x y   = Seq (\t -> map2 sub (runSeq x t) (runSeq y t))
  mul x y   = Seq (\t -> map2 mul (runSeq x t) (runSeq y t))
  signum x  = Seq (\t -> map signum (runSeq x t))
  abs x     = Seq (\t -> map abs (runSeq x t))

instance Fractional a => Fractional (Seq a) where
  fromRational r = Seq (\_ -> SeqValue 1 (fromRational r))
  div x y        = Seq (\t -> map2 div (runSeq x t) (runSeq y t))
  recip x        = Seq (\t -> map recip (runSeq x t))

rest :: Seq Int
rest = Seq (\_ -> SeqNil 1 SeqRest)


--------------------
-- Print
--------------------
class Print a where
  print :: a -> *World -> *World

instance Print Int where
  print x w = printInt x w

instance Print F64 where
  print x w = printF64 x w


--------------------
-- Channel
--------------------
data Channel = BlockRate F64 | AudioRate (Array BlockSize F64)

outChannel :: UInt -> Channel -> *World -> *World
outChannel n c w =
  case c of
    BlockRate _ -> w
    AudioRate b -> outAudioBlock n b w

mapChannel :: (F64 -> F64) -> Channel -> Channel
mapChannel f c =
  case c of
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share (f (readArray i b))) a

-- TODO: Look into alias analysis here!
-- We should be able to float the call to unsafeEmptyArray out of the for loop
mapChannel2 :: (F64 -> F64 -> F64) -> Channel -> Channel -> Channel
mapChannel2 f cx cy =
  case cx of
    BlockRate x ->
      case cy of
        BlockRate y ->
          BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f x (readArray i y))) a
    AudioRate x ->
      case cy of
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f (readArray i x) y)) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f (readArray i x) (readArray i y))) a

-- TODO: Stateful unboxed tuple types!
accumulateChannel1 :: Default s => (F64 -> s -> (#s, F64#)) -> Channel -> Channel
accumulateChannel1 f input1 =
  case output of
    (_, o) -> AudioRate o
  where
    output ~ (default, freezeArray (unsafeEmptyArray ())) =
      case output of
        (state, _) ->
          let (#Share state', o'#) =
                case input1 of
                  BlockRate input1Val ->
                    loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
                      case f input1Val s of
                        (#s', x#) ->
                          (#Share s', writeArray i (Share x) o#)
                  AudioRate input1Buffer ->
                    loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
                      case f (readArray i input1Buffer) s of
                        (#s', x#) ->
                          (#Share s', writeArray i (Share x) o#)
          in (state', freezeArray o')

-- -- Ugly, but and inefficient, it works
-- accumulateChannel2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> Channel -> Channel -> Channel
-- accumulateChannel2 f input1 input2 =
--   case output of
--     (_, o) -> AudioRate o
--   where
--     output ~ (default, freezeArray (unsafeEmptyArray ())) =
--       case output of
--         (state, _) ->
--           let output' =
--                 case input1 of
--                   BlockRate input1Val ->
--                     case input2 of
--                       BlockRate input2Val ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f input1Val input2Val s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--                       AudioRate input2Buffer ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f input1Val (readArray i input2Buffer) s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--                   AudioRate input1Buffer ->
--                     case input2 of
--                       BlockRate input2Val ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f (readArray i input1Buffer) input2Val s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--                       AudioRate input2Buffer ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f (readArray i input1Buffer) (readArray i input2Buffer) s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--           in case output' of
--                (#Share state', o'#) -> (state', freezeArray o')

-- -- The goal, but not all features currently supported
-- accumulateChannel2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> Channel -> Channel -> Channel
-- accumulateChannel2 f input1 input2 =
--   AudioRate (freezeArray output)
--   where
--     emptyO                      = unsafeEmptyArray ()
--     (#state ~ default, output#) =
--       case (#input1, input2#) of
--         (#BlockRate input1Val, BlockRate input2Value#) ->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f input1Val input2Val s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#BlockRate input1Val, AudioRate input2Buffer#) ->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f input1Val (readArray i input2Buffer) s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#AudioRate input1Buffer, BlockRate input2Val#)->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f (readArray i input1Buffer) input2Val s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#AudioRate input1Buffer, AudioRate input2Buffer#)->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f (readArray i input1Buffer) (readArray i input2Buffer) s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)

instance Num Channel where
  fromInt i = BlockRate (fromInt i)
  add l r   = mapChannel2 add l r
  sub l r   = mapChannel2 sub l r
  mul l r   = mapChannel2 mul l r
  signum c  = mapChannel signum c
  abs c     = mapChannel abs c


--------------------
-- Audio
--------------------
data Mono      = Mono Channel
data Stereo    = Stereo (#Channel, Channel#)
data Quad      = Quad Channel Channel Channel Channel
data Ambisonic = Ambisonic Channel Channel Channel Channel

-- TODO: Equal power panning
class Audio a where
  pureAudio        :: Channel -> a
  mapAudio         :: (Channel -> Channel) -> a -> a
  mapAudio2        :: (Channel -> Channel -> Channel) -> a -> a -> a
  accumulateAudio1 :: Default s => (F64 -> s -> (#s, F64#)) -> a -> a
  pan              :: Mono -> a -> Stereo
  outAudio         :: UInt -> a -> *World -> *World

instance Audio Mono where
  pureAudio c    = Mono c
  outAudio n m w =
    case m of
      Mono c -> outChannel n c w
  mapAudio f m =
    case m of
      Mono c -> Mono (f c)
  mapAudio2 f mx my =
    case mx of
      Mono cx ->
        case my of
          Mono cy -> Mono (f cx cy)
  accumulateAudio1 f m =
    case m of
      Mono c -> Mono (accumulateChannel1 f c)
  pan amount input =
    case input of
      Mono inputChannel ->
        case amount of
          Mono amountChannel ->
            Stereo (#mul inputChannel (sub 1 amountChannel), mul inputChannel amountChannel#)

instance Audio Stereo where
  pureAudio c    = Stereo (#c, c#)
  outAudio n s w =
    case s of
      Stereo (#l, r#) ->
        outChannel (add n 1) r (outChannel n l w)
  mapAudio f s =
    case s of
      Stereo (#l, r#) ->
        Stereo (#f l, f r#)
  mapAudio2 f sx sy =
    case sx of
      Stereo (#lx, rx#) ->
        case sy of
          Stereo (#ly, ry#) -> Stereo (#f lx ly, f rx ry#)
  accumulateAudio1 f s =
    case s of
      Stereo (#l, r#) ->
        Stereo (#accumulateChannel1 f l, accumulateChannel1 f r#)
  pan amount input =
    case input of
      Stereo (#inputChannelL, inputChannelR#) ->
        case amount of
          Mono amountChannel ->
            Stereo (#mul inputChannelL (sub 1 amountChannel), mul inputChannelR amountChannel#)

-- accumulateAudio1 :: (Default s, Audio a) => (F64 -> s -> (#s, F64#)) -> a -> a
-- accumulateAudio1 f a = mapAudio (accumulateChannel1 f) a

instance Num Mono where
  fromInt i = Mono (fromInt i)
  add l r   = mapAudio2 add l r
  sub l r   = mapAudio2 sub l r
  mul l r   = mapAudio2 mul l r
  signum c  = mapAudio signum c
  abs c     = mapAudio abs c

instance Num Stereo where
  fromInt i = let c = fromInt i in Stereo (#c, c#)
  add l r   = mapAudio2 add l r
  sub l r   = mapAudio2 sub l r
  mul l r   = mapAudio2 mul l r
  signum c  = mapAudio signum c
  abs c     = mapAudio abs c

instance Fractional Channel where
  fromRational r = BlockRate (fromRational r)
  div l r        = mapChannel2 div l r
  recip c        = mapChannel recip c

instance Fractional Mono where
  fromRational r = Mono (fromRational r)
  div l r        = mapAudio2 div l r
  recip c        = mapAudio recip c

instance Fractional Stereo where
  fromRational r = let c = fromRational r in Stereo (#c, c#)
  div l r        = mapAudio2 div l r
  recip c        = mapAudio recip c

instance Semigroup Mono where
  append x y = x + y

instance Monoid Mono where
  mempty = 0

instance Semigroup Stereo where
  append x y = x + y

instance Monoid Stereo where
  mempty = 0

stereo :: Mono -> Mono -> Stereo
stereo ml mr =
  case ml of
    Mono l ->
      case mr of
        Mono r -> Stereo (#l, r#)

accumulateSaw :: F64 -> F64 -> (#F64, F64#)
accumulateSaw freq acc =
  (#acc3, out#)
  where
    acc2 = fma freq recipSampleRate acc
    acc3 = acc2 - fastFloor acc2
    out  = fma acc3 2.0 (-1.0)

saw :: (Audio a) => a -> a
saw freq = accumulateAudio1 accumulateSaw freq

-- statefulWhile :: Mono
-- statefulWhile = snd <|
--   loop (i, x) = (0, 0) while i < 20 do
--     (i + 1, x + saw 440)

class Foldable f where
  fold  :: Monoid m => f m -> m
  foldl :: Monoid b => (b -> a -> b) -> b -> f a -> b
  foldp :: Monoid b => (b -> a -> b) -> f a -> b

-- TODO: Desugar seq literals
-- TODO: Replace Default with Monoid?
-- TODO: Handle Constant, End, etc
-- TODO: Need partial recursive values to get rid of monoid here

instance Foldable Seq where
  fold s =
    case out of
      (#_, _, accOut#) -> accOut
    where
      out ~ (#0, 0, mempty#) =
        case out of
          (#tick', time', _#) ->
            loop (#tick, time, acc#) = (#tick' + 1, time', mempty#) while time < tick do
              case runSeq s time of
                SeqNil   t _ -> (#tick, time + t, acc#)
                SeqValue t x -> (#tick, time + t, acc <> x#)

  foldl f init s =
    case out of
      (#_, _, accOut#) -> accOut
    where
      out ~ (#0, 0, mempty#) =
        case out of
          (#tick', time', _#) ->
            loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
              case runSeq s time of
                SeqNil   t _ -> (#tick, time + t, acc#)
                SeqValue t x -> (#tick, time + t, f acc x#)

  foldp f s =
    case out of
      (#_, _, accOut#) -> accOut
    where
      out ~ (#0, 0, mempty#) =
        case out of
          (#tick', time', init#) ->
            loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
              case runSeq s time of
                SeqNil   t _ -> (#tick, time + t, acc#)
                SeqValue t x -> (#tick, time + t, f acc x#)

seqOne :: Seq Int
seqOne = 1

foldSeqTest :: Int
-- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- instance Default World where
--   default = World

-- instance Print a => Print (Seq a) where
--   print s w =
--     case out of
--       (#_, _, wout#) -> wout
--     where
--       out ~ (#Share 0, Share 0, _#) =
--         case out of
--           (#Share tick', time', _#) ->
--             loop (#Share tick, Share time, w'#) = (#Share (tick' + 1), time', w#) while time < tick do
--               case runSeq s time of
--                 SeqNil   t _ -> (#Share tick, Share (time + t), w'#)
--                 SeqValue t x -> (#Share tick, Share (time + t), print x w'#)

-- printSeqTest :: *World -> *World
-- printSeqTest w = print seqOne w

-- -- TODO: UInt64
-- -- TODO: Rational
-- data Rational = Rational (#Bool, UInt, UInt#)

-- poly :: Audio a => (a -> a) -> Seq Float -> a
-- poly f (Seq s) = out
--   where
--     (children ~ default, currTime ~ 0, tick ~ 1) =
--       loop (c, t, tick') = (children, currTime, tick + 1) while t > tick' do
--         case s t of
--           SeqNil   t' _   -> (c, t + t', tick')
--           SeqValue t' arg -> (dynAppend (f (fromRational arg)) c, t + t', tick')

-- Add Bool to Audio which flags that it has ended!

-- flipTest2 :: Maybe Int
-- flipTest2 = map (flip add 33) Nothing

-- TODO:
-- accumulatePulse :: F64 -> F64 -> F64 -> (#F64, F64#)
-- accumulatePulse width freq acc =
--   (#acc3, out#)
--   where
--     acc2 = fma freq recipSampleRate acc
--     acc3 = acc2 - fastFloor acc2
--     out  = fma (fromInt (boolToInt (acc3 > width))) 2.0 (-1.0)
--
-- pulse :: Audio a => a -> a
-- pulse freq = accumulateAudio2 accumulatePulse freq

-- TODO: Seq notation
-- TODO: Seq
-- TODO: while loops
-- TODO: Defunctionalization
-- TODO: Rational Type
-- TODO: Stateful Unboxed types
-- TODO: Stateful Pattern assignment
-- TODO: toSIMDAudio :: Array BlockSize F64 -> Array SIMDBlockSize SIMDF64

