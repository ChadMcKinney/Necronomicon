--------------------
-- Necro.Base
--------------------

id :: .a -> .a
id x = x

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

fst :: .(a, b) -> .a
fst (x, _) = x

snd :: .(a, b) -> .b
snd t =
  case t of
    (_, y) -> y

fst' :: .(#a, b#) -> .a
fst' t =
  case t of
    (#x, _#) -> x

snd' :: .(#a, b#) -> .b
snd' t =
  case t of
    (#_, y#) -> y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  if x < y then
    x
  else
    y

-- TODO: map3, etc
class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

-- class Default a where
--   default :: !a

-- instance (Default a, Default b) => Default (a, b) where
--   default = (default, default)

arrayFrom :: a -> Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share x) a

--------------------
-- Prim Instances
--------------------

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Semigroup F64 where
  append x y = x + y

instance Monoid F64 where
  mempty = 0

-- instance Default a => Default (Array n a) where
--   default = arrayFrom default

-- -- This is getting tripped up in lambda_lift
-- defaulted :: Array 4 (Maybe Int)
-- defaulted = default

-- coolInit :: Array 4 Int
-- coolInit ~ (freezeArray (unsafeEmptyArray ())) = coolInit

-- coolInit2 :: (#Maybe Int, Float#)
-- coolInit2 = x
--   where
--     x ~ (#Just 0, default#) = x

-- class Num a => Integral a where
--   quot :: a -> a -> Maybe a
--   rem :: a -> a -> Maybe a
--   div :: a -> a -> Maybe a
--   mod :: a -> a -> Maybe a

-- instance Integral Int where
--   quot x y = if y == 0 then Nothing else primUndefined
--   rem  x y = if y == 0 then Nothing else primUndefined
--   div  x y = if y == 0 then Nothing else primUndefined
--   mod  x y = if y == 0 then Nothing else primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
data Rational = Rational (#Int, Int#)

gcd :: Int -> Int -> Int
gcd x y =
  fst' <| loop (#a, b#) = (#abs x, abs y#) while b > 0 do
    (#b, remInt a b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational (#quotInt x d, quotInt y d#)
  where
    d = gcd x y

-- TODO: abs and signum are currently broken
rational :: Int -> Int -> Rational
rational x y = reduce x y
-- rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator (Rational (#n, _#)) = n

denominator :: Rational -> Int
denominator (Rational (#_, d#)) = d

instance Eq Rational where
  eq  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = eq (xn * yd) (yn * xd)
  neq (Rational (#xn, xd#)) (Rational (#yn, yd#)) = neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = lt  (xn * yd) (yn * xd)
  lte (Rational (#xn, xd#)) (Rational (#yn, yd#)) = lte (xn * yd) (yn * xd)
  gt  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = gt  (xn * yd) (yn * xd)
  gte (Rational (#xn, xd#)) (Rational (#yn, yd#)) = gte (xn * yd) (yn * xd)

-- TODO: Rational math looks off...
instance Num Rational where
  add (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yd + yn * xd) (xd * yd)
  sub (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yd - yn * xd) (xd * yd)
  mul (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yn) (xd * yd)
  abs (Rational (#xn, xd#))                       = Rational (#abs xn, xd#)
  signum (Rational (#xn, _#))                     = Rational (#signum xn, 1#)
  fromInt x                                       = Rational (#fromInt x, 1#)

-- -- TODO: Switch fromRational to use Rational type!
-- instance Fractional Rational where
--   div x y =
--     case x of
--       Rational (#xn, xd#) ->
--         case y of
--           Rational (#yn, yd#) ->
--             rational (xn * yd) (xd * yn)
--   recip x =
--     case x of
--       Rational (#n, d#) -> if n == 0 then Rational (#0, 1#) else
--         if n < 0
--           then rational d n
--           else rational d n
--   fromRational r = rational 1 1

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

-- rationalTest :: Rational
-- rationalTest = 33 * 44 + 23 - (1 % 4)

-- threeHalves :: Rational
-- threeHalves = 3 % 2


--------------------
-- Array
--------------------
  -- TODO: This is failing in lambda lift for some reason
-- instance Print a => Print (Array n a) where
--   print a w =
--     loop w' = w for i <- each do
--       print (readArray i a) w'

-- nums :: Array 3 Int
-- nums = {0, 1, 2}

-- stringTest :: *World -> *World
-- stringTest w = print nums w


--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Default (Maybe a) where
  default = nothing

instance Semigroup (Maybe a) where
  append x y =
    case x of
      Nothing -> y
      _       -> x

instance Monoid (Maybe a) where
  mempty = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

maybe :: b -> (a -> b) -> Maybe a -> b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x


--------------------
-- Seq
--------------------
data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
data SeqValue a = SeqValue (#Float, SeqControl, Maybe a#)
data Seq a      = Seq (() -> SeqValue a)

instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    if lt (fromEnum x) (fromEnum y) then
      x
    else
      y

instance Monoid SeqControl where
  mempty = SeqPure

instance Semigroup (SeqValue a) where
  append (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#min xt yt, append xc yc, append xv yv#)

instance Monoid (SeqValue a) where
  mempty = SeqValue (#1, SeqPure, nothing#)

instance Default (SeqValue a) where
  default = SeqValue (#1, SeqPure, nothing#)

instance Functor SeqValue where
  map f (SeqValue (#t, c, x#)) =
    SeqValue (#t, c, map f x#)

-- TODO: Take SeqControl into account when merging times!

instance FunctorN SeqValue where
  map2 f (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#min xt yt, xc <> yc, map2 f xv yv#)

instance Applicative SeqValue where
  pure x = SeqValue (#1, SeqPure, Just x#)
  ap (SeqValue (#ft, fc, fv#)) (SeqValue (#xt, xc, xv#)) =
    SeqValue (#min xt ft, fc <> xc, ap fv xv#)

instance Num a => Num (SeqValue a) where
  fromInt i = SeqValue (#1, SeqPure, Just (fromInt i)#)
  add x y   = map2 add x y
  sub x y   = map2 sub x y
  mul x y   = map2 mul x y
  signum x  = map signum x
  abs x     = map abs x

instance Fractional a => Fractional (SeqValue a) where
  fromRational r = SeqValue (#1, SeqPure, Just (fromRational r)#)
  div x y        = map2 div x y
  recip x        = map recip x

runSeq :: Seq a -> () -> SeqValue a
runSeq (Seq stepFunc) _ = stepFunc ()

instance Functor Seq where
  map f s = Seq (\_ -> map f (runSeq s ()))

instance Applicative Seq where
  pure x   = Seq (\_ -> pure x)
  ap fs xs = Seq (\_ -> ap (runSeq fs ()) (runSeq xs ()))

instance FunctorN Seq where
  map2 f sx sy = Seq (\_ -> map2 f (runSeq sx ()) (runSeq sy ()))

instance Num a => Num (Seq a) where
  fromInt i = Seq (\_ -> pure (fromInt i))
  add x y   = Seq (\_ -> map2 add (runSeq x ()) (runSeq y ()))
  sub x y   = Seq (\_ -> map2 sub (runSeq x ()) (runSeq y ()))
  mul x y   = Seq (\_ -> map2 mul (runSeq x ()) (runSeq y ()))
  signum x  = Seq (\_ -> map signum (runSeq x ()))
  abs x     = Seq (\_ -> map abs (runSeq x ()))

instance Fractional a => Fractional (Seq a) where
  fromRational r = Seq (\_ -> pure (fromRational r))
  div x y        = Seq (\_ -> map2 div (runSeq x ()) (runSeq y ()))
  recip x        = Seq (\_ -> map recip (runSeq x ()))

instance Semigroup (Seq a) where
  append (Seq xf) (Seq yf) =
    Seq (\_ -> append (xf ()) (yf ()))

restSeqValue :: SeqValue a
restSeqValue =
  SeqValue (#1, SeqPure, nothing#)

rest :: Seq a
rest =
  Seq (\_ -> restSeqValue)

--------------------
-- Print
--------------------
class Print a where
  print :: a -> *World -> *World

instance Print Int where
  print x w = printInt x w

instance Print I64 where
  print x w = printI64 x w

instance Print F64 where
  print x w = printF64 x w

instance Print Char where
  print x w = printChar x w

instance Print Rational where
  print (Rational (#n, d#)) w =
    print '(' w |> print n |> print ' ' |> print '%' |> print ' ' |> print d |> print ')'

-- -- TODO: Tick delta
-- -- TODO: Seq literals

-- TODO: Print Array
-- TODO: Print Seq

printLn :: Print a => a -> *World -> *World
printLn x w =
  print '\n' (print x w)


--------------------
-- Channel
--------------------
data Channel = BlockRate F64 | AudioRate (Array BlockSize F64)

outChannel :: UInt -> Channel -> *World -> *World
outChannel n c w =
  case c of
    BlockRate _ -> w
    AudioRate b -> outAudioBlock n b w

mapChannel :: (F64 -> F64) -> Channel -> Channel
mapChannel f c =
  case c of
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share (f (readArray i b))) a

-- TODO: Look into alias analysis here!
-- We should be able to float the call to unsafeEmptyArray out of the for loop
mapChannel2 :: (F64 -> F64 -> F64) -> Channel -> Channel -> Channel
mapChannel2 f cx cy =
  case cx of
    BlockRate x ->
      case cy of
        BlockRate y ->
          BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f x (readArray i y))) a
    AudioRate x ->
      case cy of
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f (readArray i x) y)) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f (readArray i x) (readArray i y))) a

-- TODO: Partially recursive values
-- TODO: Stateful unboxed tuple types!

accumulateChannel1 :: Default s => (F64 -> s -> (#s, F64#)) -> Channel -> Channel
accumulateChannel1 f input1 =
  case out of
    (_, a) ->
      AudioRate a
  where
    out ~ (default, freezeArray (unsafeEmptyArray ())) =
      case out of
        (state, _) ->
          let
            out' =
              case input1 of
                BlockRate input1Val ->
                  loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
                    case f input1Val s of
                      (#s', x#) ->
                        (#Share s', writeArray i (Share x) o#)
                AudioRate input1Buffer ->
                  loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#Share s', writeArray i (Share x) o#)
          in
            case out' of
              (#Share state', o'#) ->
                (state', freezeArray o')

-- accumulateChannel1 :: Default s => (F64 -> s -> (#s, F64#)) -> Channel -> Channel
-- accumulateChannel1 f input1 =
--   AudioRate (freezeArray o)
--   where
--     (#Share (state ~ default), o#) =
--       case input1 of
--         BlockRate input1Val ->
--           loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--             case f input1Val s of
--               (#s', x#) ->
--                 (#Share s', writeArray i (Share x) o#)
--         AudioRate input1Buffer ->
--           loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--             case f (readArray i input1Buffer) s of
--               (#s', x#) ->
--                 (#Share s', writeArray i (Share x) o#)

-- -- The goal, but not all features currently supported
-- accumulateChannel2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> Channel -> Channel -> Channel
-- accumulateChannel2 f input1 input2 =
--   AudioRate (freezeArray output)
--   where
--     emptyO                      = unsafeEmptyArray ()
--     (#Share (state ~ default), output#) =
--       case (#input1, input2#) of
--         (#BlockRate input1Val, BlockRate input2Value#) ->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f input1Val input2Val s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#BlockRate input1Val, AudioRate input2Buffer#) ->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f input1Val (readArray i input2Buffer) s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#AudioRate input1Buffer, BlockRate input2Val#)->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f (readArray i input1Buffer) input2Val s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#AudioRate input1Buffer, AudioRate input2Buffer#)->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f (readArray i input1Buffer) (readArray i input2Buffer) s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)

instance Num Channel where
  fromInt i = BlockRate (fromInt i)
  add l r   = mapChannel2 add l r
  sub l r   = mapChannel2 sub l r
  mul l r   = mapChannel2 mul l r
  signum c  = mapChannel signum c
  abs c     = mapChannel abs c


--------------------
-- Audio
--------------------
data Mono      = Mono Channel
data Stereo    = Stereo (#Channel, Channel#)
data Quad      = Quad Channel Channel Channel Channel
data Ambisonic = Ambisonic Channel Channel Channel Channel

-- TODO: Equal power panning
class Audio a where
  pureAudio        :: Channel -> a
  mapAudio         :: (Channel -> Channel) -> a -> a
  mapAudio2        :: (Channel -> Channel -> Channel) -> a -> a -> a
  accumulateAudio1 :: Default s => (F64 -> s -> (#s, F64#)) -> a -> a
  pan              :: Mono -> a -> Stereo
  outAudio         :: UInt -> a -> *World -> *World

instance Audio Mono where
  pureAudio c                     = Mono c
  outAudio  n (Mono c)  w         = outChannel n c w
  mapAudio  f (Mono c)            = Mono (f c)
  mapAudio2 f (Mono cx) (Mono cy) = Mono (f cx cy)
  accumulateAudio1 f (Mono c)     = Mono (accumulateChannel1 f c)
  pan (Mono amount) (Mono input)  = Stereo (#mul input (sub 1 amount), mul input amount#)

instance Audio Stereo where
  pureAudio c                                         = Stereo (#c, c#)
  outAudio  n (Stereo (#l, r#)) w                     = outChannel (add n 1) r (outChannel n l w)
  mapAudio  f (Stereo (#l, r#))                       = Stereo (#f l, f r#)
  mapAudio2 f (Stereo (#lx, rx#)) (Stereo (#ly, ry#)) = Stereo (#f lx ly, f rx ry#)
  accumulateAudio1 f (Stereo (#l, r#))                = Stereo (#accumulateChannel1 f l, accumulateChannel1 f r#)
  pan (Mono amount) (Stereo (#l, r#))                 = Stereo (#mul l (sub 1 amount), mul r amount#)

-- accumulateAudio1 :: (Default s, Audio a) => (F64 -> s -> (#s, F64#)) -> a -> a
-- accumulateAudio1 f a = mapAudio (accumulateChannel1 f) a

instance Num Mono where
  fromInt i = Mono (fromInt i)
  add l r   = mapAudio2 add l r
  sub l r   = mapAudio2 sub l r
  mul l r   = mapAudio2 mul l r
  signum c  = mapAudio signum c
  abs c     = mapAudio abs c

instance Num Stereo where
  fromInt i = let c = fromInt i in Stereo (#c, c#)
  add l r   = mapAudio2 add l r
  sub l r   = mapAudio2 sub l r
  mul l r   = mapAudio2 mul l r
  signum c  = mapAudio signum c
  abs c     = mapAudio abs c

instance Fractional Channel where
  fromRational r = BlockRate (fromRational r)
  div l r        = mapChannel2 div l r
  recip c        = mapChannel recip c

instance Fractional Mono where
  fromRational r = Mono (fromRational r)
  div l r        = mapAudio2 div l r
  recip c        = mapAudio recip c

instance Fractional Stereo where
  fromRational r = let c = fromRational r in Stereo (#c, c#)
  div l r        = mapAudio2 div l r
  recip c        = mapAudio recip c

instance Semigroup Mono where
  append x y = x + y

instance Monoid Mono where
  mempty = 0

instance Semigroup Stereo where
  append x y = x + y

instance Monoid Stereo where
  mempty = 0

stereo :: Mono -> Mono -> Stereo
stereo (Mono l) (Mono r) =
  Stereo (#l, r#)

accumulateSaw :: F64 -> F64 -> (#F64, F64#)
accumulateSaw freq acc =
  (#acc3, out#)
  where
    acc2 = fma freq recipSampleRate acc
    acc3 = acc2 - fastFloor acc2
    out  = fma acc3 2.0 (-1.0)

saw :: (Audio a) => a -> a
saw freq =
  accumulateAudio1 accumulateSaw freq

-- class Foldable f where
--   fold  :: Monoid m => f m -> m
--   foldl :: (b -> a -> b) -> b -> f a -> b
--   foldp :: (b -> a -> b) -> f a -> b

-- TODO: Desugar seq literals
-- TODO: Replace Default with Monoid?
-- TODO: Handle Constant, End, etc
-- TODO: Need partial recursive values to get rid of monoid here

-- -- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     acc'
--     where
--       (#tick' ~ 0, time' ~ 0, acc' ~ mempty#) =
--         loop (#tick, time, acc#) = (#tick' + 1, time', acc'#) while time < tick do
--           case runSeq s () of
--             SeqValue (#t, _, Just x#) -> (#tick, time + t, f acc x#)
--             SeqValue (#t, _, _#)      -> (#tick, time + t, acc#)
--
-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

instance Print a => Print (Seq a) where
  print s w = wout
    where
      tick ~ 0       = tick + 0.003
      (#_, _, wout#) =
        loop (#Share cont, Share time, w'#) = (#Share True, Share 0, w#) while cont do
          let nextValueTime ~ 0 = nextValueTime + time in
            if nextValueTime >= tick then
              (#Share False, Share 0, w'#)
            else
              case runSeq s () of
                SeqValue (#t, _, Just x#) ->
                  (#Share True, Share t, print ' ' (print ',' (print x w'))#)
                SeqValue (#t, _, _#) ->
                  (#Share True, Share t, w'#)

-- TODO: Literal Case expressions are returning the wrong values!
seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  SeqNormal
  -- if (slot + 1) < maxSlot then
  --   SeqNormal
  -- else
  --   SeqLoopEnd

-- Combining nested case statements with case literals seems to break...
slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue (#t, c, v#) ->
      case c of
        SeqNormal -> (#slot, sv#)
        _         -> (#remInt (slot + 1) maxSlot, SeqValue (#t, SeqNormal, v#)#)

        -- _         -> (#remInt (slot + 1) maxSlot, SeqValue (#t, controlIfNotNormal, v#)#)

warpSeqValueSpeed :: Float -> SeqValue a -> SeqValue a
warpSeqValueSpeed speed (SeqValue (#t, c, v#)) =
  SeqValue (#t * speed, c, v#)

seqTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
seqTick slot maxSlot sv =
  slotTick slot maxSlot SeqNormal sv

tupleTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
tupleTick slot maxSlot sv =
  slotTick slot maxSlot SeqNormal (warpSeqValueSpeed (recip (fromInt maxSlot)) sv)

interleaveTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot sv =
  slotTick slot maxSlot SeqNormal sv

-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

-- seqTest :: Seq Float
-- seqTest =
--   [0 _ 1 2]

-- seqTestGo :: SeqValue Float
-- seqTestGo =
--   runSeq seqTest ()

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- tupleTestGo :: SeqValue Float
-- tupleTestGo = runSeq tupleTest ()

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- interleaveTestGo :: SeqValue Float
-- interleaveTestGo = runSeq interleaveTest ()

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- seqTest1Go :: SeqValue Float
-- seqTest1Go = runSeq seqTest1 ()

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 _ 4>]

-- seqTest2Go :: SeqValue Float
-- seqTest2Go = runSeq seqTest2 ()

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]

-- proceduralBeat :: Seq Float
-- proceduralBeat = Seq <| \_ ->
--   let
--     tick ~ 0 = tick + 1
--     value    = tick * 100 + fromInt mouseY * fromInt mouseX
--   in
--     SeqValue (#2, SeqNormal, Just value#)

-- -- Simplification is getting out of hand, current setup is n^2 which is....bad.
-- seqTest :: Seq Float
-- seqTest =
--   [x 100 200 <300 x> [400:500]]
--   where
--     x = <30 40 <50 60 70> 80> + 3

-- coolBeat :: Seq Float
-- coolBeat =
--   [
--     x y (y+y) z
--     _ x <5 z> x
--     _ 0 <1 2> y
--   ] * 2
--   where
--     x = <0 5 <1 2> 1>
--     y = 3
--     z = fromInt mouseX * 100

-- coolBeatGo :: SeqValue Float
-- coolBeatGo = runSeq coolBeat ()

-- seqTest3 :: Seq Float
-- seqTest3 =
--   [c d [2:y]]

-- seqTest4 :: Seq Float
-- seqTest4 =
--   [0 _ 1 [x:y:4]]
--   where
--     x = <1 2 3>
--     y = <4 5 6 7>

-- longTuple :: Seq Float
-- longTuple =
--   [0 1 _ [twentyOneSecondsOfRest:3]]
--
-- mixNMatch :: Seq Float
-- mixNMatch =
--   [x y (x + y) 1]
--   where
--     x = [1:2:3:4]
--     y = [3:2:1]
--
-- mixNMatch2 :: Seq Float
-- mixNMatch2 =
--   [0 _ 1 [x:y:mixNMatch]]
--   where
--     x = <1:[2|4]:3>
--     y = [<4:5> | <6:7:8>]
--
-- -- <|> => Merge
-- -- <|> ==> alternative operator?
--
-- mergedBeat :: Seq Float
-- mergedBeat = x <|> y
--   where
--     x = [1 _ <2:0:[3|4]> _]
--     y = [<_:4> <_:_:5> <_:6>]

-- properFraction :: (Fractional a, Integral b) -> a -> (b, b)

-- poly :: Audio a => (a -> a) -> Seq Float -> a
-- poly f (Seq s) = out
--   where
--     (children ~ default, currTime ~ 0, tick ~ 1) =
--       loop (c, t, tick') = (children, currTime, tick + 1) while t > tick' do
--         case s t of
--           SeqNil   t' _   -> (c, t + t', tick')
--           SeqValue t' arg -> (dynAppend (f (fromRational arg)) c, t + t', tick')


-- TODO:
-- accumulatePulse :: F64 -> F64 -> F64 -> (#F64, F64#)
-- accumulatePulse width freq acc =
--   (#acc3, out#)
--   where
--     acc2 = fma freq recipSampleRate acc
--     acc3 = acc2 - fastFloor acc2
--     out  = fma (fromInt (boolToInt (acc3 > width))) 2.0 (-1.0)
--
-- pulse :: Audio a => a -> a
-- pulse freq = accumulateAudio2 accumulatePulse freq

-- TODO: Make sure that seq combinators that take multiple seq inputs (map2, ap, etc) only demands the inputs after the duration for each specific input
-- TODO: Add Flag to Audio which flags that it has ended!
-- TODO: Sequence Literals
-- TODO: Partially recursive values
-- TODO: Defunctionalization
-- TODO: Rational Type
-- TODO: Stateful Unboxed types
-- TODO: Stateful Pattern assignment
-- TODO: toSIMDAudio :: Array BlockSize F64 -> Array SIMDBlockSize SIMDF64
-- TODO: Conal Elliot automatic differentiation
-- TODO: Get changes from Chad for apat desugaring
-- TODO: Throw this into a test
-- TODO: 64-bit issue Chad was having

