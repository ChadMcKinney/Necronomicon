--------------------
-- Necro.Base
--------------------

-- -- TODO: Move into tests!
-- data ETest1 a     = ETest1 (Maybe a)
-- data ETest2 a     = ETest2 (Bool, Maybe a)
-- data ETest3 a     = ETest3 (Maybe (Bool, Maybe a))
-- data T3feri a b c = T3feri (a, a) (b, b) (c, c)
-- data HKT  t a     = HKT  (t a)
-- data HTest  a b   = HTest (Maybe a) (Maybe b) (Either a b)
-- data HKT2 t a b   = HKT2 (t a b)

testAssertion :: Bool -> *World -> *World
testAssertion b w = primUndefined

panic :: UInt -> UInt
panic x = primUndefined

boundsCheck :: Array n Char -> UInt -> UInt -> UInt
boundsCheck str index capacity =
  if index < capacity then index else
    index
    |> traceLn "bounds check FAILED:"
    |> trace "| "
    |> traceLn str
    |> trace "| index:    "
    |> traceLn index
    |> trace "| capacity: "
    |> traceLn capacity
    |> traceLn " "
    |> panic

-- testAndPrintAssertion :: (Print a, Eq a) => a -> a -> *World -> *World
-- testAndPrintAssertion x y w = testAssertion (x == y) <| printLn x w

boolToInt :: Bool -> Int
boolToInt b = primUndefined

id :: .a -> .a
id x = x

fst :: (.a, .b) -> .a
fst (x, _) = x

snd :: (.a, .b) -> .b
snd (_, y) = y

fst' :: (#.a, .b#) -> .a
fst' (#x, _#) = x

snd' :: (#.a, .b#) -> .b
snd' (#_, y#) = y

fst3 :: (.a, .b, .c) -> .a
fst3 (x, _, _) = x

snd3 :: (.a, .b, .c) -> .b
snd3 (_, y, _) = y

thd3 :: (.a, .b, .c) -> .c
thd3 (_, _, z) = z

fst3' :: (#.a, .b, .c#) -> .a
fst3' (#x, _, _#) = x

snd3' :: (#.a, .b, .c#) -> .b
snd3' (#_, y, _#) = y

thd3' :: (#.a, .b, .c#) -> .c
thd3' (#_, _, z#) = z

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  if x < y then
    x
  else
    y

-- TODO: Fold into Ord class
max :: Ord a => a -> a -> a
max x y =
  if x > y then
    x
  else
    y

uncurry :: .(.a -> .b -> .c) -> (.a, .b) -> .c
uncurry f (x, y) = f x y

uncurry3 :: .(.a -> .b -> .c -> .d) -> (.a, .b, .c) -> .d
uncurry3 f (x, y, z) = f x y z

uncurry' :: .(.a -> .b -> .c) -> (#.a, .b#) -> .c
uncurry' f (#x, y#) = f x y

uncurry3' :: .(.a -> .b -> .c -> .d) -> (#.a, .b, .c#) -> .d
uncurry3' f (#x, y, z#) = f x y z

mouseX :: Int
mouseX = getMouseX ()

mouseY :: Int
mouseY = getMouseY ()

sampleRate :: UInt
sampleRate = primUndefined

recipSampleRate :: F64
recipSampleRate = primUndefined


----------------------
-- Bool
----------------------
data Bool = False | True

-- TODO: primitive for not
not :: .Bool -> .Bool
not b =
  case b of
    True -> False
    _    -> True


----------------------
-- Some Base Classes
----------------------

class Semigroup m where
  append :: m -> m -> m

class Semigroup m => Monoid m where
  mempty :: m

class Functor f where
  map :: (a -> b) -> f a -> f b

class UFunctor f where
  umap :: .(.a -> .b) -> f .a -> f .b

class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c
  map3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  map4 :: (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
  -- TODO: map4, etc

class Functor f => Applicative f where
  pure :: a -> f a
  ap   :: f (a -> b) -> f a -> f b

class Applicative m => Monad m where
  bind :: m a -> (a -> m b) -> m b

class Applicative f => Alternative f where
  empty       :: f a
  alternative :: f a -> f a -> f a

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

class Foldable f where
  fold   :: Monoid m => f m -> m
  foldl  :: (.b -> .a -> .b) -> .b -> f .a -> .b

class Eq a where
  eq  :: a -> a -> Bool
  neq :: a -> a -> Bool

class Eq a => Ord a where
  lt  :: a -> a -> Bool
  gt  :: a -> a -> Bool
  lte :: a -> a -> Bool
  gte :: a -> a -> Bool

class Default a where
  default :: a


----------------------
-- Numeric Hierarchy
----------------------
class Semiring a where
  zero :: a
  one  :: a
  add  :: a -> a -> a
  mul  :: a -> a -> a

class Semiring a => Ring a where
  sub     :: a -> a -> a
  fromInt :: Int -> a

class Ring a => DivisionRing a where
  recip :: a -> a

class Ring a => EuclideanRing a where
  div :: a -> a -> a
  rem :: a -> a -> a
  -- mod :: a -> a -> a

class (EuclideanRing a, DivisionRing a) => Field a where

class (Eq a, Ring a) => Num a where
  abs    :: a -> a
  signum :: a -> a

class (Num a, EuclideanRing a) => Integral a where
  -- quotient :: a -> a -> a

class (Num a, Field a) => Floating a where
  fromFloat :: Float -> a
  sqrt :: a -> a

class Floating a => Trig a where
  sine     :: a -> a
  cosine   :: a -> a
  -- tan      :: a -> a
  -- asine    :: a -> a
  -- acosine  :: a -> a
  -- atan     :: a -> a
  -- atan2    :: a -> a -> a
  -- sineh    :: a -> a
  -- cosineh  :: a -> a
  -- tanh     :: a -> a
  -- asineh   :: a -> a
  -- acosineh :: a -> a
  -- atanh    :: a -> a
  -- atanh2   :: a -> a -> a
  exp      :: a -> a
  exp2     :: a -> a
  log      :: a -> a
  log10    :: a -> a
  log2     :: a -> a
  pow      :: a -> a -> a

  -- atan      :: a -> a
  -- floor'    :: Integral b => a -> b
  -- ceil'     :: Integral b => a -> b

-- toFloating :: (Num' a, Floating b) => a -> b
-- toFloating = fromRational' <. toRational


----------------------------------------
-- Trig Approximation Functions
----------------------------------------

-- How to deal with Float maybe 64 vs 32 bit?
tanF32 :: F64 -> F64
tanF32 n = tanResult
  where
    x = rem n twoPi
    octant = floor <| (x * fourOverPi)
    -- HACK -> Need to be able to convert from Float to
    octantInt = if octant < 1 then 0
      else if octant < 2 then 1
      else if octant < 3 then 2
      else if octant < 4 then 3
      else if octant < 5 then 4
      else if octant < 6 then 5
      else if octant < 7 then 6
      else 7
    -- Accurate to about 8.2 decimal digits over the range (0, pi/4)
    -- This computes tan (pi * x/4), range reduction must be used before input
    tan82 x = (x * (c1 + c2 * x2) / (c3 + x2 * (c4 + x2)))
      where
        c1 = 211.849369664121
        c2 = -12.5288887278448
        c3 = 269.7350131214121
        c4 = -71.4145309347748
        x2 = (x * x)
    tanResult = case octantInt of
      0 -> tan82 (x * fourOverPi)
      1 -> 1 / (tan82 ((halfPi - x) * fourOverPi))
      2 -> -1 / (tan82 ((x - halfPi) * fourOverPi))
      3 -> negate <| tan82 ((pi - x) * fourOverPi)
      4 -> tan82 ((x - pi) * fourOverPi)
      5 -> 1 / (tan82 ((threeHalfPi - x) * fourOverPi))
      6 -> -1 / (tan82 ((x - threeHalfPi) * fourOverPi))
      7 -> negate <| tan82 ((twoPi - x) * fourOverPi)
      _ -> 0 -- ?!?

tanF64 :: F64 -> F64
tanF64 n = tanResult
  where
    x = rem n twoPi
    octant = floor <| (x * fourOverPi)
    -- HACK -> Need to be able to convert from Float to
    octantInt = if octant < 1 then 0
      else if octant < 2 then 1
      else if octant < 3 then 2
      else if octant < 4 then 3
      else if octant < 5 then 4
      else if octant < 6 then 5
      else if octant < 7 then 6
      else 7
    -- Accurate to about 14 decimal digits over the range (0, pi/4)
    -- This computes tan (pi * x/4), range reduction must be used before input
    tan14s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = -34287.4662577359568109624
        c2 = 2566.7175462315050423295
        c3 = -26.5366371951731325438
        c4 = -43656.1579281292375769579
        c5 = 12244.4839556747426927793
        c6 = -336.611376245464339493
        x2 = (x * x)
    tanResult = case octantInt of
      0 -> tan14s (x * fourOverPi)
      1 -> 1 / (tan14s ((halfPi - x) * fourOverPi))
      2 -> -1 / (tan14s ((x - halfPi) * fourOverPi))
      3 -> negate <| tan14s ((pi - x) * fourOverPi)
      4 -> tan14s ((x - pi) * fourOverPi)
      5 -> 1 / (tan14s ((threeHalfPi - x) * fourOverPi))
      6 -> -1 / (tan14s ((x - threeHalfPi) * fourOverPi))
      7 -> negate <| tan14s ((twoPi - x) * fourOverPi)
      _ -> 0 -- ?!?

atanF64 :: F64 -> F64
atanF64 n = if sign then negate z else z
  where
    sign = n < 0
    absN = abs n
    complement = n > 1
    x = if complement then 1 / absN else absN
    region = x > tanTwelthPi
    x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    atanX = atan137s x'
    y = if region then atanX + sixthPi else atanX
    z = if complement then halfPi - y else y
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x * 2
----------------------------------------

class Bits a where
  bitAnd        :: a -> a -> a
  bitNot        :: a -> a
  bitOr         :: a -> a -> a
  bitXor        :: a -> a -> a
  bitShiftLeft  :: a -> UInt -> a
  bitShiftRight :: a -> UInt -> a
  bitReverse    :: a -> a
  toBits        :: a -> UInt
  fromBits      :: UInt -> a

sqr :: Semiring a => a -> a
sqr n = n * n

--------------------
-- ()
--------------------
-- TODO: Can't currently parse () in an instance head!
-- instance Eq () where
--   eq  _ _ = True
--   neq _ _ = False
--
-- instance Ord () where
--   lt  _ _ = False
--   gt  _ _ = False
--   lte _ _ = True
--   gte _ _ = True


--------------------
-- Bool
--------------------
instance Eq Bool where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Bool where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

instance Semiring Bool where
  zero    = False
  one     = True
  add x y = x || y
  mul x y = x && y

instance Semigroup Bool where
  append x y = x || y

instance Monoid Bool where
  mempty = False

instance Default Bool where
  default = False


--------------------
-- Int
--------------------
instance Eq Int where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Int where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Int where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Int where
  sub   x y = primUndefined
  fromInt x = x

instance EuclideanRing Int where
  div x y = primUndefined
  rem x y = primUndefined

instance Num Int where
  abs    x = primUndefined
  signum x = primUndefined

instance Integral Int where

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Default Int where
  default = 0


--------------------
-- I64
--------------------
instance Eq I64 where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord I64 where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring I64 where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring I64 where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance EuclideanRing I64 where
  div x y = primUndefined
  rem x y = primUndefined

instance Num I64 where
  abs    x = primUndefined
  signum x = primUndefined

instance Integral I64 where

instance Semigroup I64 where
  append x y = x + y

instance Monoid I64 where
  mempty = 0

instance Default I64 where
  default = 0


--------------------
-- UInt
-- NOTE: that this is the traditional programming language concept of an unsigned integer (with its idiosyncrasies) and not the more mathematically defined set of Natural Numbers
--------------------
instance Eq UInt where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord UInt where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring UInt where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring UInt where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance EuclideanRing UInt where
  div x y = primUndefined
  rem x y = primUndefined

instance Num UInt where
  abs    x = primUndefined
  signum x = primUndefined

instance Integral UInt where

instance Bits UInt where
  bitAnd        x y = primUndefined
  bitNot        x   = primUndefined
  bitOr         x y = primUndefined
  bitXor        x y = primUndefined
  bitShiftLeft  x y = primUndefined
  bitShiftRight x y = primUndefined
  bitReverse    x   = primUndefined
  toBits        x   = x
  fromBits      x   = x

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Default UInt where
  default = 0


--------------------
-- Float
--------------------
instance Eq Float where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Float where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Float where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Float where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num Float where
  abs    x = primUndefined
  signum x = primUndefined

instance EuclideanRing Float where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing Float where
  recip x = 1 / x

instance Field Float where

instance Floating Float where
  fromFloat x = x
  sqrt      x = primUndefined

instance Trig Float where
  sine   x = primUndefined
  cosine x = primUndefined
  exp    x = primUndefined
  exp2   x = primUndefined
  log    x = primUndefined
  log10  x = primUndefined
  log2   x = primUndefined
  pow  x y = primUndefined

instance Bits Float where
  bitAnd        x y = primUndefined
  bitNot        x   = primUndefined
  bitOr         x y = primUndefined
  bitXor        x y = primUndefined
  bitShiftLeft  x y = primUndefined
  bitShiftRight x y = primUndefined
  bitReverse    x   = primUndefined
  toBits        x   = primUndefined
  fromBits      x   = primUndefined

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Default Float where
  default = 0

negate :: Ring a => a -> a
negate x = 0 - x

floatToInt :: Float -> Int
floatToInt x = primUndefined

floatToUInt :: Float -> UInt
floatToUInt x = primUndefined

f64ToInt :: F64 -> Int
f64ToInt x = primUndefined

f64ToUInt :: F64 -> UInt
f64ToUInt x = primUndefined


--------------------
-- F64
--------------------
instance Eq F64 where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord F64 where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring F64 where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring F64 where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num F64 where
  abs    x = primUndefined
  signum x = primUndefined

instance EuclideanRing F64 where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing F64 where
  recip x = 1 / x

instance Field F64 where

instance Floating F64 where
  fromFloat x = primUndefined
  sqrt      x = primUndefined

instance Trig F64 where
  sine   x = primUndefined
  cosine x = primUndefined
  exp    x = primUndefined
  exp2   x = primUndefined
  log    x = primUndefined
  log10  x = primUndefined
  log2   x = primUndefined
  pow  x y = primUndefined

instance Bits F64 where
  bitAnd        x y = primUndefined
  bitNot        x   = primUndefined
  bitOr         x y = primUndefined
  bitXor        x y = primUndefined
  bitShiftLeft  x y = primUndefined
  bitShiftRight x y = primUndefined
  bitReverse    x   = primUndefined
  toBits        x   = primUndefined
  fromBits      x   = primUndefined

instance Semigroup F64 where
  append x y = x + y

instance Monoid F64 where
  mempty = 0

instance Default F64 where
  default = 0

fastFloor :: F64 -> F64
fastFloor x = primUndefined

floor :: F64 -> F64
floor x = primUndefined

fma :: F64 -> F64 -> F64 -> F64
fma x y z = primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
-- TODO: More efficient gcd algorithm
data Rational = Rational (#Int, Int#)

gcd :: Int -> Int -> Int
gcd x y =
  fst' <| loop (#a, b#) = (#abs x, abs y#) while b > 0 do
    (#b, a % b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational (#x / d, y / d#)
  where
    d = gcd x y

rational :: Int -> Int -> Rational
rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator (Rational (#n, _#)) = n

denominator :: Rational -> Int
denominator (Rational (#_, d#)) = d

instance Eq Rational where
  eq  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = eq (xn * yd) (yn * xd)
  neq (Rational (#xn, xd#)) (Rational (#yn, yd#)) = neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = lt  (xn * yd) (yn * xd)
  lte (Rational (#xn, xd#)) (Rational (#yn, yd#)) = lte (xn * yd) (yn * xd)
  gt  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = gt  (xn * yd) (yn * xd)
  gte (Rational (#xn, xd#)) (Rational (#yn, yd#)) = gte (xn * yd) (yn * xd)

instance Semiring Rational where
  zero = Rational (#0, 1#)
  one  = Rational (#1, 1#)
  add (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yd + yn * xd) (xd * yd)
  mul (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yn) (xd * yd)

instance Ring Rational where
  sub (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yd - yn * xd) (xd * yd)
  fromInt x                                       = Rational (#fromInt x, 1#)

instance Num Rational where
  abs    (Rational (#xn, xd#)) = Rational (#abs xn, xd#)
  signum (Rational (#xn, _#))  = Rational (#signum xn, 1#)

instance DivisionRing Rational where
  recip (Rational (#n, d#)) =
    if n == 0 then
      Rational (#0, 1#)
    else
      d // n

instance EuclideanRing Rational where
  rem x y = primUndefined
  div x y = x * recip y

instance Field Rational where

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

instance Default Rational where
  default = 0

rationalToFloat :: Rational -> Float
rationalToFloat r = fromInt (numerator r) / fromInt (denominator r)


--------------------
-- Complex
--------------------
data Complex = Complex (#F64, F64#)

realPart :: Complex -> F64
realPart (Complex (#r, _#)) = r

imagPart :: Complex -> F64
imagPart (Complex (#_, i#)) = i

mkPolar :: F64 -> F64 -> Complex
mkPolar r theta = Complex (#r * cosine theta, r * sine theta#)

cis :: F64 -> Complex
cis theta = Complex (#cosine theta, sine theta #)

polar :: Complex -> (F64, F64)
polar c = (magnitude c, phase c)

sqrMagnitude :: Complex -> F64
sqrMagnitude (Complex (#r, i#)) = (r * r) + (i * i)

magnitude :: Complex -> F64
magnitude (Complex (#r, i#)) = sqrt ((r * r) + (i * i))

conjugate :: Complex -> Complex
conjugate (Complex (#r, i#)) = Complex (#r, negate i#)

phase :: Complex -> F64
phase c = primUndefined
-- TODO: ADD ATAN2!
-- phase (Complex (#r, i#)) = atan2 r i

instance Eq Complex where
  eq  (Complex (#rx, ix#)) (Complex (#ry, iy#)) = rx == ry && ix == iy
  neq (Complex (#rx, ix#)) (Complex (#ry, iy#)) = rx /= ry || ix /= iy

instance Semiring Complex where
  zero                                          = Complex (#0, 0#)
  one                                           = Complex (#1, 0#)
  add (Complex (#rx, ix#)) (Complex (#ry, iy#)) = Complex (#rx + ry, ix + iy#)
  mul (Complex (#rx, ix#)) (Complex (#ry, iy#)) = Complex (#rx * ry - ix * iy, rx * iy + ix * ry#)

instance Ring Complex where
  sub (Complex (#rx, ix#)) (Complex (#ry, iy#)) = Complex (#rx - ry, ix - iy#)
  fromInt z                                     = Complex (#fromInt z, 0#)

instance EuclideanRing Complex where
  div x y = Complex (#zx / yIntoConjugate, zi / yIntoConjugate#)
    where
      conjugateY = conjugate y
      yIntoConjugate = y * conjugateY |> realPart
      (Complex (#zx, zi#)) = x * conjugateY
  rem x y = x - y * w
    where
      z = x / y
      w = case z of
        Complex (#rz, iz#) -> Complex (#floor rz, floor iz#)

instance DivisionRing Complex where
  recip (Complex (#r, i#)) = Complex (#r / sqrRsqrI, negate (i / sqrRsqrI)#)
    where
      sqrRsqrI = (r * r) + (i * i)

instance Num Complex where
  abs z    = Complex (#magnitude z, 0#)
  signum z =
    case z of
      Complex (#r, i#) ->
        if r == 0 && i == 0 then 0 else
          let m = magnitude z in
            Complex (#r / m, i / m#)

instance Field Complex where

instance Floating Complex where
  fromFloat f = Complex (#fromFloat f, 0#)
  sqrt z = case z of
    Complex (#r, i#) ->
      if r == 0 then
        let
          u = sqrt ((abs i) / r)
          v = if i < 0 then negate u else u
        in
          Complex (#u, v#)
      else
        let
          u = sqrt (2 * (magnitude z + abs r))
          v = u / 2
        in
          if r > 0 then
            Complex (#v, i / u#)
          else
            let
              vByI = if i < 0 then negate v else v
            in
              Complex (#(abs i) / u, vByI#)

-- TODO - ADD SINEH and COSINEH
-- instance Trig Complex where
--   sine (Complex (#r, i#)) = Complex (#sine r * cosineh i, cosine r * sineh i)
--   cosine (Complex (#r, i#)) = Complex (#cosine r * cosineh i, (negate <| sine r) * sineh i)
--   exp    :: a -> a
--   exp2   :: a -> a
--   log    :: a -> a
--   log10  :: a -> a
--   log2   :: a -> a
--   pow    :: a -> a -> a

--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Eq a => Eq (Maybe a) where
  eq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> True
          _       -> False

      Just x ->
        case my of
          Nothing -> False
          Just y  -> eq x y
  neq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> False
          _       -> True

      Just x ->
        case my of
          Nothing -> True
          Just y  -> neq x y

instance Default (Maybe a) where
  default = nothing

instance Semigroup a => Semigroup (Maybe a) where
  append mx my =
    case mx of
      Nothing -> my
      Just x  ->
        case my of
          Nothing -> mx
          Just y  -> Just (append x y)

instance Monoid (Maybe a) where
  mempty = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance UFunctor Maybe where
  umap f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> Nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)
  map3 f mx my mz =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            case mz of
              Nothing -> nothing
              Just z  ->
                Just (f x y z)
  map4 f mw mx my mz =
    case mw of
      Nothing -> nothing
      Just w  ->
        case mx of
          Nothing -> nothing
          Just x  ->
            case my of
              Nothing -> nothing
              Just y  ->
                case mz of
                  Nothing -> nothing
                  Just z  ->
                    Just (f w x y z)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

instance Alternative Maybe where
  empty           = nothing
  alternative x y =
    case x of
      Nothing -> y
      _       -> x

-- This are wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
maybe :: .b -> .(.a -> .b) -> Maybe .a -> .b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x

-- This are wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
fromMaybe :: .a -> Maybe .a -> .a
fromMaybe defaultValue m =
  case m of
    Nothing -> defaultValue
    Just x  -> x


--------------------
-- Either
--------------------
data Either a b = Left a | Right b

either :: .(.a -> .c) -> .(.b -> .c) -> Either .a .b -> .c
either lf rf e =
  case e of
    Left  lx -> lf lx
    Right rx -> rf rx


--------------------
-- Ptr
--------------------
ptrMalloc :: UInt -> Ptr *a
ptrMalloc capacity = primUndefined

ptrRealloc :: UInt -> Ptr *a -> Ptr *a
ptrRealloc capacity ptr = primUndefined

ptrFree :: Ptr .a -> *()
ptrFree ptr = primUndefined

-- unsafePtrPeek :: UInt -> *Ptr a -> (#a, *Ptr a#)
-- unsafePtrPeek index ptr = primUndefined

unsafePtrPoke :: UInt -> *a -> Ptr *a -> Ptr *a
unsafePtrPoke index value ptr = primUndefined

unsafePtrSwapElement :: UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
unsafePtrSwapElement index element ptr = primUndefined

unsafePtrPokeChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> Ptr *a
unsafePtrPokeChecked str capacity index value ptr =
  unsafePtrPoke (boundsCheck str index capacity) value ptr

unsafePtrSwapElementChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
unsafePtrSwapElementChecked str capacity index element ptr =
  unsafePtrSwapElement (boundsCheck str index capacity) element ptr

-- TODO: Checked readArray and writeArray!

-- unsafeCastPtr :: *Ptr a -> *Ptr b
-- unsafeCastPtr = primUndefined


----------------------
-- MutRef: A hack to allow for recursively owned types...
----------------------
-- data MutRef a = MutRef (Ptr (Maybe a))

-- HACK / NOTE: mutRef expects the first argument to be CONSTANT (Need to support this concept in the type system...)
mutRef :: Maybe *a -> Ptr (Maybe *a)
mutRef x =
  primUndefined

mutRefTake :: (() -> *a) -> (#*a, Ptr (Maybe *a)#)
mutRefTake mkFn =
  case unsafePtrSwapElement 0 Nothing (mutRef Nothing) of
    (#mx, ptr1#) ->
      case mx of
        Just x  -> (#x, ptr1#)
        Nothing -> (#mkFn (), ptr1#)

mutRefPut :: *a -> Ptr (Maybe *a) -> ()
mutRefPut x ptr =
  case unsafePtrPoke 0 (Just x) ptr of
    _ -> ()


--------------------
-- Array
--------------------

data Range (n :: Nat) = Range UInt UInt UInt
data Index (n :: Nat) = Index UInt

each :: Range n
each = Range 0 1 0

unsafeEmptyArray :: () -> *Array n a
unsafeEmptyArray u = primUndefined

freezeArray :: *Array n a -> .Array n a
freezeArray a = primUndefined

readArray :: Index n -> Array n a -> a
readArray i a = primUndefined

readArrayU :: Index n -> Array n .a -> (#.a, Array n .a#)
readArrayU i a = primUndefined

writeArray :: Index n -> a -> *Array n a -> *Array n a
writeArray i x a = primUndefined

writeArrayChecked :: Array n Char -> UInt -> Index n -> a -> *Array n a -> *Array n a
writeArrayChecked str capacity (Index i) x a =
  writeArray (Index (boundsCheck str capacity i)) x a

readArrayChecked :: Array n Char -> UInt -> Index n -> Array n a -> a
readArrayChecked str capacity (Index i) a =
  readArray (Index (boundsCheck str capacity i)) a

instance Default a => Default (Array n a) where
  default = arrayFrom default

arrayFrom :: a -> .Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i x a

instance Foldable (Array n) where
  fold a =
    loop x = mempty for i <- each do
      x <> readArray i a
  foldl f init a0 =
    fst' <| loop (#x, a1#) = (#init, a0#) for i <- each do
      case readArrayU i a1 of
        (#y, a2#) ->
          (#f x y, a2#)

--------------------
-- Index
--------------------
-- TODO: Hide Index constructor outside of base.necro for safety
-- TODO: Use Max to restrict UInt to range?
unsafeUIntToIndex :: UInt -> Index n
unsafeUIntToIndex i = Index i

indexToUInt :: Index n -> UInt
indexToUInt (Index i) = i

bitReverseIndex :: Index n -> Index n
bitReverseIndex (Index i) = Index (bitReverse i)

toIndexMultiple :: Index n -> Index (NatMul n (NatMax k 1))
toIndexMultiple (Index i) = Index i

audioSampleRate' :: UInt
audioSampleRate' = 48000

audioBlockSize' :: UInt
audioBlockSize' = 64

audioOverSampleAmount :: UInt
audioOverSampleAmount = 32

audioBlockSize :: UInt
audioBlockSize = audioBlockSize' * audioOverSampleAmount

audioBlockSizeF :: Float
audioBlockSizeF = fromUInt audioBlockSize

audioSampleRate :: UInt
audioSampleRate = audioSampleRate' * audioOverSampleAmount

audioSampleRateF :: F64
audioSampleRateF = fromUInt audioSampleRate

audioBlocksPerSecond :: UInt
audioBlocksPerSecond = audioSampleRate' / audioBlockSize'

audioBlockDelta :: Rational
audioBlockDelta = 1 // fromUInt audioBlocksPerSecond

audioSampleDelta :: Rational
audioSampleDelta = 1 // fromUInt audioSampleRate

-- -- NOTE: Assumes audioBlockSize is a power of 2!
-- audioBlockSizeLog2 :: UInt
-- audioBlockSizeLog2 =
--   fst' <| loop (#bits, n#) = (#0, audioBlockSize#) while n > 0 do
--     (#bits + 1, bitShiftRight n 1#)

audioSampleOffset :: UInt
audioSampleOffset = 0


--------------------
-- Channel
--------------------
data Channel = ChannelEnd | BlockRate F64 | AudioRate (Array BlockSize F64)

outAudioBlock :: UInt -> Array BlockSize F64 -> *World -> *World
outAudioBlock c a w = primUndefined

outChannel :: UInt -> Channel -> *World -> *World
outChannel n c w =
  case c of
    ChannelEnd  -> w
    BlockRate _ -> w
    AudioRate b -> outAudioBlock n b w

audioInitArray :: () -> *Array BlockSize F64
audioInitArray u =
  snd' <| loop (#i, a#) = (#0, unsafeEmptyArray ()#) while i < audioSampleOffset do
    (#i + 1, writeArray (Index i) 0 a#)

mapChannel :: (F64 -> F64) -> Channel -> Channel
mapChannel f c =
  case c of
    ChannelEnd  -> ChannelEnd
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = audioInitArray () for i <- offsetToEndRange do
        writeArray i (f (readArray i b)) a
  where
    offsetToEndRange = Range audioSampleOffset 1 0

mapChannel2 :: (F64 -> F64 -> F64) -> Channel -> Channel -> Channel
mapChannel2 f cx cy =
  case cx of
    ChannelEnd  -> ChannelEnd
    BlockRate x ->
      case cy of
        ChannelEnd  -> ChannelEnd
        BlockRate y ->
          BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f x (readArray i y)) a
    AudioRate x ->
      case cy of
        ChannelEnd  -> ChannelEnd
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) y) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) (readArray i y)) a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()

constTrue :: a -> Bool
constTrue _ = True

accumulateChannel1 :: Default s => (F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Channel -> Channel
accumulateChannel1 f isRunningFunc input1 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case out of
        (s, a) ->
          case isRunningFunc s of
            False -> ChannelEnd
            _     -> AudioRate a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()
    out ~ (default, primUndefined) =
      case out of
        (state, _) ->
          let
            (#state', o'#) =
              case input1 of
                ChannelEnd          -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
          in
            (state', freezeArray o')

accumulateChannel2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Channel -> Channel -> Channel
accumulateChannel2 f isRunningFunc input1 input2 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case input2 of
        ChannelEnd -> ChannelEnd
        _          ->
          case out of
            (s, a) ->
              case isRunningFunc s of
                False -> ChannelEnd
                _     -> AudioRate a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()
    out ~ (default, primUndefined) =
      case out of
        (state, _) ->
          let
            (#state', o'#) =
              case input1 of
                ChannelEnd          -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    ChannelEnd          -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    ChannelEnd          -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
          in
            (state', freezeArray o')

accumulateChannel3 :: Default s => (F64 -> F64 -> F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Channel -> Channel -> Channel -> Channel
accumulateChannel3 f isRunningFunc input1 input2 input3 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case input2 of
        ChannelEnd -> ChannelEnd
        _          ->
          case input3 of
            ChannelEnd -> ChannelEnd
            _          ->
              case out of
                (s, a) ->
                  case isRunningFunc s of
                    False -> ChannelEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()
    out ~ (default, primUndefined) =
      case out of
        (state, _) ->
          let
            (#state', o'#) =
              case input1 of
                ChannelEnd          -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    ChannelEnd          -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        ChannelEnd          -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        ChannelEnd          -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    ChannelEnd          -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        ChannelEnd          -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        ChannelEnd          -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
          in
            (state', freezeArray o')

accumulateChannel1U :: (() -> *s) -> (F64 -> *s -> (#*s, F64#)) -> (*s -> (#*s, Bool#)) -> Channel -> Channel
accumulateChannel1U mkState f isRunningFunc input1 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case out of
        (#isRunning, a#) ->
          case isRunning of
            False -> ChannelEnd
            _     -> AudioRate a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                ChannelEnd          -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)

accumulateChannel2U :: (() -> *s) -> (F64 -> F64 -> *s -> (#*s, F64#)) -> (*s -> (#*s, Bool#)) -> Channel -> Channel -> Channel
accumulateChannel2U mkState f isRunningFunc input1 input2 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case input2 of
        ChannelEnd -> ChannelEnd
        _          ->
          case out of
            (#isRunning, a#) ->
              case isRunning of
                False -> ChannelEnd
                _     -> AudioRate a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                ChannelEnd          -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    ChannelEnd          -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    ChannelEnd          -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)

instance Eq Channel where
  eq x y =
    case x of
      ChannelEnd ->
        case y of
          ChannelEnd -> True
          _          -> False

      BlockRate xv ->
        case y of
          BlockRate yv -> xv == yv
          _            -> False

      AudioRate xa ->
        case y of
          AudioRate ya ->
            loop cond = True for i <- each do
              cond && readArray i xa == readArray i ya
          _ -> False

  neq x y = not (eq x y)

instance Semiring Channel where
  zero    = BlockRate 0
  one     = BlockRate 1
  add x y = mapChannel2 add x y
  mul x y = mapChannel2 mul x y

instance Ring Channel where
  sub x y   = mapChannel2 sub x y
  fromInt i = BlockRate (fromInt i)

instance EuclideanRing Channel where
  div x y = mapChannel2 div x y
  rem x y = mapChannel2 rem x y

instance DivisionRing Channel where
  recip x = mapChannel recip x

instance Num Channel where
  signum x  = mapChannel signum x
  abs x     = mapChannel abs x

instance Field Channel where

instance Floating Channel where
  fromFloat f = BlockRate (fromFloat f)
  sqrt x      = mapChannel sqrt x

instance Semigroup Channel where
  append x y = x + y

instance Monoid Channel where
  mempty = 0

instance Default Channel where
  default = 0


--------------------
-- FFT
--------------------
-- https://www.dspguide.com/ch12/1.htm
-- FFT bins are represented as complex numbers wherein phase is encoded as the angle of a 2D vector and amplitude is encoded as the magnitude of the 2D vector.
data FFT f k   = FFT (f (Array (NatMul BlockSize (NatMax k 1)) Complex))
data FFTWindow = FFTWindow (Array BlockSize F64)
-- TODO: FFT windowing!

uintToInt :: UInt -> Int
uintToInt x = primUndefined

fromUInt :: Ring a => UInt -> a
fromUInt x = fromInt (uintToInt x)

pi :: Floating a => a
pi = 3.1415926535897932384626433

twoPi :: Floating a => a
twoPi = pi * 2

twoOverPi :: Floating a => a
twoOverPi = 2 / pi

halfPi :: Floating a => a
halfPi = pi * 0.5

threeHalfPi :: Floating a => a
threeHalfPi = 3 * halfPi

fourOverPi :: Floating a => a
fourOverPi = 4 / pi

quarterPi :: Floating a => a
quarterPi = pi * 0.25

sixthPi :: Floating a => a
sixthPi = pi / 6

twelthPi :: Floating a => a
twelthPi = pi / 12

tanSixthPi :: F64
tanSixthPi = tanF64 sixthPi

tanTwelthPi :: F64
tanTwelthPi = tanF64 twelthPi

tau :: Floating a => a
tau = 2 * pi

-- hanning :: FFTWindow
-- hanning =
--   FFTWindow <| freezeArray <| loop a = unsafeEmptyArray () for i <- each do
--     writeArray i (0.5 - 0.5 * cosine (tau * fromUInt (indexToUInt i + 1) / fromUInt sampleRate)) a

-- hamming :: FFTWindow
-- hamming =
--   FFTWindow <| freezeArray <| loop a = unsafeEmptyArray () for i <- each do
--     writeArray i (0.54 - 0.46 * cosine (tau * fromUInt (indexToUInt i + 1) / fromUInt sampleRate)) a

-- -- TODO: Look more into this...
-- -- TODO: Shift right after bit reverse?
-- bitRevFFTArray :: Array BlockSize F64 -> FFTWindow -> *Array (NatMul BlockSize (NatMax k 1)) Complex
-- bitRevFFTArray audioBuffer (FFTWindow windowBuffer) =
--   loop a' = unsafeEmptyArray () for i <- each do
--     let
--       sample = readArray (bitReverseIndex i) audioBuffer
--       winval = readArray i windowBuffer
--       c      = Complex (#sample * winval, 0#)
--     in
--       writeArray (toIndexMultiple i) c a'

-- -- NOTE: bitReverse Cooley-Tukey FFT algorithm
-- -- TODO: Finish!
-- -- TODO: Compute log2n somehow
-- -- TODO: Windowing function!
-- fftChannel :: Array BlockSize F64 -> FFTWindow -> Array (NatMul BlockSize (NatMax 1 1)) Complex
-- fftChannel a w =
--   freezeArray <| snd' <|
--     loop (#i, a0#) = (#0, bitRevFFTArray a w#) while i < audioBlockSizeLog2 do
--       let
--         m1              = bitShiftLeft  1  i
--         m2              = bitShiftRight m1 1
--         wm              = 0 -- Compute somehow
--         (#_, _, aout1#) =
--           loop (#j, w, a1#) = (#0, 1, a0#) while j < m2 do
--             let
--               (#_, aout0#) =
--                 loop (#k, a2#) = (#j, a1#) while k < audioBlockSize do
--                   let
--                     ki        = Index k
--                     km2i      = Index (k + m2)
--                     (#t, a3#) = readArrayU km2i a2
--                     (#u, a4#) = readArrayU ki a3
--                     t'        = t * w
--                   in
--                     (#k + 1, writeArray km2i (u - t') (writeArray ki (u + t') a4)#)
--             in
--               (#j + 1, w * wm, aout0#)
--       in
--         (#i + 1, aout1#)

--------------------
-- AudioFormat
--------------------
data Mono a      = Mono a
data Stereo a    = Stereo (#a, a#)
data Quad a      = Quad (#a, a, a, a#)
data Ambisonic a = Ambisonic (#a, a, a, a#)
data Audio f     = Audio (f Channel)

-- TODO: Equal power panning
class (Functor f, FunctorN f, Applicative f, Foldable f) => AudioFormat f where
  accumulate1 :: Default s => (F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Audio f -> Audio f
  accumulate2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Audio f -> Audio f -> Audio f
  accumulate3 :: Default s => (F64 -> F64 -> F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Audio f -> Audio f -> Audio f -> Audio f
  pan         :: Audio Mono -> Audio f -> Audio Stereo
  outAudio    :: UInt -> Audio f -> *World -> *World

instance Functor Mono where
  map f (Mono x) = Mono (f x)

instance FunctorN Mono where
  map2 f (Mono x) (Mono y)                   = Mono (f x y)
  map3 f (Mono x) (Mono y) (Mono z)          = Mono (f x y z)
  map4 f (Mono w) (Mono x) (Mono y) (Mono z) = Mono (f w x y z)

instance Applicative Mono where
  pure x               = Mono x
  ap (Mono f) (Mono x) = Mono (f x)

instance Foldable Mono where
  fold (Mono x)      = x
  foldl f i (Mono x) = f i x

instance AudioFormat Mono where
  outAudio  n (Audio (Mono c))  w                                            = outChannel n c w
  accumulate1 f isRunning (Audio (Mono c))                                   = Audio (Mono (accumulateChannel1 f isRunning c))
  accumulate2 f isRunning (Audio (Mono x)) (Audio (Mono y))                  = Audio (Mono (accumulateChannel2 f isRunning x y))
  accumulate3 f isRunning (Audio (Mono x)) (Audio (Mono y)) (Audio (Mono z)) = Audio (Mono (accumulateChannel3 f isRunning x y z))
  pan (Audio (Mono amount)) (Audio (Mono input))                             = Audio (Stereo (#input * (1 - amount), input * amount#))

instance Functor Stereo where
  map f (Stereo (#x, y#)) = Stereo (#f x, f y#)

instance FunctorN Stereo where
  map2 f (Stereo (#x1, x2#)) (Stereo (#y1, y2#))                                         = Stereo (#f x1 y1, f x2 y2#)
  map3 f (Stereo (#x1, x2#)) (Stereo (#y1, y2#)) (Stereo (#z1, z2#))                     = Stereo (#f x1 y1 z1, f x2 y2 z2#)
  map4 f (Stereo (#w1, w2#)) (Stereo (#x1, x2#)) (Stereo (#y1, y2#)) (Stereo (#z1, z2#)) = Stereo (#f w1 x1 y1 z1, f w2 x2 y2 z2#)

instance Applicative Stereo where
  pure x                                     = Stereo (#x, x#)
  ap (Stereo (#f1, f2#)) (Stereo (#x1, x2#)) = Stereo (#f1 x2, f2 x2#)

instance Foldable Stereo where
  fold (Stereo (#l, r#))      = l <> r
  foldl f i (Stereo (#l, r#)) = f (f i l) r

instance AudioFormat Stereo where
  outAudio  n (Audio (Stereo (#l, r#))) w                                                                     = outChannel (n + 1) r (outChannel n l w)
  accumulate1 f isRunning (Audio (Stereo (#l, r#)))                                                           = Audio (Stereo (#accumulateChannel1 f isRunning l, accumulateChannel1 f isRunning r#))
  accumulate2 f isRunning (Audio (Stereo (#xl, xr#))) (Audio (Stereo (#yl, yr#)))                             = Audio (Stereo (#accumulateChannel2 f isRunning xl yl, accumulateChannel2 f isRunning xr yr#))
  accumulate3 f isRunning (Audio (Stereo (#xl, xr#))) (Audio (Stereo (#yl, yr#))) (Audio (Stereo (#zl, zr#))) = Audio (Stereo (#accumulateChannel3 f isRunning xl yl zl, accumulateChannel3 f isRunning xr yr zr#))
  pan (Audio (Mono amount)) (Audio (Stereo (#l, r#)))                                                         = Audio (Stereo (#l * (1 - amount), r * amount#))

instance AudioFormat f => Eq (Audio f) where
  eq  (Audio x) (Audio y) = foldl (\cond x -> cond && x) True  (map2 eq x y)
  neq (Audio x) (Audio y) = foldl (\cond x -> cond || x) False (map2 neq x y)

instance AudioFormat f => Semiring (Audio f) where
  zero                    = Audio (pure 0)
  one                     = Audio (pure 1)
  add (Audio x) (Audio y) = Audio (map2 add x y)
  mul (Audio x) (Audio y) = Audio (map2 mul x y)

instance AudioFormat f => Ring (Audio f) where
  fromInt i               = Audio (pure (fromInt i))
  sub (Audio x) (Audio y) = Audio (map2 sub x y)

instance AudioFormat f => EuclideanRing (Audio f) where
  div (Audio x) (Audio y) = Audio (map2 div x y)
  rem (Audio x) (Audio y) = Audio (map2 rem x y)

instance AudioFormat f => DivisionRing (Audio f) where
  recip (Audio cs) = Audio (map recip cs)

instance AudioFormat f => Num (Audio f) where
  signum (Audio c) = Audio (map signum c)
  abs    (Audio c) = Audio (map abs c)

instance AudioFormat f => Field (Audio f) where

instance AudioFormat f => Floating (Audio f) where
  fromFloat f = Audio (pure (fromFloat f))
  sqrt (Audio x) = Audio (map sqrt x)

instance AudioFormat f => Semigroup (Audio f) where
  append (Audio x) (Audio y) = Audio (map2 append x y)

instance AudioFormat f => Monoid (Audio f) where
  mempty = Audio (pure mempty)

--------------------
-- UGens
--------------------

stereo :: Audio Mono -> Audio Mono -> Audio Stereo
stereo (Audio (Mono l)) (Audio (Mono r)) =
  Audio (Stereo (#l, r#))

-- NOTE: Turns out floor is faster than fastFloor???
accumulateSaw :: F64 -> F64 -> (#F64, F64#)
accumulateSaw freq acc =
  (#acc3, out#)
  where
    acc2 = fma freq recipSampleRate acc
    acc3 = acc2 - floor acc2
    out  = fma acc3 2.0 (-1.0)

saw :: AudioFormat f => Audio f -> Audio f
saw freq =
  accumulate1 accumulateSaw constTrue freq

accumulatePulse :: F64 -> F64 -> F64 -> (#F64, F64#)
accumulatePulse width freq acc =
  (#acc3, out#)
  where
    acc2 = fma freq recipSampleRate acc
    acc3 = acc2 - floor acc2
    out  = fma (fromInt (boolToInt (acc3 > width))) 2.0 (-1.0)

pulse :: AudioFormat f => Audio f -> Audio f -> Audio f
pulse width freq =
  accumulate2 accumulatePulse constTrue width freq

-- TODO: Use curve!
accumulatePerc :: (#F64, F64, F64, F64#) -> F64 -> F64 -> (#F64, F64#)
accumulatePerc (#attackTime, recipAttackTime, recipDecayTime, curve#) input state =
  (#state', out#)
  where
    state'    = state + recipSampleRate
    attackEnv = state' * recipAttackTime * isAttack
    decayEnv  = 1 - ((state' - attackTime) * recipDecayTime)
    isAttack  = fromInt (boolToInt (state' <= attackTime))
    isDecay   = 1 - isAttack
    env       = attackEnv * isAttack + decayEnv * isDecay
    out       = env * input

percIsRunning :: F64 -> F64 -> Bool
percIsRunning totalTime state =
  state < totalTime

perc :: AudioFormat f => F64 -> F64 -> F64 -> Audio f -> Audio f
perc attackTime decayTime curve input =
  accumulate1 (accumulatePerc (#attackTime, recip attackTime, recip decayTime, curve#)) (percIsRunning (attackTime + decayTime)) input

data AudioBuffer s = AudioBuffer (.Array (NatNextPowerOfTwo (NatMul SampleRate (NatMax s 1))) F64)

data DelayState s = DelayState (#.AudioBuffer s, UInt, F64#)

mkDelayState :: F64 -> () -> *DelayState s
mkDelayState initialDelayTime _ = DelayState (#AudioBuffer (arrayFrom 0), 0, initialDelayTime#)

-- proxyVal :: Proxy n -> UInt
-- proxyVal p = primUndefined

-- TODO: Easy way out: arraySize combinator
-- TODO: Way to have buffer size exist in types and in expressions
-- TODO: Interpolate delayTime!
-- TODO: delay playback speed? Reverse delay? delay bank etc?
-- TODO: initialDelayTime, maxDelayTime, audioBufferSize, etc

-- Linear interpolation scheme for delay time!
    -- delayTime'       = ...

accumulateDelay :: UInt -> F64 -> F64 -> *DelayState s -> (#*DelayState s, F64#)
accumulateDelay bufferSizeMinus1 targetDelayTime input (DelayState (#AudioBuffer buffer0, index, delayTime#)) =
  (#DelayState (#AudioBuffer buffer2, index + 1, delayTime'#), input + out#)
  where
    delayTime'       = targetDelayTime
    delayIndex       = bitAnd (index + f64ToUInt (delayTime' * audioSampleRateF)) bufferSizeMinus1
    (#out, buffer1#) = readArrayU (Index index) buffer0
    buffer2          = writeArray (Index delayIndex) input buffer1

-- accumulateDelayGo :: *DelayState 2 -> (#*DelayState 2, F64#)
-- accumulateDelayGo state = accumulateDelay 1024 1 0 state

-- delay :: AudioFormat f => Audio f -> Audio f -> Audio f
-- delay delayTime input =
--   accumulateChannel2U (mkDelayState 1) accumulateDelay (\s -> (#s, True#)) delayTime input


--------------------
-- Seq
--------------------
data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
data SeqValue a = SeqValue (#Rational, SeqControl, Maybe a#)
data Seq a      = Seq (() -> SeqValue a)

mergeSeqValueTimes :: Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes xt xc yt yc =
  case xc of
    SeqPure -> yt
    _ ->
      case yc of
        SeqPure -> xt
        _       -> min xt yt

mergeSeqValueTimes3 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes3 xt xc yt yc zt zc =
  case xc of
    SeqPure -> mergeSeqValueTimes yt yc zt zc
    _ ->
      case yc of
        SeqPure -> mergeSeqValueTimes xt xc zt zc
        _       ->
          case zc of
            SeqPure -> mergeSeqValueTimes xt xc yt yc
            _       -> min (min xt yt) zt

mergeSeqValueTimes4 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes4 wt wc xt xc yt yc zt zc =
  case wc of
    SeqPure -> mergeSeqValueTimes3 xt xc yt yc zt zc
    _       ->
      case xc of
        SeqPure -> mergeSeqValueTimes3 wt wc yt yc zt zc
        _ ->
          case yc of
            SeqPure -> mergeSeqValueTimes3 wt wc xt xc zt zc
            _       ->
              case zc of
                SeqPure -> mergeSeqValueTimes3 wt wc xt xc yt yc
                _       -> min (min (min wt xt) yt) zt


instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    if lt (fromEnum x) (fromEnum y) then
      x
    else
      y

instance Monoid SeqControl where
  mempty = SeqPure

instance Eq SeqControl where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

seqControlFromEnumAlt :: SeqControl -> Int
seqControlFromEnumAlt s =
  case s of
    SeqNormal   -> 0
    SeqLoopEnd  -> 1
    SeqPure     -> 2
    SeqBlockEnd -> 3
    SeqEnd      -> 4

seqControlAlternative :: SeqControl -> SeqControl -> SeqControl
seqControlAlternative x y =
  if lt (seqControlFromEnumAlt x) (seqControlFromEnumAlt y) then
    x
  else
    y

instance Functor SeqValue where
  map f (SeqValue (#t, c, x#)) =
    SeqValue (#t, c, map f x#)

instance FunctorN SeqValue where
  map2 f (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#mergeSeqValueTimes xt xc yt yc, xc <> yc, map2 f xv yv#)
  map3 f (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) (SeqValue (#zt, zc, zv#)) =
    SeqValue (#mergeSeqValueTimes3 xt xc yt yc zt zc, xc <> yc <> zc, map3 f xv yv zv#)
  map4 f (SeqValue (#wt, wc, wv#)) (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) (SeqValue (#zt, zc, zv#)) =
    SeqValue (#mergeSeqValueTimes4 wt wc xt xc yt yc zt zc, wc <> xc <> yc <> zc, map4 f wv xv yv zv#)

instance Applicative SeqValue where
  pure x = SeqValue (#1, SeqPure, Just x#)
  ap (SeqValue (#ft, fc, fv#)) (SeqValue (#xt, xc, xv#)) =
    SeqValue (#mergeSeqValueTimes xt xc ft fc, fc <> xc, ap fv xv#)

instance Semigroup a => Semigroup (SeqValue a) where
  append (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#mergeSeqValueTimes xt xc yt yc, append xc yc, append xv yv#)

instance Monoid (SeqValue a) where
  mempty = SeqValue (#1, SeqPure, nothing#)

instance Alternative SeqValue where
  empty = SeqValue (#1, SeqEnd, nothing#)
  alternative (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#mergeSeqValueTimes xt xc yt yc, seqControlAlternative xc yc, alternative xv yv#)

instance Default (SeqValue a) where
  default = SeqValue (#1, SeqPure, nothing#)

instance Eq a => Eq (SeqValue a) where
  eq  (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, tc, yv#)) = xt == yt && xc == tc && xv == yv
  neq (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, tc, yv#)) = xt /= yt || xc /= tc || xv /= yv

instance Semiring a => Semiring (SeqValue a) where
  zero    = SeqValue (#1, SeqPure, Just zero#)
  one     = SeqValue (#1, SeqPure, Just one#)
  add x y = map2 add x y
  mul x y = map2 mul x y

instance Ring a => Ring (SeqValue a) where
  sub x y   = map2 sub x y
  fromInt i = SeqValue (#1, SeqPure, Just (fromInt i)#)

instance EuclideanRing a => EuclideanRing (SeqValue a) where
  div x y = map2 div x y
  rem x y = map2 rem x y

instance DivisionRing a => DivisionRing (SeqValue a) where
  recip x = map recip x

instance Num a => Num (SeqValue a) where
  signum x  = map signum x
  abs x     = map abs x

instance Field a => Field (SeqValue a) where

instance Floating a => Floating (SeqValue a) where
  fromFloat f = SeqValue (#1, SeqPure, Just (fromFloat f)#)
  sqrt f = map sqrt f

runSeq :: Seq a -> () -> SeqValue a
runSeq (Seq stepFunc) _ = stepFunc ()

runSeq2 :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeq2 sx sy =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#xt, xc, xv#), SeqValue (#yt, yc, yv#)#) ->
          let
            t = min xt yt
            x = if xt <= t then runSeq sx () else SeqValue (#xt - t, xc, xv#)
            y = if yt <= t then runSeq sy () else SeqValue (#yt - t, yc, yv#)
          in
            (#x, y#)

runSeq3 :: Seq a -> Seq b -> Seq c -> (#SeqValue a, SeqValue b, SeqValue c#)
runSeq3 sx sy sz =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#xt, xc, xv#), SeqValue (#yt, yc, yv#), SeqValue (#zt, zc, zv#)#) ->
          let
            t = min (min xt yt) zt
            x = if xt <= t then runSeq sx () else SeqValue (#xt - t, xc, xv#)
            y = if yt <= t then runSeq sy () else SeqValue (#yt - t, yc, yv#)
            z = if zt <= t then runSeq sz () else SeqValue (#zt - t, zc, zv#)
          in
            (#x, y, z#)

runSeq4 :: Seq a -> Seq b -> Seq c -> Seq d -> (#SeqValue a, SeqValue b, SeqValue c, SeqValue d#)
runSeq4 sw sx sy sz =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#wt, wc, wv#),SeqValue (#xt, xc, xv#), SeqValue (#yt, yc, yv#), SeqValue (#zt, zc, zv#)#) ->
          let
            t = min (min (min wt xt) yt) zt
            w = if wt <= t then runSeq sw () else SeqValue (#wt - t, wc, wv#)
            x = if xt <= t then runSeq sx () else SeqValue (#xt - t, xc, xv#)
            y = if yt <= t then runSeq sy () else SeqValue (#yt - t, yc, yv#)
            z = if zt <= t then runSeq sz () else SeqValue (#zt - t, zc, zv#)
          in
            (#w, x, y, z#)

seqValueDuration :: SeqValue a -> Rational
seqValueDuration (SeqValue (#t, _, _#)) = t

seqValueControl :: SeqValue a -> SeqControl
seqValueControl (SeqValue (#_, c, _#)) = c

runSeqOnLeft :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnLeft ls rs =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#lt, lc, _#), SeqValue (#rt, rc, rv#)#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue (#lt - t, lc, nothing#)
            r = if rt <= t then runSeq rs () else SeqValue (#rt - t, rc, rv#)
          in
            (#l, r#)

runSeqOnRight :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnRight ls rs =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#lt, lc, lv#), SeqValue (#rt, rc, _#)#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue (#lt - t, lc, lv#)
            r = if rt <= t then runSeq rs () else SeqValue (#rt - t, rc, nothing#)
          in
          (#l, r#)

instance Functor Seq where
  map f s = Seq (\_ -> map f (runSeq s ()))

instance Applicative Seq where
  pure x   = Seq (\_ -> pure x)
  ap fs xs = Seq (\_ -> ap (runSeq fs ()) (runSeq xs ()))

instance FunctorN Seq where
  map2 f sx sy       = Seq (\_ -> let (#x, y#)       = runSeq2 sx sy       in map2 f x y)
  map3 f sx sy sz    = Seq (\_ -> let (#x, y, z#)    = runSeq3 sx sy sz    in map3 f x y z)
  map4 f sw sx sy sz = Seq (\_ -> let (#w, x, y, z#) = runSeq4 sw sx sy sz in map4 f w x y z)

instance Eq a => Eq (Seq a) where
  eq  sx sy = let (#x, y#) = runSeq2 sx sy in x == y
  neq sx sy = let (#x, y#) = runSeq2 sx sy in x == y

instance Semiring a => Semiring (Seq a) where
  zero      = Seq (\_ -> pure zero)
  one       = Seq (\_ -> pure one)
  add sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 add x y)
  mul sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 mul x y)

instance Ring a => Ring (Seq a) where
  sub sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 sub x y)
  fromInt i = Seq (\_ -> pure (fromInt i))

instance EuclideanRing a => EuclideanRing (Seq a) where
  div sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 div x y)
  rem sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 rem x y)

instance DivisionRing a => DivisionRing (Seq a) where
  recip x = Seq (\_ -> map recip (runSeq x ()))

instance Num a => Num (Seq a) where
  signum x  = map signum x
  abs x     = map abs x

instance Field a => Field (Seq a) where

instance Floating a => Floating (Seq a) where
  fromFloat f = Seq (\_ -> pure (fromFloat f))
  sqrt f = map sqrt f

instance Semigroup (Seq a) where
  append sx sy = [sx sy]

instance Monoid (Seq a) where
  mempty = Seq (\_ -> SeqValue (#1, SeqPure, nothing#))

instance Alternative Seq where
  empty             = Seq (\_ -> SeqValue (#1, SeqPure, nothing#))
  alternative sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in alternative x y)

-- TODO: <|>

-- Biased BinOps
-- +@  @+  +
-- -@  @-  -
-- *@  @*  *
-- /@  @/  /
-- <@  @< @<@
-- >@  @> @>@

-- TODO:
-- %@ @%

leftConst :: a -> b -> a
leftConst x _ = x

rightConst :: a -> b -> b
rightConst _ y = y

addSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
addSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 add l r)

addSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
addSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 add l r)

subSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
subSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 sub l r)

subSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
subSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 sub l r)

mulSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 mul l r)

mulSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 mul l r)

divSeqOnLeft :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 div l r)

divSeqOnRight :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 div l r)

leftConstSeqOnLeft :: Seq a -> Seq b -> Seq a
leftConstSeqOnLeft ls _ = ls

leftConstSeqOnRight :: Seq a -> Seq b -> Seq a
leftConstSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 leftConst l r)

rightConstSeqOnLeft :: Seq a -> Seq b -> Seq b
rightConstSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 rightConst l r)

rightConstSeqOnRight :: Seq a -> Seq b -> Seq b
rightConstSeqOnRight _ rs = rs

leftConstSeqOnBoth :: Seq a -> Seq b -> Seq a
leftConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 leftConst l r)

rightConstSeqOnBoth :: Seq a -> Seq b -> Seq b
rightConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 rightConst l r)

-- addSeqOnLeftTest :: Seq Int
-- addSeqOnLeftTest =
--   [1 _ <2 3>] @+ [4 <5 6> <7 8 9>] *@ [1 2 _ 5] @- <3 4 5> @> fromInt mouseX

-- mouseBeat :: Seq Float
-- mouseBeat = fromInt mouseX <@ coolBeat

-- addSeqOnRightTest :: SeqValue Int
-- addSeqOnRightTest = runSeq (rightConstSeqOnLeft 1 2) ()

restSeqValue :: SeqValue a
restSeqValue =
  SeqValue (#1, SeqPure, nothing#)

rest :: Seq a
rest =
  Seq (\_ -> restSeqValue)

seqValueDurationMul :: Rational -> SeqValue a -> SeqValue a
seqValueDurationMul speed (SeqValue (#t, c, v#)) =
  SeqValue (#t * speed, c, v#)

seqSpeed :: Rational -> Seq a -> Seq a
seqSpeed speed seq =
  Seq (\_ -> seqValueDurationMul (recip speed) (runSeq seq ()))

bpm :: Int -> Rational
bpm tempoInBPM =
  tempoInBPM // 60

toSeq :: SeqValue a -> Seq a
toSeq sv =
  Seq (\_ -> sv)

-- altTest :: SeqValue Int
-- altTest = runSeq (alternative [0 1 _ 3] [_ <2 9> 55 _]) ()

-- seqLoop :: (Seq a -> Seq a) -> Seq a
-- seqLoop sf = Seq (\_ -> let x ~ default = runSeq (sf (toSeq x)) () in x)

-- myRecSeq :: Seq Int
-- myRecSeq = seqLoop <| \x ->
--   [1 2 <(x * 4) _ 4>]

seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  if (slot + 1) < maxSlot then
    SeqNormal
  else
    SeqLoopEnd

-- Combining nested case statements with case literals seems to break...
slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue (#t, c, v#) ->
      case c of
        SeqNormal -> (#slot, sv#)
        _         -> (#(slot + 1) % maxSlot, SeqValue (#t, controlIfNotNormal, v#)#)

seqTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
seqTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) sv

tupleTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
tupleTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (seqValueDurationMul (1 // maxSlot) sv)

interleaveTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot sv =
  slotTick slot maxSlot SeqLoopEnd sv


--------------------
-- Print
--------------------
class Print a where
  print :: a -> *World -> *World

printUInt :: UInt -> *World -> *World
printUInt u w = w

printInt :: Int -> *World -> *World
printInt i w = w

printI64 :: I64 -> *World -> *World
printI64 i w = w

printFloat :: Float -> *World -> *World
printFloat i w = w

printF64 :: F64 -> *World -> *World
printF64 f w = w

printChar :: Char -> *World -> *World
printChar c w = w

printNewline :: *World -> *World
printNewline w = printChar '\n' w

instance Print UInt where
  print x w = printUInt x w

instance Print Int where
  print x w = printInt x w

instance Print I64 where
  print x w = printI64 x w

instance Print Float where
  print x w = printFloat x w

instance Print F64 where
  print x w = printF64 x w

instance Print Char where
  print x w = printChar x w

instance Print a => Print (Array n a) where
  print a w =
    loop w' = w for i <- each do
      print (readArray i a) w'

instance Print Bool where
  print x w =
    case x of
      True -> print "True" w
      _    -> print "False" w

instance Print Rational where
  print (Rational (#n, d#)) w =
    print '(' w |> print n |> print " // " |> print d |> print ')'

instance Print a => Print (Maybe a) where
  print mx w =
    case mx of
      Nothing -> print '_' w
      Just x  -> print x w

instance Print a => Print (SeqValue a) where
  print (SeqValue (#t, _, v#)) w =
    print '(' w
    |> print t
    |> print ':'
    |> print v
    |> print ')'

printBarOnLoop :: SeqControl -> *World -> *World
printBarOnLoop c w =
  case c of
    SeqLoopEnd -> print '|' w |> print ' '
    _          -> w

instance Print a => Print (Seq a) where
  print s w = wout
    where
      tick ~ 0       = tick + audioBlockDelta
      (#_, _, wout#) =
        loop (#cont, time, w'#) = (#True, 0, w#) while cont do
          let nextValueTime ~ 0 = nextValueTime + time in
            if nextValueTime >= tick then
              (#False, 0, w'#)
            else
              case runSeq s () of
                SeqValue (#t, c, Just x#) ->
                  (#True, t, print x w' |> print ' ' |> printBarOnLoop c#)
                SeqValue (#t, c, _#) ->
                  (#True, t, printBarOnLoop c w'#)

instance Print Channel where
  print c w =
    case c of
      ChannelEnd  -> print "ChannelEnd" w
      BlockRate x -> print "BlockRate " w |> print x
      AudioRate b ->
        print '}' <| loop w' = (print '{' w) for i <- each do
          print (readArray i b) w' |> print ',' |> print ' '

instance Foldable f => Print (Audio f) where
  print (Audio f) w =
    print "Audio [" w
    |> printNewline
    |> printNewline
    |> (\w' -> foldl (\w'' c -> print c w'' |> printNewline |> printNewline) w' f)
    |> print ']'
    |> printNewline

instance Print Complex where
  print (Complex (#r, i#)) w =
    print '(' w
    |> print r
    |> print " + i"
    |> print i
    |> print ')'

instance Foldable f => Print (FFT f k) where
  print (FFT f) w =
    print "FFT [" w
    |> printNewline
    |> printNewline
    |> (\w' -> foldl (\w'' c -> print c w'' |> printNewline |> printNewline) w' f)
    |> print ']'
    |> printNewline

printLn :: Print a => a -> *World -> *World
printLn x w =
  printNewline (print x w)

trace :: Print a => a -> .b -> .b
trace x y =
  case print x primUndefined of
    _ -> y

traceLn :: Print a => a -> .b -> .b
traceLn x y =
  case printLn x primUndefined of
    _ -> y

  -- foldp :: (b -> a -> b) -> f a -> b

-- -- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     acc'
--     where
--       (#tick' ~ 0, time' ~ 0, acc' ~ mempty#) =
--         loop (#tick, time, acc#) = (#tick' + 1, time', acc'#) while time < tick do
--           case runSeq s () of
--             SeqValue (#t, _, Just x#) -> (#tick, time + t, f acc x#)
--             SeqValue (#t, _, _#)      -> (#tick, time + t, acc#)
--
-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- seqTest :: Seq Float
-- -- seqTest :: Seq Int
-- seqTest =
--   [0 _ 1 2] + [<3 4> _ <5 6> <7 8 9>]

-- seqTestGo :: SeqValue Float
-- seqTestGo =
--   runSeq seqTest ()

-- notAnInt :: Seq Float
-- notAnInt = 2 / 3

-- doubleTrouble :: SeqValue Int
-- doubleTrouble =
--   runSeq (2 * <33 44 <0 _ 1 2>>) ()

-- appendSeq :: Seq a -> Seq a -> Seq a
-- appendSeq x y = [x y]

-- appendGo :: SeqValue Rational
-- appendGo = runSeq (appendSeq 1 2) ()


----------------------
-- DynArray
----------------------

data DynTier     a = DynTier (#UInt, UInt, UInt, Ptr a#)
data DynArray    a = DynArray (#DynTier a, DynTier a#)
data DynTierIndex  = DynTierLow | DynTierHigh
data DynArrayIndex = DynArrayIndex (#DynTierIndex, UInt#)

dynTierTrace :: DynTier *a -> DynTier *a
dynTierTrace (DynTier (#cap, count, hwm, ptr#)) =
  DynTier (#cap, count, hwm, ptr#)
  |> trace "    DynTier { cap: "
  |> trace cap
  |> trace ", count: "
  |> trace count
  |> trace ", hwm: "
  |> trace hwm
  |> traceLn '}'

dynArrayTrace :: Array n Char -> DynArray *a -> DynArray *a
dynArrayTrace opName (DynArray (#low, high#)) =
  let low'  = dynTierTrace <| traceLn "  {" <| traceLn "  DynArray " <| traceLn opName low in
  let high' = traceLn " " <| traceLn "  }" <| dynTierTrace high in
  DynArray (#low', high'#)

-- dynArrayTrace :: Array n Char -> DynArray *a -> DynArray *a
-- dynArrayTrace _ a = a

dynArrayIndexEmpty :: DynArrayIndex
dynArrayIndexEmpty = DynArrayIndex (#DynTierLow, 0#)

dynTierEmpty :: UInt -> DynTier *a
dynTierEmpty capacity =
  DynTier (#capacity, 0, 0, ptrMalloc capacity#)

dynArrayEmpty :: UInt -> DynArray *a
dynArrayEmpty capacity =
  DynArray (#dynTierEmpty 0, dynTierEmpty capacity#)

dynTierPop :: DynTier *a -> (#Maybe *a, DynTier *a#)
dynTierPop (DynTier (#capacity, count, highWaterMark, ptr#)) =
  if count > 0 && count < capacity then
    case unsafePtrSwapElementChecked "dynTierPop" capacity (count - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#Just element, DynTier (#capacity, count - 1, highWaterMark, ptr'#)#)
  else
    (#Nothing, DynTier (#capacity, count, highWaterMark, ptr#)#)

dynTierSwapToEndAndDelete :: UInt -> DynTier *a -> DynTier *a
dynTierSwapToEndAndDelete index (DynTier (#capacity, count, highWaterMark, ptr#))=
  if index >= capacity then
    DynTier (#capacity, count, highWaterMark, ptr#)
  else
    case unsafePtrSwapElementChecked "dynTierSwapToEndAndDelete 1" capacity index primUndefined ptr of
      (#indexElement, ptr2#) ->
        case unsafePtrSwapElementChecked "dynTierSwapToEndAndDelete 2" capacity (count - 1) indexElement ptr2 of
          (#endElement, ptr3#) ->
            DynTier (#capacity, count - 1, highWaterMark, unsafePtrPokeChecked "dynTierSwapToEndAndDelete 3" capacity index endElement ptr3#)

-- NOTE: This assumes that the tier is correctly sized!
dynTierAppend :: *a -> DynTier *a -> DynTier *a
dynTierAppend element (DynTier (#capacity, count, highWaterMark, ptr#)) =
  DynTier (#capacity, count + 1, highWaterMark + 1, unsafePtrPokeChecked "dynTierAppend" capacity count element ptr#)

  -- |> trace "dynTierAppend, capacity: "
  -- |> trace capacity
  -- |> trace ", count: "
  -- |> traceLn count

-- TODO: Nested case branching seems broken!?!?!?
dynArrayPromoteElement :: DynArray *a -> DynArray *a
dynArrayPromoteElement (DynArray (#low, high#)) =
  case dynTierPop low of
    (#m, low'#) ->
      case m of
        Nothing      -> DynArray (#low', high#)
        Just element -> DynArray (#low', dynTierAppend element high#)

-- NOTE: This assumes that the low tier has been completely moved to the high tier
dynArrayResize :: DynArray *a -> DynArray *a
dynArrayResize (DynArray (#DynTier (#lcap, lcount, lhwm, lowPtr#), DynTier (#highCapacity, highCount, hhwm, highPtr#)#)) =
  if highCount < highCapacity then
    DynArray (#DynTier (#lcap, lcount, lhwm, lowPtr#), DynTier (#highCapacity, highCount, hhwm, highPtr#)#)
  else
    let
      newCap  = highCapacity * 2
      newLow  = DynTier (#highCapacity, highCount, 0, highPtr#)
      newHigh = DynTier (#newCap, 0, 0, ptrRealloc newCap lowPtr#)
    in
      DynArray (#newLow, newHigh#)
      |> dynArrayTrace "GROW: "

dynArrayAppend :: *a -> DynArray *a -> DynArray *a
dynArrayAppend element a =
  case dynArrayResize (dynArrayPromoteElement a) of
    DynArray (#low, high#) ->
      DynArray (#low, dynTierAppend element high#)

dynTierModifyElement :: UInt -> (*a -> *a) -> DynTier *a -> DynTier *a
dynTierModifyElement index f (DynTier (#capacity, count, highWaterMark, ptr0#)) =
  if index >= count then
    DynTier (#capacity, count, highWaterMark, ptr0#)
  else
    case unsafePtrSwapElementChecked "dynTierModifyElement 1" count index primUndefined ptr0 of
      (#element, ptr1#) ->
        DynTier (#capacity, count, highWaterMark, unsafePtrPokeChecked "dynTierModifyElement 2" count index (f element) ptr1#)

-- dynArrayModifyElement :: DynArrayIndex -> (*a -> *a) -> DynArray *a -> DynArray *a
-- dynArrayModifyElement (DynArrayIndex (#tier, index#)) f (DynArray (#low, high#)) =
--   case tier of
--     DynTierLow  -> DynArray (#dynTierModifyElement index f low, high#)
--     DynTierHigh -> DynArray (#low, dynTierModifyElement index f high#)

data DynArrayResult a = DynArrayEnd | DynArrayNothing | DynArrayJust a

  -- traceLn count <| trace ", count: " <| trace index <| trace "index: " <|

dynTierWithElement :: UInt -> (*a -> (#b, *a#)) -> DynTier *a -> (#Maybe b, DynTier *a#)
dynTierWithElement index f (DynTier (#capacity, count, highWaterMark, ptr0#)) =
  if index >= count then
    (#Nothing, DynTier (#capacity, count, highWaterMark, ptr0#)#)
  else
    case unsafePtrSwapElementChecked "dynTierWithElement 1" count index primUndefined ptr0 of
      (#element0, ptr1#) ->
        case f element0 of
          (#result, element1#) ->
            (#Just result, DynTier (#capacity, count, highWaterMark, unsafePtrPokeChecked "dynTierWithElement 2" count index element1 ptr1#)#)

dynArrayWithElement :: DynArrayIndex -> (*a -> (#b, *a#)) -> DynArray *a -> (#DynArrayResult b, DynArray *a#)
dynArrayWithElement (DynArrayIndex (#tier, index#)) f (DynArray (#low, high#)) =
  case tier of
    DynTierLow ->
      case dynTierWithElement index f low of
        (#result, low'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray (#low', high#)#)
            _            -> (#DynArrayNothing, DynArray (#low', high#)#)
    DynTierHigh ->
      case dynTierWithElement index f high of
        (#result, high'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray (#low, high'#)#)
            _            -> (#DynArrayEnd, DynArray (#low, high'#)#)

dynArrayDelete :: DynArrayIndex -> DynArray *a -> DynArray *a
dynArrayDelete (DynArrayIndex (#tier, index#)) (DynArray (#low, high#)) =
  case tier of
    DynTierLow  -> DynArray (#dynTierSwapToEndAndDelete index low, high#)
    DynTierHigh -> DynArray (#low, dynTierSwapToEndAndDelete index high#)
  |> dynArrayTrace "DELETE: "

-- TODO: Nested case literals seem broken!
-- dynArrayDelete :: DynArrayIndex -> DynArray *a -> DynArray *a
-- dynArrayDelete index (DynArray (#low, high#)) =
--   case index of
--     DynArrayIndex (#DynTierLow,  index'#) -> DynArray (#dynTierSwapToEndAndDelete index' low, high#)
--     DynArrayIndex (#DynTierHigh, index'#) -> DynArray (#low, dynTierSwapToEndAndDelete index' high#)

    -- DynArray (#low, dynTierAppend (appendMk ()) <| DynTier (#highCapacity, highCount, highWaterMark, highPtr#)#)

dynArrayEmplaceOrAppend :: (*a -> *a) -> (() -> *a) -> DynArray *a -> DynArray *a
dynArrayEmplaceOrAppend emplaceInit appendMk (DynArray (#low, DynTier (#highCapacity, highCount, highWaterMark, highPtr#)#)) =
  if highCount < highWaterMark then
    dynArrayTrace "EMPLACE: " <| DynArray (#low, dynTierModifyElement highCount emplaceInit <| DynTier (#highCapacity, highCount + 1, highWaterMark, highPtr#)#)
  else
    dynArrayTrace "APPEND:  " <| dynArrayAppend (appendMk ()) (DynArray (#low, DynTier (#highCapacity, highCount, highWaterMark, highPtr#)#))

data DynArrayIterator a = DynArrayIterator (#DynArrayIndex, DynArray a#)

dynArrayIterator :: DynArray *a -> DynArrayIterator *a
dynArrayIterator a = DynArrayIterator (#dynArrayIndexEmpty, a#)

dynArrayIteratorEnd :: DynArrayIterator *a -> DynArray *a
dynArrayIteratorEnd (DynArrayIterator (#_, array#)) = array

dynArrayIteratorEmplaceOrAppend :: (*a -> *a) -> (() -> *a) -> DynArrayIterator *a -> DynArrayIterator *a
dynArrayIteratorEmplaceOrAppend emplaceInit appendMk (DynArrayIterator (#_, array#)) =
  DynArrayIterator (#dynArrayIndexEmpty, dynArrayEmplaceOrAppend emplaceInit appendMk array#)

dynArrayIteratorWithElement :: (*a -> (#b, *a#)) -> DynArrayIterator *a -> (#DynArrayResult b, DynArrayIterator *a#)
dynArrayIteratorWithElement f (DynArrayIterator (#index, array#)) =
  case dynArrayWithElement index f array of
    (#result, array'#) ->
      (#result, DynArrayIterator (#index, array'#)#)

dynArrayIteratorNext :: DynArrayIterator *a -> DynArrayIterator *a
dynArrayIteratorNext (DynArrayIterator (#DynArrayIndex (#tier, index#), DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)) =
  case tier of
    DynTierLow ->
      if index < lcount then
        DynArrayIterator (#DynArrayIndex (#DynTierLow, index + 1#), DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)
      else
        DynArrayIterator (#DynArrayIndex (#DynTierHigh, 0#), DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)
    DynTierHigh ->
      DynArrayIterator (#DynArrayIndex (#DynTierHigh, index + 1#), DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)

dynArrayIteratorFree :: DynArrayIterator *a -> DynArrayIterator *a
dynArrayIteratorFree (DynArrayIterator (#index, array#)) =
  case dynArrayDelete index array of
    DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#) ->
      case index of
        DynArrayIndex (#tier, _#) ->
          case tier of
            DynTierLow ->
              if lcount > 0 then
                DynArrayIterator (#index, DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)
              else
                DynArrayIterator (#DynArrayIndex (#DynTierHigh, 0#), DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)
            DynTierHigh ->
              DynArrayIterator (#index, DynArray (#DynTier (#lcap, lcount, lhwm, lptr#), DynTier (#hcap, hcount, hhwm, hptr#)#)#)


--------------------
-- PolyThunks
--------------------
-- NOTE on Propagation:
--    * All Type variables are propagating
--    * In data constructors type variables are always polymorphic in uniqueness
--    * In data constructors monomorphic types are always shared in uniqueness (TODO: Allow users to put anon dots on Monomorphic types so that they share uniqueness with the declared type!)
--    * No uniqueness notation is allowed in data constructors (except for in the future anon dots on type apps and monomorphic types!)
--    * Higher Kinded Types do not have uniqueness types and do not propagate uniqueness, instead Type Applications have uniqueness types associated with them and are propagating!
--    * Propagation behavior is enforced by the type of the data constructor function!
data PolyThunkState = PolyThunkAlloc | PolyThunkInit | PolyThunkEval
data PolyThunk a    = PolyThunk (#Ptr .(), Ptr .(), a, PolyThunkState, Float#)
-- UpdateState, CopyState, Arg, ThunkState, SampleOffset

dynDeepCopy :: a -> (#Ptr *(), a#)
dynDeepCopy x =
  primUndefined

dynDeepCopyInto :: Ptr *() -> a -> (#Ptr *(), a#)
dynDeepCopyInto copyState x =
  primUndefined

polyThunkAlloc :: a -> Float -> () -> *PolyThunk a
polyThunkAlloc x sampleOffset u =
  case dynDeepCopy x of
    (#copyState, x'#) ->
      PolyThunk (#primUndefined, copyState, x', PolyThunkAlloc, sampleOffset#)

polyThunkInit :: a -> Float -> *PolyThunk a -> *PolyThunk a
polyThunkInit x sampleOffset (PolyThunk (#updateState, copyState, _, _, _#))  =
  case dynDeepCopyInto copyState x of
    (#copyState', x'#) ->
      PolyThunk (#updateState, copyState', x', PolyThunkInit, sampleOffset#)

polyThunkEvalGo :: (a -> b) -> a -> b
polyThunkEvalGo f x =
  case f x of
    result ->
      result

polyThunkEval :: (a -> b) -> *PolyThunk a -> (#b, *PolyThunk a#)
polyThunkEval f t =
  let
    dummy = polyThunkEvalGo f primUndefined
  in
    primUndefined

----------------------
-- Poly
----------------------
class Finite a where
  isRunning :: a -> Bool

class (Monoid p, Finite p) => Poly p where

instance Finite Channel where
  isRunning c =
    case c of
      ChannelEnd -> False
      _          -> True

instance AudioFormat f => Finite (Audio f) where
  isRunning (Audio cs) = foldl (\b x -> b && isRunning x) True cs

instance Poly Channel where
instance Poly (Audio f) where

calculateAudioSampleOffset :: Rational -> Rational -> Float
calculateAudioSampleOffset valueTime tickTime =
  (fromInt n / fromInt d) * audioBlockSizeF
  where
    Rational (#n, d#) =
      (valueTime - (tickTime - audioBlockDelta)) / audioBlockDelta

seqToAudio :: (AudioFormat f) => Seq Float -> Audio f
seqToAudio s =
  Audio (pure (AudioRate (freezeArray aout)))
  where
    (#_, aout#) =
      loop (#i0, a#) = (#audioSampleOffset, audioInitArray ()#) while i0 < audioBlockSize do
        let
          i1        = i0 + 1
          time ~ 0  = time + audioSampleDelta
          value ~ 0 =
            thd3' <| loop (#cont, seqDuration0, prevValue#) = (#True, 0, value#) while cont do
              let
                nextValueTime ~ 0 = nextValueTime + seqDuration0
              in
                if nextValueTime >= time then (#False, 0, prevValue#) else
                  case runSeq s () of
                    SeqValue (#seqDuration1, _, Just seqValue#) -> (#True, seqDuration1, seqValue#)
                    SeqValue (#seqDuration1, _, _#)             -> (#True, seqDuration1, prevValue#)
        in
          (#i1, writeArray (unsafeUIntToIndex i0) (fromFloat value) a#)

poly :: Poly b => (a -> b) -> Seq a -> b
poly f s =
  case mutRefTake (\_ -> dynArrayEmpty 8) of
    (#thunks0, mref#) ->
      let
        tick ~ 0                = tick + audioBlockDelta
        (#_, _, acc', thunks4#) =
          loop (#cont, time, acc, thunks1#) = (#True, 0, mempty, dynArrayIterator thunks0#) while cont do
            let nextValueTime ~ 0 = nextValueTime + time in
              if nextValueTime < tick then
                case runSeq s () of
                  SeqValue (#t, _, Just x#) ->
                    (#True, t, acc, dynArrayIteratorEmplaceOrAppend (polyThunkInit x (calculateAudioSampleOffset nextValueTime tick)) (polyThunkAlloc x (calculateAudioSampleOffset nextValueTime tick)) thunks1#)
                  SeqValue (#t, _, _#) ->
                    (#True, t, acc, thunks1#)
              else
                case dynArrayIteratorWithElement (polyThunkEval f) thunks1 of
                  (#maybeEvalResult, thunks2#) ->
                    case maybeEvalResult of
                      DynArrayJust evalResult ->
                        if isRunning evalResult then
                          (#True, 0, append acc evalResult, dynArrayIteratorNext thunks2#)
                        else
                          (#True, 0, acc, dynArrayIteratorFree thunks2#)
                      DynArrayNothing -> (#True, 0, acc, dynArrayIteratorNext thunks2#)
                      DynArrayEnd     -> (#False, 0, acc, thunks2#)
      in
        case mutRefPut (dynArrayIteratorEnd thunks4) mref of
          _ -> acc'

poly2 :: Poly c => (a -> b -> c) -> Seq a -> Seq b -> c
poly2 f x y = poly (uncurry' f) (map2 (\x' y' -> (#x', y'#)) x y)

-- TODO: Need map3
poly3 :: Poly d => (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> d
poly3 f x y z = poly (uncurry3' f) (map3 (\x' y' z' -> (#x', y', z'#)) x y z)

-- TODO: Simultaneous synths panned in the middle cause weird FM?!?!!?!?
-- TODO: Test arg copying
-- TODO: Test multiple polys
-- TODO: Test shared beats, etc (NOTE: Known to assert false currently)

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio   = poly badSynth badBeat
--     badBeat    = [400 600 [800:500] <900 <600 [700:1200]> <300 200>>]
--     badSynth f =
--       saw (fromFloat f)
--       |> mul 0.0125
--       |> perc 0.0125 3 1
--       |> pan 0.5

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio   = poly badSynth badBeat
--     badBeat    = [_ 600] |> seqSpeed (1 // 10)
--     badSynth f =
--       saw (fromFloat f)

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (saw 220 * 0.05 |> perc 2 10 1) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (pulse 0.5 220 * 0.05 |> perc 2 10 1) w

-- -- TODO: Deep copy arrays, but don't deep copy unique arrays
-- -- TODO: id in poly causing compile assert... probably due to inlining???
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badBeat    = [100 1200 1400 1800] |> seqSpeed (1 // 2) |> map saw
--     badSynth a = a * 0.1 |> perc 1 3 1 |> pan 0.5
--     badAudio   = poly badSynth badBeat

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badBeat1     = seqSpeed (6 // 1) [100 600 800 900]
--     badBeat2     = seqSpeed (3 // 1) [0.2 0.8 0.4 0.6]
--     badSynth f p = saw (f * fromInt (mouseX / 32 + 1)) * 0.05 |> perc 0.0125 1 1 |> pan p
--     badAudio     = poly2 badSynth badBeat1 badBeat2

-- -- TODO: Look at arg copying scheme....seems off (related to array copying?0
-- -- TODO: map3, etc
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badBeat1       = seqSpeed (6 // 1) [100 600 800 900]
--     badBeat2       = seqSpeed (3 // 1) [900 800 600 100 1200 100 600 800 900 1200]
--     badBeat3       = seqSpeed (3 // 1) [0.2 0.8 0.4 0.6]
--     badSynth f g p = (saw (fromFloat f) + saw (fromFloat g)) * 0.05 |> perc 0.0125 1 1 |> pan (fromFloat p)
--     badAudio       = poly3 badSynth badBeat1 badBeat2 badBeat3

testJit :: *World -> *World
testJit w =
  outAudio 0 badAudio w
  where
    freqMul1  = saw 0.1   * 0.01 + 0.5
    freqMul2  = saw 0.07  * -0.01 + 0.5
    freqMul3  = saw 0.114 * 0.01 + 0.5
    beatSpeed = 3 // 2
    badBeat1  = seqSpeed beatSpeed [400 _ 600 <_ 700> 800]
    badBeat2  = seqSpeed beatSpeed ([400 _ 600 <_ 700> <_ 1200> 1350] @* (seqSpeed (1 // 9) [0.5 1 2 3 0.25]))
    badBeat3  = seqSpeed (beatSpeed / 8) [100 60 75 100 60 75 80]
    bassSynth fm a p f =
      saw (fromFloat f) + saw (fromFloat f * fm)
      |> mul (0.0125 * fromFloat a)
      |> perc 0.0125 4.5 1
      |> pan p
    badSynth fm a p f =
      pulse fm (fromFloat f) + saw (fromFloat f * fm)
      |> mul (0.0125 * fromFloat a)
      |> perc 0.0125 6 1
      |> pan p
    badAudio =
      poly (badSynth  freqMul1 0.5 0.25) badBeat1 +
      poly (badSynth  freqMul2 0.5 0.75) badBeat2 +
      poly (bassSynth freqMul3 2.3 0.5)  badBeat3

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
-- 		  |> printLn (bitNot one |> bitAnd (fromBits negativeBit |> bitNot))
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> bitAnd (bitNot negativeBit |> fromBits)
--     -- unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print negativeBit
--           |> print " -> "
--           |> print negativeOne
--           |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits
--

-- bitOneOne = bitAnd (bitXor (-1) negativeBit) bitOne |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w |> print " -> " |> print bitOne |> print " -> " |> print bitOneOne |> printLn " "
--   where
--     one :: Float
--     one = 1
--     -- negativeBit :: UInt
--     -- negativeBit = bitShiftRight 1 63
--     bitOne = bitShiftLeft one 2
--     bitOneOne = bitShiftRight bitOne 2
--
-- testJit :: *World -> *World
-- testJit w = print f64 w |> print " -> " |> print rF64 |> print " -> " |> print rrF64 |> printLn " "
--   where
--     f64 :: Float
--     f64 = pi
--     rF64 = bitReverse f64
--     rrF64 = bitReverse rF64
--

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     s = seqToAudio <| seqSpeed 4 [(fromInt mouseX / 64.0) 1 2 <4 3>]
--     t = seqToAudio <| seqSpeed 2 [0.5 1 2 <4 3>]
--     a =
--       saw (440 * stereo s t)
--       |> mul 0.25
--       |> pan 0.5

-- testJit :: *World -> *World
-- testJit w = printLn f64 w |> printLn (bitReverse f64) |> printLn (bitReverse <| bitReverse f64)
--   where
--     f64 :: F64
--     f64 = 5

-- testJit :: *World -> *World
-- testJit w = printLn mouseX w |> printLn (atanF64 fMouse)
--   where
--     fMouse :: F64
--     fMouse = fromInt mouseX
--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex (#8, 2#)
--     b = Complex (#2, 1#)
--     c = sqrt (Complex (#negate 3.4, pi#))
--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex (#(negate pi), 3#)
--     b = Complex (#3, 4#)
--     c = a / b


-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- tupleTestGo :: SeqValue Float
-- tupleTestGo = runSeq tupleTest ()

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- interleaveTestGo :: SeqValue Float
-- interleaveTestGo = runSeq interleaveTest ()

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- seqTest1Go :: SeqValue Float
-- seqTest1Go = runSeq seqTest1 ()

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 _ 4>]

-- seqTest2Go :: SeqValue Float
-- seqTest2Go = runSeq seqTest2 ()

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]

-- proceduralBeat :: Seq Float
-- proceduralBeat = Seq <| \_ ->
--   let
--     tick ~ 0 = tick + 1
--     value    = tick * 100 + fromInt mouseY * fromInt mouseX
--   in
--     SeqValue (#2, SeqNormal, Just value#)

-- -- Simplification is getting out of hand, current setup is n^2 which is....bad.
-- seqTest :: Seq Float
-- seqTest =
--   [x 100 200 <300 x> [400:500]]
--   where
--     x = <30 40 <50 60 70> 80> + 3

-- coolBeat :: Seq Float
-- coolBeat =
--   [
--     x y (y+y) z
--     _ x <5 z> x
--     _ 0 <1 2> y
--   ] * 2
--   where
--     x = <0 5 <1 2> 1>
--     y = 3
--     z = fromInt mouseX * 100

-- properFraction :: (Fractional a, Integral b) -> a -> (b, b)

-- TODO / One Day... We need ~ constraints for this to work...
-- class Freeze a where
--   freeze :: (Freeze b, a ~ b) => *a -> b

-- TODO: Set audioSampleOffset to NOT be constant and insure that it is never used at a global scope!!!!! (It is magical...)
-- TODO: repeat combinator
-- TODO: accumulate2, etc
-- TODO: FFT stuff
-- TODO: Nested case literals seem broken!
-- TODO: Out of order monomorphic instances (i.e. 'instance Ring Complex' textually appearing before 'instance Ring F64') can cause erroneous 'Not An Instance' errors. Maybe need a better dep analysis story to make this work since we don't figure this out until inference which is at that point too late to fix.
-- TODO: Write to log file, perhaps class Log a similar to class Print a
-- TODO: Look at all the .i.i.i weirdness in llvm names???

-- TODO: Optimize const expr globals
-- TODO: Memory access test audio stuff!
-- TODO: type sig coerce constraint!
-- TODO: Put constant check on initializers, not in type signatures. It doesn't need to be in the type system to be checked! Then we can nix Default for Monoid?
-- TODO: FFT generated signals, pure FFT
-- TODO: Compiler breaks down when a Non-Type kinded type is used in a class declaration!
-- TODO: endAfterTick IO combinator: endAfterTick :: *World -> *World
-- TODO: Immutable and Mutable (Unique) FFT API
-- TODO: Writing audio files

-- TODO: Concept of Constant Values somehow being worked into the type system for things like default and mutRef
-- TODO: Inline compose operators! .> and <.
-- TODO: Perhaps function caching is getting off, need more accurate check for HOF caching!
-- TODO: Replace Default with Monoid?
-- TODO: Need partial recursive values to get rid of monoid here
-- TODO: Partially recursive values
-- TODO: Use List type syntax for Sequences?
-- TODO: Partially recursive values
-- TODO: Defunctionalization of function on data structures
-- TODO: Stateful Pattern assignment

-- Sound ideas
--     * Percussive simulations
--     * Strange attractors in FFT?
--     * Cool FFT effects we used: Convolution with voices, Long time stretching

