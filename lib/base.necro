--------------------
-- Necro.Base
--------------------

id :: .a -> .a
id x = x

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

fst :: .(a, b) -> .a
fst t =
  case t of
    (x, _) -> x

snd :: .(a, b) -> .b
snd t =
  case t of
    (_, y) -> y

fst' :: .(#a, b#) -> .a
fst' t =
  case t of
    (#x, _#) -> x

snd' :: .(#a, b#) -> .b
snd' t =
  case t of
    (#_, y#) -> y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  case lt x y of
    True -> x
    _    -> y

-- TODO: map3, etc
class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

-- class Default a where
--   default :: !a

-- instance (Default a, Default b) => Default (a, b) where
--   default = (default, default)

arrayFrom :: a -> Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share x) a

--------------------
-- Prim Instances
--------------------

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Semigroup F64 where
  append x y = x + y

instance Monoid F64 where
  mempty = 0

-- instance Default a => Default (Array n a) where
--   default = arrayFrom default

-- -- This is getting tripped up in lambda_lift
-- defaulted :: Array 4 (Maybe Int)
-- defaulted = default

-- coolInit :: Array 4 Int
-- coolInit ~ (freezeArray (unsafeEmptyArray ())) = coolInit

-- coolInit2 :: (#Maybe Int, Float#)
-- coolInit2 = x
--   where
--     x ~ (#Just 0, default#) = x

-- class Num a => Integral a where
--   quot :: a -> a -> Maybe a
--   rem :: a -> a -> Maybe a
--   div :: a -> a -> Maybe a
--   mod :: a -> a -> Maybe a

-- instance Integral Int where
--   quot x y = if y == 0 then Nothing else primUndefined
--   rem  x y = if y == 0 then Nothing else primUndefined
--   div  x y = if y == 0 then Nothing else primUndefined
--   mod  x y = if y == 0 then Nothing else primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
data Rational = Rational (#Int, Int#)

gcd :: Int -> Int -> Int
gcd x y = d
  where
    (#d, _#) =
      loop (#a, b#) = (#abs x, abs y#) while b > 0 do
        (#b, remInt a b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational (#quotInt x d, quotInt y d#)
  where
    d = gcd x y

-- TODO: abs and signum are currently broken
rational :: Int -> Int -> Rational
rational x y = reduce x y
-- rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator r =
  case r of
    Rational (#n, _#) -> n

denominator :: Rational -> Int
denominator r =
  case r of
    Rational (#_, d#) -> d

instance Eq Rational where
  eq x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            eq (xn * yd) (yn * xd)
  neq x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            lt (xn * yd) (yn * xd)
  lte x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            lte (xn * yd) (yn * xd)
  gt x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            gt (xn * yd) (yn * xd)
  gte x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            gte (xn * yd) (yn * xd)

-- TODO: Rational math looks off...
instance Num Rational where
  add x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            reduce (xn * yd + yn * xd) (xd * yd)
  sub x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            reduce (xn * yd - yn * xd) (xd * yd)
  mul x y =
    case x of
      Rational (#xn, xd#) ->
        case y of
          Rational (#yn, yd#) ->
            reduce (xn * yn) (xd * yd)
  abs x =
    case x of
      Rational (#xn, xd#) ->
        Rational (#abs xn, xd#)
  signum x =
    case x of
      Rational (#xn, _#) ->
        Rational (#signum xn, 1#)
  fromInt x =
    Rational (#fromInt x, 1#)

-- -- TODO: Switch fromRational to use Rational type!
-- instance Fractional Rational where
--   div x y =
--     case x of
--       Rational (#xn, xd#) ->
--         case y of
--           Rational (#yn, yd#) ->
--             rational (xn * yd) (xd * yn)
--   recip x =
--     case x of
--       Rational (#n, d#) -> if n == 0 then Rational (#0, 1#) else
--         if n < 0
--           then rational d n
--           else rational d n
--   fromRational r = rational 1 1

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

-- ltTest :: Float -> Float
-- ltTest x =
--   if x < 33 + 1 then
--     66
--   else
--     0

-- rationalTest :: Rational
-- rationalTest = 33 * 44 + 23 - (1 % 4)

-- threeHalves :: Rational
-- threeHalves = 3 % 2


--------------------
-- Array
--------------------
  -- TODO: This is failing in lambda lift for some reason
-- instance Print a => Print (Array n a) where
--   print a w =
--     loop w' = w for i <- each do
--       print (readArray i a) w'

-- nums :: Array 3 Int
-- nums = {0, 1, 2}

-- stringTest :: *World -> *World
-- stringTest w = print nums w


--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Default (Maybe a) where
  default = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

maybe :: b -> (a -> b) -> Maybe a -> b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x


--------------------
-- Seq
--------------------

-- data SeqNil     = SeqEnd | SeqBlockEnd | SeqLoopEnd | SeqRest
-- data SeqValue a = SeqValue Float a | SeqNil Float SeqNil

data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
data SeqValue a = SeqValue (#Float, SeqControl, Maybe a#)
data Seq a      = Seq (() -> SeqValue a)

instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    case lt (fromEnum x) (fromEnum y) of
      True -> x
      _    -> y

instance Monoid SeqControl where
  mempty = SeqLoopEnd

-- instance Semigroup (SeqValue a) where
--   append xs ys =
--     case xs of
--       SeqValue t x ->

instance Default (SeqValue a) where
  default = SeqValue (#1, SeqPure, nothing#)

instance Functor SeqValue where
  map f s =
    case s of
      SeqValue (#t, c, x#) -> SeqValue (#t, c, map f x#)

instance FunctorN SeqValue where
  map2 f xs ys =
    case xs of
      SeqValue (#xt, xc, xv#) ->
        case ys of
          SeqValue (#yt, yc, yv#) ->
            SeqValue (#min xt yt, xc <> yc, map2 f xv yv#)

instance Applicative SeqValue where
  pure x   = SeqValue (#1, SeqPure, Just x#)
  ap fs xs =
    case fs of
      SeqValue (#ft, fc, fv#) ->
        case xs of
          SeqValue (#xt, xc, xv#) ->
            SeqValue (#min xt ft, fc <> xc, ap fv xv#)

instance Num a => Num (SeqValue a) where
  fromInt i = SeqValue (#1, SeqPure, Just (fromInt i)#)
  add x y   = map2 add x y
  sub x y   = map2 sub x y
  mul x y   = map2 mul x y
  signum x  = map signum x
  abs x     = map abs x

instance Fractional a => Fractional (SeqValue a) where
  fromRational r = SeqValue (#1, SeqPure, Just (fromRational r)#)
  div x y        = map2 div x y
  recip x        = map recip x

runSeq :: Seq a -> () -> SeqValue a
runSeq s _ =
  case s of
    Seq stepFunc ->
      stepFunc ()

instance Functor Seq where
  map f s = Seq (\_ -> map f (runSeq s ()))

instance Applicative Seq where
  pure x   = Seq (\_ -> SeqValue (#1, SeqNormal, Just x#))
  ap fs xs = Seq (\_ -> ap (runSeq fs ()) (runSeq xs ()))

instance FunctorN Seq where
  map2 f sx sy = Seq (\_ -> map2 f (runSeq sx ()) (runSeq sy ()))

instance Num a => Num (Seq a) where
  fromInt i = Seq (\_ -> SeqValue (#1, SeqNormal, Just (fromInt i)#))
  add x y   = Seq (\_ -> map2 add (runSeq x ()) (runSeq y ()))
  sub x y   = Seq (\_ -> map2 sub (runSeq x ()) (runSeq y ()))
  mul x y   = Seq (\_ -> map2 mul (runSeq x ()) (runSeq y ()))
  signum x  = Seq (\_ -> map signum (runSeq x ()))
  abs x     = Seq (\_ -> map abs (runSeq x ()))

instance Fractional a => Fractional (Seq a) where
  fromRational r = Seq (\_ -> SeqValue (#1, SeqNormal, Just (fromRational r)#))
  div x y        = Seq (\_ -> map2 div (runSeq x ()) (runSeq y ()))
  recip x        = Seq (\_ -> map recip (runSeq x ()))

rest :: Seq a
rest = Seq (\_ -> SeqValue (#1, SeqPure, nothing#))


--------------------
-- Print
--------------------
class Print a where
  print :: a -> *World -> *World

instance Print Int where
  print x w = printInt x w

instance Print I64 where
  print x w = printI64 x w

instance Print F64 where
  print x w = printF64 x w

instance Print Char where
  print x w = printChar x w

instance Print Rational where
  print r w =
    case r of
      Rational (#n, d#) ->
        print '(' w |> print n |> print ' ' |> print '%' |> print ' ' |> print d |> print ')'

-- -- TODO: Tick delta
-- -- TODO: Seq literals

-- TODO: Print Array
-- TODO: Print Seq

printLn :: Print a => a -> *World -> *World
printLn x w = print '\n' (print x w)


--------------------
-- Channel
--------------------
data Channel = BlockRate F64 | AudioRate (Array BlockSize F64)

outChannel :: UInt -> Channel -> *World -> *World
outChannel n c w =
  case c of
    BlockRate _ -> w
    AudioRate b -> outAudioBlock n b w

mapChannel :: (F64 -> F64) -> Channel -> Channel
mapChannel f c =
  case c of
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share (f (readArray i b))) a

-- TODO: Look into alias analysis here!
-- We should be able to float the call to unsafeEmptyArray out of the for loop
mapChannel2 :: (F64 -> F64 -> F64) -> Channel -> Channel -> Channel
mapChannel2 f cx cy =
  case cx of
    BlockRate x ->
      case cy of
        BlockRate y ->
          BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f x (readArray i y))) a
    AudioRate x ->
      case cy of
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f (readArray i x) y)) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (Share (f (readArray i x) (readArray i y))) a

-- TODO: Stateful unboxed tuple types!
accumulateChannel1 :: Default s => (F64 -> s -> (#s, F64#)) -> Channel -> Channel
accumulateChannel1 f input1 =
  case output of
    (_, o) -> AudioRate o
  where
    output ~ (default, freezeArray (unsafeEmptyArray ())) =
      case output of
        (state, _) ->
          let (#Share state', o'#) =
                case input1 of
                  BlockRate input1Val ->
                    loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
                      case f input1Val s of
                        (#s', x#) ->
                          (#Share s', writeArray i (Share x) o#)
                  AudioRate input1Buffer ->
                    loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
                      case f (readArray i input1Buffer) s of
                        (#s', x#) ->
                          (#Share s', writeArray i (Share x) o#)
          in (state', freezeArray o')

-- -- Ugly, but and inefficient, it works
-- accumulateChannel2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> Channel -> Channel -> Channel
-- accumulateChannel2 f input1 input2 =
--   case output of
--     (_, o) -> AudioRate o
--   where
--     output ~ (default, freezeArray (unsafeEmptyArray ())) =
--       case output of
--         (state, _) ->
--           let output' =
--                 case input1 of
--                   BlockRate input1Val ->
--                     case input2 of
--                       BlockRate input2Val ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f input1Val input2Val s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--                       AudioRate input2Buffer ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f input1Val (readArray i input2Buffer) s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--                   AudioRate input1Buffer ->
--                     case input2 of
--                       BlockRate input2Val ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f (readArray i input1Buffer) input2Val s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--                       AudioRate input2Buffer ->
--                         loop (#Share s, o#) = (#Share state, unsafeEmptyArray ()#) for i <- each do
--                           case f (readArray i input1Buffer) (readArray i input2Buffer) s of
--                             (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--           in case output' of
--                (#Share state', o'#) -> (state', freezeArray o')

-- -- The goal, but not all features currently supported
-- accumulateChannel2 :: Default s => (F64 -> F64 -> s -> (#s, F64#)) -> Channel -> Channel -> Channel
-- accumulateChannel2 f input1 input2 =
--   AudioRate (freezeArray output)
--   where
--     emptyO                      = unsafeEmptyArray ()
--     (#state ~ default, output#) =
--       case (#input1, input2#) of
--         (#BlockRate input1Val, BlockRate input2Value#) ->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f input1Val input2Val s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#BlockRate input1Val, AudioRate input2Buffer#) ->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f input1Val (readArray i input2Buffer) s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#AudioRate input1Buffer, BlockRate input2Val#)->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f (readArray i input1Buffer) input2Val s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)
--         (#AudioRate input1Buffer, AudioRate input2Buffer#)->
--           loop (#Share s, o#) = (#state, emptyO#) for i <- each do
--             case f (readArray i input1Buffer) (readArray i input2Buffer) s of
--               (#s', x#) -> (#Share s', writeArray i (Share x) o#)

instance Num Channel where
  fromInt i = BlockRate (fromInt i)
  add l r   = mapChannel2 add l r
  sub l r   = mapChannel2 sub l r
  mul l r   = mapChannel2 mul l r
  signum c  = mapChannel signum c
  abs c     = mapChannel abs c


--------------------
-- Audio
--------------------
data Mono      = Mono Channel
data Stereo    = Stereo (#Channel, Channel#)
data Quad      = Quad Channel Channel Channel Channel
data Ambisonic = Ambisonic Channel Channel Channel Channel

-- TODO: Equal power panning
class Audio a where
  pureAudio        :: Channel -> a
  mapAudio         :: (Channel -> Channel) -> a -> a
  mapAudio2        :: (Channel -> Channel -> Channel) -> a -> a -> a
  accumulateAudio1 :: Default s => (F64 -> s -> (#s, F64#)) -> a -> a
  pan              :: Mono -> a -> Stereo
  outAudio         :: UInt -> a -> *World -> *World

instance Audio Mono where
  pureAudio c    = Mono c
  outAudio n m w =
    case m of
      Mono c -> outChannel n c w
  mapAudio f m =
    case m of
      Mono c -> Mono (f c)
  mapAudio2 f mx my =
    case mx of
      Mono cx ->
        case my of
          Mono cy -> Mono (f cx cy)
  accumulateAudio1 f m =
    case m of
      Mono c -> Mono (accumulateChannel1 f c)
  pan amount input =
    case input of
      Mono inputChannel ->
        case amount of
          Mono amountChannel ->
            Stereo (#mul inputChannel (sub 1 amountChannel), mul inputChannel amountChannel#)

instance Audio Stereo where
  pureAudio c    = Stereo (#c, c#)
  outAudio n s w =
    case s of
      Stereo (#l, r#) ->
        outChannel (add n 1) r (outChannel n l w)
  mapAudio f s =
    case s of
      Stereo (#l, r#) ->
        Stereo (#f l, f r#)
  mapAudio2 f sx sy =
    case sx of
      Stereo (#lx, rx#) ->
        case sy of
          Stereo (#ly, ry#) -> Stereo (#f lx ly, f rx ry#)
  accumulateAudio1 f s =
    case s of
      Stereo (#l, r#) ->
        Stereo (#accumulateChannel1 f l, accumulateChannel1 f r#)
  pan amount input =
    case input of
      Stereo (#inputChannelL, inputChannelR#) ->
        case amount of
          Mono amountChannel ->
            Stereo (#mul inputChannelL (sub 1 amountChannel), mul inputChannelR amountChannel#)

-- accumulateAudio1 :: (Default s, Audio a) => (F64 -> s -> (#s, F64#)) -> a -> a
-- accumulateAudio1 f a = mapAudio (accumulateChannel1 f) a

instance Num Mono where
  fromInt i = Mono (fromInt i)
  add l r   = mapAudio2 add l r
  sub l r   = mapAudio2 sub l r
  mul l r   = mapAudio2 mul l r
  signum c  = mapAudio signum c
  abs c     = mapAudio abs c

instance Num Stereo where
  fromInt i = let c = fromInt i in Stereo (#c, c#)
  add l r   = mapAudio2 add l r
  sub l r   = mapAudio2 sub l r
  mul l r   = mapAudio2 mul l r
  signum c  = mapAudio signum c
  abs c     = mapAudio abs c

instance Fractional Channel where
  fromRational r = BlockRate (fromRational r)
  div l r        = mapChannel2 div l r
  recip c        = mapChannel recip c

instance Fractional Mono where
  fromRational r = Mono (fromRational r)
  div l r        = mapAudio2 div l r
  recip c        = mapAudio recip c

instance Fractional Stereo where
  fromRational r = let c = fromRational r in Stereo (#c, c#)
  div l r        = mapAudio2 div l r
  recip c        = mapAudio recip c

instance Semigroup Mono where
  append x y = x + y

instance Monoid Mono where
  mempty = 0

instance Semigroup Stereo where
  append x y = x + y

instance Monoid Stereo where
  mempty = 0

stereo :: Mono -> Mono -> Stereo
stereo ml mr =
  case ml of
    Mono l ->
      case mr of
        Mono r -> Stereo (#l, r#)

accumulateSaw :: F64 -> F64 -> (#F64, F64#)
accumulateSaw freq acc =
  (#acc3, out#)
  where
    acc2 = fma freq recipSampleRate acc
    acc3 = acc2 - fastFloor acc2
    out  = fma acc3 2.0 (-1.0)

saw :: (Audio a) => a -> a
saw freq = accumulateAudio1 accumulateSaw freq

-- statefulWhile :: Mono
-- statefulWhile = snd <|
--   loop (i, x) = (0, 0) while i < 20 do
--     (i + 1, x + saw 440)

-- class Foldable f where
--   fold  :: Monoid m => f m -> m
--   foldl :: (b -> a -> b) -> b -> f a -> b
--   foldp :: (b -> a -> b) -> f a -> b

-- TODO: Desugar seq literals
-- TODO: Replace Default with Monoid?
-- TODO: Handle Constant, End, etc
-- TODO: Need partial recursive values to get rid of monoid here

-- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', init#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)

-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- instance Default World where
--   default = World

-- seqControlIsNormal :: SeqControl -> Bool
-- seqControlIsNormal sc =
--   case sc of
--     SeqNormal -> True
--     _         -> False

-- -- TODO: If statements seem to cause issues with loops and nested case statments?!?!!?
-- instance Print a => Print (Seq a) where
--   print seq w = wout
--     where
--       tick ~ 0       = tick + 0.00390625
--       (#_, _, wout#) =
--         loop (#Share cont, Share time, w'#) = (#Share True, Share 0, w#) while cont do
--           let
--             nextValueTime ~ 0 = nextValueTime + time
--           in
--             case nextValueTime < tick of
--               False -> (#Share False, Share 0, w'#)
--               True  ->
--                 case runSeq seq () of
--                   SeqValue (#t, c, Nothing#) -> (#Share (seqControlIsNormal c), Share t, w'#)
--                   SeqValue (#t, c, Just x#)  -> (#Share (seqControlIsNormal c), Share t, print ' ' (print ',' (print x w'))#)

-- TODO: Loop Syntax
-- TODO: Sequence Syntax

-- printSeqTest :: *World -> *World
-- printSeqTest w = print seqOne w

-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  case (slot + 1) < maxSlot of
    True -> SeqNormal
    _    -> SeqLoopEnd

slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue (#t, SeqNormal, v#) -> (#slot, sv#)
    SeqValue (#t, _,         v#) -> (#remInt (slot + 1) maxSlot, SeqValue (#t, controlIfNotNormal, v#)#)

warpSeqValueSpeed :: Float -> SeqValue a -> SeqValue a
warpSeqValueSpeed speed sv =
  case sv of
    SeqValue (#t, c, v#) ->
      (SeqValue (#t * speed, c, v#))

seqTick :: Int -> Int -> Seq a -> (#Int, SeqValue a#)
seqTick slot maxSlot s =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (runSeq s ())

tupleTick :: Int -> Int -> Seq a -> (#Int, SeqValue a#)
tupleTick slot maxSlot s =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (warpSeqValueSpeed (recip (fromInt maxSlot)) (runSeq s ()))

interleaveTick :: Int -> Int -> Seq a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot s =
  slotTick slot maxSlot SeqLoopEnd (runSeq s ())

-- seqTickTest :: SeqValue Int
-- seqTickTest = sv
--   where
--     (#_, sv#)  = seqTick 0 2 55
--     (#_, sv'#) = seqTick 0 2 666

-- -- TODO: Test, mach crash (could be stateful unboxed tuple related, or unboxed tuples in unboxed tuples?)
-- tupleTickTest :: SeqValue Int
-- tupleTickTest = sv1
--   where
--     (#_, sv1#) = tupleTick 0 2 55
--     (#_, sv2#) = tupleTick 0 2 66

-- interleaveTickTest :: SeqValue Int
-- interleaveTickTest = sv1
--   where
--     (#_, sv1#) = interleaveTick 0 2 55
--     (#_, sv2#) = interleaveTick 0 2 66

-- Desugar constants into direct values instead of seq ticks!
-- 0 -> (#1, SeqValue (#1, SeqNormal, Just 333#)#)

-- handMadeHemiola :: Seq Int
-- handMadeHemiola = Seq <| \_ ->
--   let
--     out ~ (#0, default#) =
--       case fst' out of
--         0 -> seqTick 0 4 333
--         1 -> seqTick 1 4 666
--         2 -> seqTick 2 4 555
--         _ -> seqTick 3 4 111
--   in
--     snd' out
--
-- handMadeHemiola2 :: Seq Int
-- handMadeHemiola2 = Seq <| \_ ->
--   let
--     out ~ (#0, default#) =
--       case fst' out of
--         0 -> seqTick 0 2 100
--         _ -> seqTick 1 2 handMadeHemiola
--   in
--     snd' out
--
-- handMadeGo :: SeqValue Int
-- handMadeGo = runSeq handMadeHemiola2 ()

-- tupleTickResult :: Float -> Int -> Int -> Float -> SeqValue a -> (#Int, SeqValue a#)
-- tupleTickResult slotTime slot maxSlot sv =
--   case slotTime >= 1 of
--     False ->
--       let slotTime' = slotTime - 1 in
--       case slotTime' >= 1 of
--         True  ->
--           (#slotTime', (#remInt (slot + 1) maxSlot, SeqValue (#tupleDur, seqLoopEndIfLastSlot slot maxSlot, Nothing#)#)#)
--         False ->
--           (#slotTime', (#slot, SeqValue (#slotTime', SeqNormal, Nothing#)#)#)
--     True  ->
--       case sv of
--         SeqValue (#t, c, v#) ->
--           let slotTime' = slotTime + t in
--           case slotTime' >= 1 of
--             True  ->
--               (#slotTime', (#remInt (slot + 1) maxSlot, SeqValue (#(1 - slotTime) * tupleDur, seqLoopEndIfLastSlot slot maxSlot, v#)#)#)
--             False ->
--               (#slotTime', (#slot, SeqValue (#t * tupleDur, SeqNormal, v#)#)#)
--   where
--     tupleDur =
--       recip (fromInt maxSlot) in

-- tupleTick :: Int -> Int -> Seq a -> (#Int, SeqValue a#)
-- tupleTick slot maxSlot s =
--   case acc of
--     (#_, out#) ->
--       out
--   where
--     acc ~ (#0, (#0, default#)#) =
--       case acc of
--         (#slotTime, _#) ->
--           tupleTickResult slotTime slot maxSlot <|
--             case slotTime >= 1
--               True  -> default
--               False -> runSeq s ()

            --   let slotTime' = slotTime - 1 in
            --   case slotTime' >= 1 of
            --     True  ->
            --       (#slotTime', (#remInt (slot + 1) maxSlot, SeqValue (#tupleDur, seqLoopEndIfLastSlot slot maxSlot, Nothing#)#)#)
            --     False ->
            --       (#slotTime', (#slot, SeqValue (#slotTime', SeqNormal, Nothing#)#)#)
            -- True  ->
            --   case runSeq s () of
            --     SeqValue (#t, c, v#) ->
            --       let slotTime' = slotTime + t in
            --       case slotTime' >= 1 of
            --         True  ->
            --           (#slotTime', (#remInt (slot + 1) maxSlot, SeqValue (#(1 - slotTime) * tupleDur, seqLoopEndIfLastSlot slot maxSlot, v#)#)#)
            --         False ->
            --           (#slotTime', (#slot, SeqValue (#t * tupleDur, SeqNormal, v#)#)#)

--     -- slot ~ 7 = remInt (slot + 1) 8
-- -- TODO: How to handle non constants in slots?
-- handMadeHemiola :: Seq Int
-- handMadeHemiola = Seq <| \_ ->
--   let
--     out ~ (#0, 0, default#) =
--       case out of
--         (#slot, slotTime, _#) ->
--           let
--             SeqValue (#t, c, v#) =
--               case slot of
--                 0 -> SeqValue 0.5 100
--                 _ -> SeqValue 0.5 150
--           in

-- -- TODO: How to handle non constants in slots?
-- handMadeHemiola :: Seq Int
-- handMadeHemiola = Seq <| \_ ->
--   let
--     slot ~ 7 = remInt (slot + 1) 8
--     case slot of
--       0 -> SeqValue 0.5 100
--       1 -> SeqValue 0.5 150
--       2 -> SeqValue 1 200
--       3 -> SeqValue 1 300
--       4 -> SeqNil 0.25 SeqRest
--       5 -> SeqValue 0.25 425
--       6 -> SeqValue 0.25 450
--       _ -> SeqValue 0.25 475

-- TODO: Replace SeqConstant!?!?!?
-- interleaveTick :: Int -> Int -> Seq a -> (#Int, SeqValue a#)
-- interleaveTick slot maxSlot s =
--   snd' acc
--   where
--     acc ~ (#0, (#0, default#)#) =
--       let slotTime = fst' acc in
--       case slotTime >= 1 of
--         False ->
--           let slotTime' = slotTime - 1 in
--           case slotTime' >= 1 of
--             True  ->
--               (#slotTime', (#remInt (slot + 1) maxSlot, SeqValue (#1, SeqLoopEnd, Nothing#)#)#)
--             False ->
--               (#slotTime', (#slot, SeqValue (#slotTime', SeqNormal, Nothing#)#)#)
--         True  ->
--           case runSeq s () of
--             SeqValue (#t, c, v#) ->
--               let slotTime' = slotTime + t in
--               case slotTime' >= 1 of
--                 True  ->
--                   (#slotTime', (#remInt (slot + 1) maxSlot, SeqValue (#1 - slotTime, SeqLoopEnd, v#)#)#)
--                 False ->
--                   (#slotTime', (#slot, SeqValue (#t, SeqNormal, v#)#)#)

-- data Seq a = Seq (Rational -> SeqValue (#Rational, SeqControl, Maybe a#))
-- Take in in time return time?

-- maybeLoopEndSeq :: Int -> Int -> SeqControl -> SeqControl
-- maybeLoopendSeq slotNum slotCount control =
--   case control of
--     SeqNormal -> SeqNormal
--     _         ->
--       case (slotNum + 1) >= slotCount of
--         True  -> SeqLoopEnd
--         False -> SeqNormal

-- -- TODO: delta bleed times
-- seqTick :: Int -> Int -> Float -> Seq a -> SeqValue a
-- seqTick slotNum slotCount delta s =
--   case runSeq s delta of
--     SeqValue (#t, c, v#) ->
--       SeqValue (#t, maybeLoopEndSeq slotNum slotCount c, v#)

-- maybeLoopEndTuple :: Float -> Float -> Int -> Int -> SeqControl -> SeqControl
-- maybeLoopEndTuple dur maxDur slotNum slotCount control =
--   case control of
--     SeqEnd      -> SeqEnd
--     SeqBlockEnd -> SeqBlockEnd
--     _           ->
--       case (slotNum + 1) >= slotCount && dur >= maxDur of
--         True  -> SeqLoopEnd
--         False -> SeqLoopNormal

-- calcTupleTime :: Int -> Int -> Float -> (#Float, Float, Float#)
-- calcTupleTime slotNum slotCount time = (#tupleMul, slotTime, maxDur#)
--   where
--     tupleMul = recip (fromInt slotCount)
--     slotTime = floor time + frem (time * tupleMul - slotNum) 1
--     maxDur   = ceil slotTime - slotTime

-- tupleTick :: Int -> Int -> Float -> Seq a -> SeqValue a
-- tupleTick slotNum slotCount slotDelta s =
--   case calcTupleTime slotNum slotCount time of
--     (#tupleMul, slotTime, maxDur#) ->
--       case runSeq s slotTime of
--         SeqValue (#dur, control, value#) ->
--           SeqValue (#min dur maxDur / tupleMul, maybeLoopEndTuple dur maxDur slotNum slotCount control, value#)

-- calcTupleLiteralTime :: Int -> Float -> (#Float, Float, Float#)
-- calcTupleLiteralTime time = (#tupleMul, slotTime, maxDur#)
--   where
--     tupleMul = recip (fromInt slotCount)
--     slotTime = floor time + frem (time * tupleMul - slotNum) 1
--     maxDur   = ceil slotTime - slotTime

-- Deltas I believe are better, but we have to figure out how to handle bleed times from slot to slot
-- seq, tuple, interleave take delta, calculate time, then derive slot time, then derive slotDelta

-- calcInterleaveTime :: Int -> Int -> Float -> (#Float, Float#)
-- calcInterleaveTime slotNum slotCount time = (#slotTime, maxDur#)
--   where
--     tupleMul = recip (fromInt slotCount)
--     slotTime = floor time + frem (time - slotNum) 1
--     maxDur   = ceil slotTime - slotTime

-- interleaveTick :: Int -> Int -> Float -> Seq a -> SeqValue a
-- interleaveTick slotNum slotCount time s =
--   case calcInterleaveTime slotNum slotCount time of
--     (#slotTime, maxDur#) ->
--       case runSeq s slotTime of
--         SeqValue (#dur, control, value#) ->
--           SeqValue (#min dur maxDur, maybeLoopEndTuple dur maxDur 0 0 control, value#)

-- Seq Laws: Sequences should strive to be reversible and reentrant

-- <666 777 888 999> ==>
-- 0 ... 0.25 ... 0.5 ... 0.75 ... ==> 0 ... 0 ... 0 ... 0 ...
-- 1 ... 1.25 ... 1.5 ... 1.75 ... ==> 1 ... 1 ... 1 ... 1 ...

-- <<666 0> <777 1> <888 2> <999 3>> ==>
-- 0 ... 0.125 ... 0.25 ... 0.375 ... 0.5 ... 0.625 ... 0.75 ... 0.875 ... ==> 0 ... 0.5 ... 0 ... 0.5 ... 0 ... 0.5 ... 0 ... 0.5 ...
-- 1 ... 1.125 ... 1.25 ... 1.375 ... 1.5 ... 1.625 ... 1.75 ... 1.875 ... ==> 1 ... 1.5 ... 1 ... 1.5 ... 1 ... 1.5 ... 1 ... 1.5 ...

-- drop off boundary Pure values?

-- seqTest :: Seq Float
-- seqTest =
--   [0 _ 1 2]

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 3 4>]

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]

-- coolBeat :: Seq Float
-- coolBeat =
--   [
--     x y (y+y) z
--     _ x <5 z> x
--     _ 0 <1 2> y
--   ] * 2
--   where
--     x = <0 5 <1 2> 1>
--     y = 3
--     z = fromInt mouseX

-- seqTest3 :: Seq Float
-- seqTest3 =
--   [c d [2:y]]

-- seqTest4 :: Seq Float
-- seqTest4 =
--   [0 _ 1 [x:y:4]]
--   where
--     x = <1 2 3>
--     y = <4 5 6 7>

-- longTuple :: Seq Float
-- longTuple =
--   [0 1 _ [twentyOneSecondsOfRest:3]]
--
-- mixNMatch :: Seq Float
-- mixNMatch =
--   [x y (x + y) 1]
--   where
--     x = [1:2:3:4]
--     y = [3:2:1]
--
-- mixNMatch2 :: Seq Float
-- mixNMatch2 =
--   [0 _ 1 [x:y:mixNMatch]]
--   where
--     x = <1:[2|4]:3>
--     y = [<4:5> | <6:7:8>]
--
-- -- <|> => Merge
-- -- <|> ==> alternative operator?
--
-- mergedBeat :: Seq Float
-- mergedBeat = x <|> y
--   where
--     x = [1 _ <2:0:[3|4]> _]
--     y = [<_:4> <_:_:5> <_:6>]

-- sequenceTick ::

-- -- TODO: How to handle non constants in slots?
-- handMadeHemiola :: Seq Int
-- handMadeHemiola = Seq <| \_ ->
--   let
--     slot ~ 7 = remInt (slot + 1) 8
--   in
--     case slot of
--       0 -> SeqValue 0.5 100
--       1 -> SeqValue 0.5 150
--       2 -> SeqValue 1 200
--       3 -> SeqValue 1 300
--       4 -> SeqNil 0.25 SeqRest
--       5 -> SeqValue 0.25 425
--       6 -> SeqValue 0.25 450
--       _ -> SeqValue 0.25 475

-- handMadeHemiola :: Seq Int
-- handMadeHemiola =
--   <[100 150] 200 300 [_ 425 450 475]> |> map (d2f slendro)

--TODO: Make sure that seq combinators that take multiple seq inputs (map2, ap, etc) only demands the inputs after the duration for each specific input

-- printBeat :: *World -> *World
-- printBeat w = print handMadeHemiola w

-- properFraction :: (Fractional a, Integral b) -> a -> (b, b)

-- poly :: Audio a => (a -> a) -> Seq Float -> a
-- poly f (Seq s) = out
--   where
--     (children ~ default, currTime ~ 0, tick ~ 1) =
--       loop (c, t, tick') = (children, currTime, tick + 1) while t > tick' do
--         case s t of
--           SeqNil   t' _   -> (c, t + t', tick')
--           SeqValue t' arg -> (dynAppend (f (fromRational arg)) c, t + t', tick')

-- Add Bool to Audio which flags that it has ended!

-- flipTest2 :: Maybe Int
-- flipTest2 = map (flip add 33) Nothing

-- TODO:
-- accumulatePulse :: F64 -> F64 -> F64 -> (#F64, F64#)
-- accumulatePulse width freq acc =
--   (#acc3, out#)
--   where
--     acc2 = fma freq recipSampleRate acc
--     acc3 = acc2 - fastFloor acc2
--     out  = fma (fromInt (boolToInt (acc3 > width))) 2.0 (-1.0)
--
-- pulse :: Audio a => a -> a
-- pulse freq = accumulateAudio2 accumulatePulse freq

-- TODO: Seq notation
-- TODO: Seq
-- TODO: while loops
-- TODO: Defunctionalization
-- TODO: Rational Type
-- TODO: Stateful Unboxed types
-- TODO: Stateful Pattern assignment
-- TODO: toSIMDAudio :: Array BlockSize F64 -> Array SIMDBlockSize SIMDF64

-- TODO: Conal Elliot automatic differentiation
-- TODO: Get changes from Chad for apat desugaring
-- TODO: Throw this into a test
-- concatPairs :: (Int, Int) -> (Int, Int) -> (Int, Int) -> (Int, Int) -> (Int, Int, Int, Int, Int, Int, Int, Int)
-- concatPairs (a, b) (c, d) (e, f) (g, h) = (a, b, c, d, e, f,g, h)

