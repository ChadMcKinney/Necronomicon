--------------------
-- Necro.Base
--------------------

id :: .a -> .a
id x = x

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

fst :: .(a, b) -> .a
fst (x, _) = x

snd :: .(a, b) -> .b
snd t =
  case t of
    (_, y) -> y

fst' :: .(#a, b#) -> .a
fst' t =
  case t of
    (#x, _#) -> x

snd' :: .(#a, b#) -> .b
snd' t =
  case t of
    (#_, y#) -> y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  if x < y then
    x
  else
    y

-- TODO: Fold into Ord class
max :: Ord a => a -> a -> a
max x y =
  if x > y then
    x
  else
    y

uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y

uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry3 f (x, y, z) = f x y z

uncurry' :: (a -> b -> c) -> (#a, b#) -> c
uncurry' f (#x, y#) = f x y

uncurry3' :: (a -> b -> c -> d) -> (#a, b, c#) -> d
uncurry3' f (#x, y, z#) = f x y z

-- TODO: map3, etc
class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c

class Applicative f => Alternative f where
  empty       :: f a
  alternative :: f a -> f a -> f a

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

-- class Default a where
--   default :: !a

-- instance (Default a, Default b) => Default (a, b) where
--   default = (default, default)

mouseX :: Int
mouseX = getMouseX ()

mouseY :: Int
mouseY = getMouseY ()

sampleRate :: UInt
sampleRate = primUndefined

recipSampleRate :: F64
recipSampleRate = primUndefined


--------------------
-- Prim Instances
--------------------

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Semigroup F64 where
  append x y = x + y

instance Monoid F64 where
  mempty = 0

-- class Num a => Integral a where
--   quot :: a -> a -> Maybe a
--   rem :: a -> a -> Maybe a
--   div :: a -> a -> Maybe a
--   mod :: a -> a -> Maybe a

-- instance Integral Int where
--   quot x y = if y == 0 then Nothing else primUndefined
--   rem  x y = if y == 0 then Nothing else primUndefined
--   div  x y = if y == 0 then Nothing else primUndefined
--   mod  x y = if y == 0 then Nothing else primUndefined

--------------------
-- Int
--------------------
quotInt :: Int -> Int -> Int
quotInt x y = primUndefined

remInt :: Int -> Int -> Int
remInt x y = primUndefined

quotI64 :: I64 -> I64 -> I64
quotI64 x y = primUndefined

remI64 :: I64 -> I64 -> I64
remI64 x y = primUndefined


--------------------
-- Float
--------------------
fastFloor :: F64 -> F64
fastFloor x = primUndefined

floor :: F64 -> F64
floor x = primUndefined

fma :: F64 -> F64 -> F64 -> F64
fma x y z = primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
-- TODO: More efficient gcd algorithm
data Rational = Rational (#Int, Int#)

gcd :: Int -> Int -> Int
gcd x y =
  fst' <| loop (#a, b#) = (#abs x, abs y#) while b > 0 do
    (#b, remInt a b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational (#quotInt x d, quotInt y d#)
  where
    d = gcd x y

-- TODO: abs and signum are currently broken
rational :: Int -> Int -> Rational
rational x y = reduce x y
-- rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator (Rational (#n, _#)) = n

denominator :: Rational -> Int
denominator (Rational (#_, d#)) = d

instance Eq Rational where
  eq  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = eq (xn * yd) (yn * xd)
  neq (Rational (#xn, xd#)) (Rational (#yn, yd#)) = neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = lt  (xn * yd) (yn * xd)
  lte (Rational (#xn, xd#)) (Rational (#yn, yd#)) = lte (xn * yd) (yn * xd)
  gt  (Rational (#xn, xd#)) (Rational (#yn, yd#)) = gt  (xn * yd) (yn * xd)
  gte (Rational (#xn, xd#)) (Rational (#yn, yd#)) = gte (xn * yd) (yn * xd)

instance Num Rational where
  add (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yd + yn * xd) (xd * yd)
  sub (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yd - yn * xd) (xd * yd)
  mul (Rational (#xn, xd#)) (Rational (#yn, yd#)) = reduce (xn * yn) (xd * yd)
  abs (Rational (#xn, xd#))                       = Rational (#abs xn, xd#)
  signum (Rational (#xn, _#))                     = Rational (#signum xn, 1#)
  fromInt x                                       = Rational (#fromInt x, 1#)

-- -- TODO: Switch fromRational to use Rational type!
-- instance Fractional Rational where
--   div x y =
--     case x of
--       Rational (#xn, xd#) ->
--         case y of
--           Rational (#yn, yd#) ->
--             rational (xn * yd) (xd * yn)
--   recip x =
--     case x of
--       Rational (#n, d#) -> if n == 0 then Rational (#0, 1#) else
--         if n < 0
--           then rational d n
--           else rational d n
--   fromRational r = rational 1 1

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

-- rationalTest :: Rational
-- rationalTest = 33 * 44 + 23 - (1 // 4)

-- threeHalves :: Rational
-- threeHalves = 3 // 2


--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Default (Maybe a) where
  default = nothing

instance Semigroup (Maybe a) where
  append x y =
    case x of
      Nothing -> y
      _       -> x

instance Monoid (Maybe a) where
  mempty = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

instance Alternative Maybe where
  empty           = nothing
  alternative x y =
    case x of
      Nothing -> y
      _       -> x

maybe :: b -> (a -> b) -> Maybe a -> b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x

fromMaybe :: .a -> .Maybe a -> .a
fromMaybe defaultValue m =
  case m of
    Nothing -> defaultValue
    Just x  -> x


--------------------
-- Array
--------------------
unsafeEmptyArray :: () -> *Array n a
unsafeEmptyArray u = primUndefined

freezeArray :: *Array n (Share a) -> Array n a
freezeArray a = primUndefined

readArray :: Index n -> Array n a -> a
readArray i a = primUndefined

writeArray :: Index n -> *a -> *Array n a -> *Array n a
writeArray i x a = primUndefined

instance Default a => Default (Array n a) where
  default = arrayFrom default

arrayFrom :: a -> Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i (Share x) a

defaulted :: Array 4 (Maybe Int)
defaulted = default


--------------------
-- Seq
--------------------
data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
data SeqValue a = SeqValue (#Rational, SeqControl, Maybe a#)
data Seq a      = Seq (() -> SeqValue a)

mergeSeqValueTimes :: Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes xt xc yt yc =
  case xc of
    SeqPure -> yt
    _ ->
      case yc of
        SeqPure -> xt
        _       -> min xt yt

instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    if lt (fromEnum x) (fromEnum y) then
      x
    else
      y

instance Monoid SeqControl where
  mempty = SeqPure

seqControlFromEnumAlt :: SeqControl -> Int
seqControlFromEnumAlt s =
  case s of
    SeqNormal   -> 0
    SeqLoopEnd  -> 1
    SeqPure     -> 2
    SeqBlockEnd -> 3
    SeqEnd      -> 4

seqControlAlternative :: SeqControl -> SeqControl -> SeqControl
seqControlAlternative x y =
  if lt (seqControlFromEnumAlt x) (seqControlFromEnumAlt y) then
    x
  else
    y

instance Functor SeqValue where
  map f (SeqValue (#t, c, x#)) =
    SeqValue (#t, c, map f x#)

instance FunctorN SeqValue where
  map2 f (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#mergeSeqValueTimes xt xc yt yc, xc <> yc, map2 f xv yv#)

instance Applicative SeqValue where
  pure x = SeqValue (#1, SeqPure, Just x#)
  ap (SeqValue (#ft, fc, fv#)) (SeqValue (#xt, xc, xv#)) =
    SeqValue (#mergeSeqValueTimes xt xc ft fc, fc <> xc, ap fv xv#)

instance Semigroup (SeqValue a) where
  append (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#mergeSeqValueTimes xt xc yt yc, append xc yc, append xv yv#)

instance Monoid (SeqValue a) where
  mempty = SeqValue (#1, SeqPure, nothing#)

instance Alternative SeqValue where
  empty = SeqValue (#1, SeqEnd, nothing#)
  alternative (SeqValue (#xt, xc, xv#)) (SeqValue (#yt, yc, yv#)) =
    SeqValue (#mergeSeqValueTimes xt xc yt yc, seqControlAlternative xc yc, alternative xv yv#)

instance Default (SeqValue a) where
  default = SeqValue (#1, SeqPure, nothing#)

instance Num a => Num (SeqValue a) where
  fromInt i = SeqValue (#1, SeqPure, Just (fromInt i)#)
  add x y   = map2 add x y
  sub x y   = map2 sub x y
  mul x y   = map2 mul x y
  signum x  = map signum x
  abs x     = map abs x

instance Fractional a => Fractional (SeqValue a) where
  fromRational r = SeqValue (#1, SeqPure, Just (fromRational r)#)
  div x y        = map2 div x y
  recip x        = map recip x

runSeq :: Seq a -> () -> SeqValue a
runSeq (Seq stepFunc) _ = stepFunc ()

runSeq2 :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeq2 sx sy =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#xt, xc, xv#), SeqValue (#yt, yc, yv#)#) ->
          let
            t = min xt yt
            x = if xt <= t then runSeq sx () else SeqValue (#xt - t, xc, xv#)
            y = if yt <= t then runSeq sy () else SeqValue (#yt - t, yc, yv#)
          in
            (#x, y#)

seqValueDuration :: SeqValue a -> Rational
seqValueDuration (SeqValue (#t, _, _#)) = t

seqValueControl :: SeqValue a -> SeqControl
seqValueControl (SeqValue (#_, c, _#)) = c

runSeqOnLeft :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnLeft ls rs =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#lt, lc, _#), SeqValue (#rt, rc, rv#)#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue (#lt - t, lc, nothing#)
            r = if rt <= t then runSeq rs () else SeqValue (#rt - t, rc, rv#)
          in
            (#l, r#)

runSeqOnRight :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnRight ls rs =
  acc
  where
    acc ~ (#SeqValue (#0, SeqNormal, Nothing#), SeqValue (#0, SeqNormal, Nothing#)#) =
      case acc of
        (#SeqValue (#lt, lc, lv#), SeqValue (#rt, rc, _#)#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue (#lt - t, lc, lv#)
            r = if rt <= t then runSeq rs () else SeqValue (#rt - t, rc, nothing#)
          in
          (#l, r#)

instance Functor Seq where
  map f s = Seq (\_ -> map f (runSeq s ()))

instance Applicative Seq where
  pure x   = Seq (\_ -> pure x)
  ap fs xs = Seq (\_ -> ap (runSeq fs ()) (runSeq xs ()))

instance FunctorN Seq where
  map2 f sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 f x y)


--------------------
-- Print
--------------------
class Print a where
  print :: a -> *World -> *World

printInt :: Int -> *World -> *World
printInt i w = w

printI64 :: I64 -> *World -> *World
printI64 i w = w

printF64 :: F64 -> *World -> *World
printF64 f w = w

printChar :: Char -> *World -> *World
printChar c w = w

instance Print Int where
  print x w = printInt x w

instance Print I64 where
  print x w = printI64 x w

instance Print F64 where
  print x w = printF64 x w

instance Print Char where
  print x w = printChar x w

instance Print Rational where
  print (Rational (#n, d#)) w =
    print '(' w |> print n |> print ' ' |> print '/' |> print '/' |> print ' ' |> print d |> print ')'

instance Print a => Print (Maybe a) where
  print mx w =
    case mx of
      Nothing -> print '_' w
      Just x  -> print x w

instance Print a => Print (Array n a) where
  print a w =
    loop w' = w for i <- each do
      print (readArray i a) w'

instance Print a => Print (SeqValue a) where
  print (SeqValue (#t, _, v#)) w =
    print '(' w
    |> print t
    |> print ':'
    |> print v
    |> print ')'

printBarOnLoop :: SeqControl -> *World -> *World
printBarOnLoop c w =
  case c of
    SeqLoopEnd -> print '|' w |> print ' '
    _          -> w

instance Print a => Print (Seq a) where
  print s w = wout
    where
      tick ~ 0       = tick + blockDelta
      (#_, _, wout#) =
        loop (#Share cont, Share time, w'#) = (#Share True, Share 0, w#) while cont do
          let nextValueTime ~ 0 = nextValueTime + time in
            if nextValueTime >= tick then
              (#Share False, Share 0, w'#)
            else
              case runSeq s () of
                SeqValue (#t, c, Just x#) ->
                  (#Share True, Share t, print x w' |> print ' ' |> printBarOnLoop c#)
                SeqValue (#t, c, _#) ->
                  (#Share True, Share t, printBarOnLoop c w'#)

printLn :: Print a => a -> *World -> *World
printLn x w =
  print '\n' (print x w)

-- TODO: Kind Error
-- printArray :: *World -> *World
-- printArray w = print {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'} w

trace :: Print a => a -> b -> b
trace x y =
  case print x primUndefined of
    _ -> y

traceLn :: Print a => a -> b -> b
traceLn x y =
  case printLn x primUndefined of
    _ -> y



--------------------
-- Channel
--------------------
data Channel = ChannelEnd | BlockRate F64 | AudioRate (Array BlockSize F64)

outAudioBlock :: UInt -> Array BlockSize F64 -> *World -> *World
outAudioBlock c a w = primUndefined

outChannel :: UInt -> Channel -> *World -> *World
outChannel n c w =
  case c of
    ChannelEnd  -> w
    BlockRate _ -> w
    AudioRate b -> outAudioBlock n b w

audioInitArray :: () -> *Array BlockSize (Share F64)
audioInitArray u =
  loop a = unsafeEmptyArray () for i <- Range audioSampleOffset 1 (audioBlockSize - audioSampleOffset) do
    writeArray i (Share 0.0) a

mapChannel :: (F64 -> F64) -> Channel -> Channel
mapChannel f c =
  case c of
    ChannelEnd  -> ChannelEnd
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = audioInitArray () for i <- each do
        writeArray i (Share (f (readArray i b))) a

-- Loop constructs capturing owned/unique free_vars should be a type error!
mapChannel2 :: (F64 -> F64 -> F64) -> Channel -> Channel -> Channel
mapChannel2 f cx cy =
  case cx of
    ChannelEnd  -> ChannelEnd
    BlockRate x ->
      case cy of
        ChannelEnd  -> ChannelEnd
        BlockRate y ->
          BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- each do
            writeArray i (Share (f x (readArray i y))) a
    AudioRate x ->
      case cy of
        ChannelEnd  -> ChannelEnd
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- each do
            writeArray i (Share (f (readArray i x) y)) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- each do
            writeArray i (Share (f (readArray i x) (readArray i y))) a
  where
    ia = audioInitArray ()

-- data ProxyNat (n :: Nat) = ProxyNat

-- natValue :: ProxyNat n -> UInt
-- natValue p = primUndefined

-- range :: UInt -> UInt -> UInt -> Proxy n -> Range n
-- range startOffset increment endOffset p = Range startOffset increment (natValue p - endOffset)

-- withRangeOf :: f n -> g n -> f n
-- withRangeOf x _ = x

audioBlockSize :: UInt
audioBlockSize = 32 * 64

audioBlockSizeF :: Float
audioBlockSizeF = 32 * 64

audioSampleOffset :: UInt
audioSampleOffset = 0

-- TODO: Replace freezeArray (unsafeEmptyArray ()) with primUndefined???
-- TODO: Handle input1 Ending!
-- TODO: Finish with this and port change to maybeEnd version
accumulateChannel1 :: Default s => (F64 -> s -> (#s, F64#)) -> Channel -> Channel
accumulateChannel1 f input1 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case out of
        (_, a) -> AudioRate a
  where
    offsetToEndRange = Range audioSampleOffset 1 0
    ia               = audioInitArray ()
    out ~ (default, primUndefined) =
      case out of
        (state, _) ->
          let
            (#Share state', o'#) =
              case input1 of
                ChannelEnd          -> (#Share state, ia#)
                BlockRate input1Val ->
                  loop (#Share s, o#) = (#Share state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#Share s', writeArray i (Share x) o#)
                AudioRate input1Buffer ->
                  loop (#Share s, o#) = (#Share state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#Share s', writeArray i (Share x) o#)
          in
            (state', freezeArray o')

-- TODO: Replace freezeArray (unsafeEmptyArray ()) with primUndefined???
accumulateChannelAndMaybeEnd1 :: Default s => (F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Channel -> Channel
accumulateChannelAndMaybeEnd1 f isRunningFunc input1 =
  case input1 of
    ChannelEnd -> ChannelEnd
    _          ->
      case out of
        (s, a) ->
          case isRunningFunc s of
            False -> ChannelEnd
            _     -> AudioRate a
  where
    ia = audioInitArray ()
    out ~ (default, primUndefined) =
      case out of
        (state, _) ->
          let
            (#Share state', o'#) =
              case input1 of
                ChannelEnd          -> (#Share state, ia#)
                BlockRate input1Val ->
                  loop (#Share s, o#) = (#Share state, ia#) for i <- each do
                    case f input1Val s of
                      (#s', x#) ->
                        (#Share s', writeArray i (Share x) o#)
                AudioRate input1Buffer ->
                  loop (#Share s, o#) = (#Share state, ia#) for i <- each do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#Share s', writeArray i (Share x) o#)
          in
            (state', freezeArray o')

instance Num Channel where
  fromInt i = BlockRate (fromInt i)
  add l r   = mapChannel2 add l r
  sub l r   = mapChannel2 sub l r
  mul l r   = mapChannel2 mul l r
  signum c  = mapChannel signum c
  abs c     = mapChannel abs c


--------------------
-- Complex
--------------------
data Complex = Complex (#F64, F64#)

-- TODO: Finish

realPart :: Complex -> F64
realPart (Complex (#r, _#)) = r

imagPart :: Complex -> F64
imagPart (Complex (#_, i#)) = i

mkPolar :: F64 -> F64 -> Complex
mkPolar r theta = primUndefined

cis :: F64 -> F64 -> Complex
cis r theta = primUndefined

polar :: Complex -> (F64, F64)
polar z = primUndefined

magnitude :: Complex -> F64
magnitude z = primUndefined

phase :: Complex -> F64
phase z = primUndefined

instance Num Complex where
  fromInt z                                     = Complex (#fromInt z, 0#)
  add (Complex (#rx, ix#)) (Complex (#ry, iy#)) = Complex (#rx + ry, ix + iy#)
  sub (Complex (#rx, ix#)) (Complex (#ry, iy#)) = Complex (#rx - ry, ix - iy#)
  mul (Complex (#rx, ix#)) (Complex (#ry, iy#)) = Complex (#rx * ry - ix * iy, rx * iy + ix * ry#)
  abs z                                         = Complex (#magnitude z, 0#)
  signum z                                      =
    case z of
      Complex (#r, i#) ->
        if r == 0 && i == 0 then 0 else
          let m = magnitude z in
            Complex (#r / m, i / m#)


--------------------
-- FFT
--------------------
-- https://www.dspguide.com/ch12/1.htm
-- FFT bins are represented as complex numbers wherein phase is encoded as the angle of a 2D vector and amplitude is encoded as the magnitude of the 2D vector.
data FFT f n  = FFT (f (Array n Complex))


--------------------
-- AudioFormat
--------------------
data Mono a      = Mono a
data Stereo a    = Stereo (#a, a#)
data Quad a      = Quad (#a, a, a, a#)
data Ambisonic a = Ambisonic (#a, a, a, a#)

data Audio f     = Audio (f Channel)

-- TODO: Equal power panning
class AudioFormat f where
  accumulate1       :: Default s => (F64 -> s -> (#s, F64#)) -> Audio f -> Audio f
  accumulateFinite1 :: Default s => (F64 -> s -> (#s, F64#)) -> (s -> Bool) -> Audio f -> Audio f
  pan               :: Audio Mono -> Audio f -> Audio Stereo
  outAudio          :: UInt -> Audio f -> *World -> *World

instance Functor Mono where
  map f (Mono x) = Mono (f x)

instance FunctorN Mono where
  map2 f (Mono x) (Mono y) = Mono (f x y)

instance Applicative Mono where
  pure x               = Mono x
  ap (Mono f) (Mono x) = Mono (f x)

instance AudioFormat Mono where
  outAudio  n (Audio (Mono c))  w                = outChannel n c w
  accumulate1 f (Audio (Mono c))                 = Audio <| Mono (accumulateChannel1 f c)
  accumulateFinite1 f sf (Audio (Mono c))        = Audio <| Mono (accumulateChannelAndMaybeEnd1 f sf c)
  pan (Audio (Mono amount)) (Audio (Mono input)) = Audio <| Stereo (#mul input (sub 1 amount), mul input amount#)

instance Functor Stereo where
  map f (Stereo (#x, y#)) = Stereo (#f x, f y#)

instance FunctorN Stereo where
  map2 f (Stereo (#x1, x2#)) (Stereo (#y1, y2#)) = Stereo (#f x1 y1, f x2 y2#)

instance Applicative Stereo where
  pure x                                     = Stereo (#x, x#)
  ap (Stereo (#f1, f2#)) (Stereo (#x1, x2#)) = Stereo (#f1 x2, f2 x2#)

instance AudioFormat Stereo where
  outAudio  n (Audio (Stereo (#l, r#))) w             = outChannel (add n 1) r (outChannel n l w)
  accumulate1 f (Audio (Stereo (#l, r#)))             = Audio <| Stereo (#accumulateChannel1 f l, accumulateChannel1 f r#)
  accumulateFinite1 f sf (Audio (Stereo (#l, r#)))    = Audio <| Stereo (#accumulateChannelAndMaybeEnd1 f sf l, accumulateChannelAndMaybeEnd1 f sf r#)
  pan (Audio (Mono amount)) (Audio (Stereo (#l, r#))) = Audio <| Stereo (#mul l (sub 1 amount), mul r amount#)

instance Num a => Num (Mono a) where
  fromInt i = Mono (fromInt i)
  add l r   = map2 add l r
  sub l r   = map2 sub l r
  mul l r   = map2 mul l r
  signum c  = map signum c
  abs c     = map abs c

instance Num a => Num (Stereo a) where
  fromInt i = let c = fromInt i in Stereo (#c, c#)
  add l r   = map2 add l r
  sub l r   = map2 sub l r
  mul l r   = map2 mul l r
  signum c  = map signum c
  abs c     = map abs c

instance Fractional Channel where
  fromRational r = BlockRate (fromRational r)
  div l r        = mapChannel2 div l r
  recip c        = mapChannel recip c

instance Fractional a => Fractional (Mono a) where
  fromRational r = Mono (fromRational r)
  div l r        = map2 div l r
  recip c        = map recip c

instance Fractional a => Fractional (Stereo a) where
  fromRational r = let c = fromRational r in Stereo (#c, c#)
  div l r        = map2 div l r
  recip c        = map recip c

instance Semigroup Channel where
  append x y = x + y

instance Monoid Channel where
  mempty = 0

instance Semigroup a => Semigroup (Mono a) where
  append x y = map2 append x y

instance Monoid a => Monoid (Mono a) where
  mempty = Mono mempty

instance Semigroup a => Semigroup (Stereo a) where
  append x y = map2 append x y

instance Monoid a => Monoid (Stereo a) where
  mempty = let c = mempty in Stereo (#c, c#)

stereo :: Mono a -> Mono a -> Stereo a
stereo (Mono l) (Mono r) =
  Stereo (#l, r#)

accumulateSaw :: F64 -> F64 -> (#F64, F64#)
accumulateSaw freq acc =
  (#acc3, out#)
  where
    acc2 = fma freq recipSampleRate acc
    acc3 = acc2 - fastFloor acc2
    out  = fma acc3 2.0 (-1.0)

-- Switch things such that Audio is a container type, and change back to Channel data structure
saw :: AudioFormat f => Audio f -> Audio f
saw freq =
  accumulate1 accumulateSaw freq

-- TODO: Replace with llvm instruction!
select :: Bool -> a -> a -> a
select c t f = if c then t else f

accumulatePerc :: (#F64, F64, F64, F64#) -> F64 -> F64 -> (#F64, F64#)
accumulatePerc (#attackTime, recipAttackTime, recipDecayTime, curve#) input state =
  (#state', out#)
  where
    state'      = state + recipSampleRate
    attackDelta = state' * recipAttackTime
    decayDelta  = 1 - ((state' - attackTime) * recipDecayTime)
    out         = select (state' <= attackTime) attackDelta decayDelta * input

percIsRunning :: F64 -> Bool
percIsRunning state = if state < 1 then True else False

perc :: AudioFormat f => F64 -> F64 -> F64 -> Audio f -> Audio f
perc attackTime decayTime curve input =
  accumulateFinite1 (accumulatePerc (#attackTime, recip attackTime, recip decayTime, curve#)) percIsRunning input

coolSynth :: Audio Mono
coolSynth =
  saw 440 |> perc 0.1 10 (-3)

blocksPerSecond :: Rational
blocksPerSecond = 48000 // 64

blockDelta :: Rational
blockDelta = recipRational blocksPerSecond

-- class Foldable f where
--   fold  :: Monoid m => f m -> m
--   foldl :: (b -> a -> b) -> b -> f a -> b
--   foldp :: (b -> a -> b) -> f a -> b

-- -- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     acc'
--     where
--       (#tick' ~ 0, time' ~ 0, acc' ~ mempty#) =
--         loop (#tick, time, acc#) = (#tick' + 1, time', acc'#) while time < tick do
--           case runSeq s () of
--             SeqValue (#t, _, Just x#) -> (#tick, time + t, f acc x#)
--             SeqValue (#t, _, _#)      -> (#tick, time + t, acc#)
--
-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- seqTest :: Seq Float
-- -- seqTest :: Seq Int
-- seqTest =
--   [0 _ 1 2] + [<3 4> _ <5 6> <7 8 9>]

-- seqTestGo :: SeqValue Float
-- seqTestGo =
--   runSeq seqTest ()

-- notAnInt :: Seq Float
-- notAnInt = 2 / 3

-- doubleTrouble :: SeqValue Int
-- doubleTrouble =
--   runSeq (2 * <33 44 <0 _ 1 2>>) ()

-- appendSeq :: Seq a -> Seq a -> Seq a
-- appendSeq x y = [x y]

-- appendGo :: SeqValue Rational
-- appendGo = runSeq (appendSeq 1 2) ()

--------------------
-- Ptr
--------------------
ptrMalloc :: UInt -> *Ptr a
ptrMalloc capacity = primUndefined

ptrRealloc :: UInt -> *Ptr a -> *Ptr a
ptrRealloc capacity = primUndefined

ptrFree :: *Ptr a -> *()
ptrFree ptr = primUndefined

-- unsafePtrPeek :: UInt -> *Ptr (Share a) -> *(#Share a, Ptr (Share a)#)
-- unsafePtrPeek index ptr = primUndefined

unsafePtrPoke :: UInt -> *a -> *Ptr a -> *Ptr a
unsafePtrPoke index value ptr = primUndefined

unsafePtrSwapElement :: UInt -> *a -> *Ptr a -> *(#a, Ptr a#)
unsafePtrSwapElement index element ptr = primUndefined

-- unsafeCastPtr :: *Ptr a -> *Ptr b
-- unsafeCastPtr = primUndefined


----------------------
-- MutRef: Something of a hack to allow for recursively owned types...
----------------------
-- data MutRef a = MutRef (Ptr (Maybe a))

-- HACK / NOTE: mutRef expects the first argument to be CONSTANT (Need to support this concept in the type system...)
mutRef :: *Maybe a -> *Ptr (Maybe a)
mutRef x =
  primUndefined

mutRefTake :: (() -> *a) -> *(#a, Ptr (Maybe a)#)
mutRefTake mkFn =
  case unsafePtrSwapElement 0 Nothing (mutRef Nothing) of
    (#mx, ptr1#) ->
      case mx of
        Just x  -> (#x, ptr1#)
        Nothing -> (#mkFn (), ptr1#)

mutRefPut :: *a -> *Ptr (Maybe a) -> *Ptr (Maybe a)
mutRefPut x ptr =
  unsafePtrPoke 0 (Just x) ptr


----------------------
-- DynArray
----------------------

data DynTier     a = DynTier (#Share UInt, Share UInt, Share UInt, Ptr a#)
data DynArray    a = DynArray (#DynTier a, DynTier a#)
data DynTierIndex  = DynTierLow | DynTierHigh
data DynArrayIndex = DynArrayIndex (#DynTierIndex, UInt#)

dynArrayIndexEmpty :: DynArrayIndex
dynArrayIndexEmpty = DynArrayIndex (#DynTierLow, 0#)

dynTierEmpty :: UInt -> *DynTier a
dynTierEmpty capacity =
  DynTier (#Share capacity, Share 0, Share 0, ptrMalloc capacity#)

dynArrayEmpty :: UInt -> *DynArray a
dynArrayEmpty capacity =
  DynArray (#dynTierEmpty 0, dynTierEmpty capacity#)

dynTierPop :: *DynTier a -> *(#Maybe a, DynTier a#)
dynTierPop (DynTier (#Share capacity, Share count, Share highWaterMark, ptr#)) =
  if count > 0 then
    case unsafePtrSwapElement (count - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#Just element, DynTier (#Share capacity, Share (count - 1), Share (highWaterMark - 1), ptr'#)#)
  else
    (#Nothing, DynTier (#Share capacity, Share count, Share highWaterMark, ptr#)#)

dynTierSwapToEndAndDelete :: UInt -> *DynTier a -> *DynTier a
dynTierSwapToEndAndDelete index (DynTier (#Share capacity, Share count, Share highWaterMark, ptr#))=
  if index >= capacity then
    DynTier (#Share capacity, Share count, Share highWaterMark, ptr#)
  else
    case unsafePtrSwapElement index primUndefined ptr of
      (#indexElement, ptr2#) ->
        case unsafePtrSwapElement (count - 1) indexElement ptr2 of
          (#endElement, ptr3#) ->
            DynTier (#Share capacity, Share (count - 1), Share highWaterMark, unsafePtrPoke index endElement ptr3#)

-- NOTE: This assumes that the tier is correctly sized!
dynTierAppend :: *a -> *DynTier a -> *DynTier a
dynTierAppend element (DynTier (#Share capacity, Share count, Share highWaterMark, ptr#)) =
  DynTier (#Share capacity, Share (count + 1), Share (highWaterMark + 1), unsafePtrPoke count element ptr#)

dynArrayPromoteElement :: *DynArray a -> *DynArray a
dynArrayPromoteElement (DynArray (#low, high#)) =
  case dynTierPop low of
    (#Nothing,      low'#) -> DynArray (#low', high#)
    (#Just element, low'#) -> DynArray (#low', dynTierAppend element high#)

-- NOTE: This assumes that the low tier has been completely moved to the high tier
dynArrayResize :: *DynArray a -> *DynArray a
dynArrayResize (DynArray (#DynTier (#Share lcap, Share lcount, Share lhwm, lowPtr#), DynTier (#Share highCapacity, Share highCount, Share hhwm, highPtr#)#)) =
  if highCount < highCapacity then
    DynArray (#DynTier (#Share lcap, Share lcount, Share lhwm, lowPtr#), DynTier (#Share highCapacity, Share highCount, Share hhwm, highPtr#)#)
  else
    let
      newCap  = highCapacity * 2
      newLow  = DynTier (#Share highCapacity, Share highCount, Share hhwm, highPtr#)
      newHigh = DynTier (#Share newCap, Share 0, Share 0, ptrRealloc newCap lowPtr#)
    in
      DynArray (#newLow, newHigh#)

dynArrayAppend :: *a -> *DynArray a -> *DynArray a
dynArrayAppend element a =
  case dynArrayResize (dynArrayPromoteElement a) of
    DynArray (#low, high#) ->
      DynArray (#low, dynTierAppend element high#)

dynTierModifyElement :: UInt -> (*a -> *a) -> *DynTier a -> *DynTier a
dynTierModifyElement index f (DynTier (#capacity, Share count, highWaterMark, ptr0#)) =
  if index >= count then
    DynTier (#capacity, Share count, highWaterMark, ptr0#)
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element, ptr1#) ->
        DynTier (#capacity, Share count, highWaterMark, unsafePtrPoke index (f element) ptr1#)

dynArrayModifyElement :: DynArrayIndex -> (*a -> *a) -> *DynArray a -> *DynArray a
dynArrayModifyElement (DynArrayIndex (#tier, index#)) f (DynArray (#low, high#)) =
  case tier of
    DynTierLow  -> DynArray (#dynTierModifyElement index f low, high#)
    DynTierHigh -> DynArray (#low, dynTierModifyElement index f high#)

dynTierWithElement :: UInt -> (*a -> *(#Share b, a#)) -> *DynTier a -> *(#Share (Maybe b), DynTier a#)
dynTierWithElement index f (DynTier (#capacity, Share count, highWaterMark, ptr0#)) =
  if index >= count then
    (#Share Nothing, DynTier (#capacity, Share count, highWaterMark, ptr0#)#)
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element0, ptr1#) ->
        case f element0 of
          (#Share result, element1#) ->
            (#Share (Just result), DynTier (#capacity, Share count, highWaterMark, unsafePtrPoke index element1 ptr1#)#)

dynArrayWithElement :: DynArrayIndex -> (*a -> *(#Share b, a#)) -> *DynArray a -> *(#Share (Maybe b), DynArray a#)
dynArrayWithElement (DynArrayIndex (#tier, index#)) f (DynArray (#low, high#)) =
  case tier of
    DynTierLow ->
      case dynTierWithElement index f low of
        (#result, low'#) ->
          (#result, DynArray (#low', high#)#)
    DynTierHigh ->
      case dynTierWithElement index f high of
        (#result, high'#) ->
          (#result, DynArray (#low, high'#)#)

dynArrayDelete :: DynArrayIndex -> *DynArray a -> *DynArray a
dynArrayDelete (DynArrayIndex (#tier, index#)) (DynArray (#low, high#)) =
  case tier of
    DynTierLow  -> DynArray (#dynTierSwapToEndAndDelete index low, high#)
    DynTierHigh -> DynArray (#low, dynTierSwapToEndAndDelete index high#)

-- TODO: Nested case literals seem broken!
-- dynArrayDelete :: DynArrayIndex -> *DynArray a -> *DynArray a
-- dynArrayDelete index (DynArray (#low, high#)) =
--   case index of
--     DynArrayIndex (#DynTierLow,  index'#) -> DynArray (#dynTierSwapToEndAndDelete index' low, high#)
--     DynArrayIndex (#DynTierHigh, index'#) -> DynArray (#low, dynTierSwapToEndAndDelete index' high#)

dynArrayEmplaceOrAppend :: (*a -> *a) -> (() -> *a) -> *DynArray a -> *DynArray a
dynArrayEmplaceOrAppend emplaceInit appendMk (DynArray (#low, DynTier (#highCapacity, Share highCount, Share highWaterMark, highPtr#)#)) =
  if highCount < highWaterMark then
    DynArray (#low, dynTierModifyElement (highCount + 1) emplaceInit <| DynTier (#highCapacity, Share (highCount + 1), Share highWaterMark, highPtr#)#)
  else
    DynArray (#low, dynTierAppend (appendMk ()) <| DynTier (#highCapacity, Share highCount, Share highWaterMark, highPtr#)#)

data DynArrayIterator a = DynArrayIterator (#Share DynArrayIndex, DynArray a#)

dynArrayIterator :: *DynArray a -> *DynArrayIterator a
dynArrayIterator a = DynArrayIterator (#Share dynArrayIndexEmpty, a#)

dynArrayIteratorEnd :: *DynArrayIterator a -> *DynArray a
dynArrayIteratorEnd (DynArrayIterator (#_, array#)) = array

dynArrayIteratorEmplaceOrAppend :: (*a -> *a) -> (() -> *a) -> *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorEmplaceOrAppend emplaceInit appendMk (DynArrayIterator (#_, array#)) =
  DynArrayIterator (#Share dynArrayIndexEmpty, dynArrayEmplaceOrAppend emplaceInit appendMk array#)

dynArrayIteratorWithElement :: (*a -> *(#Share b, a#)) -> *DynArrayIterator a -> *(#Share (Maybe b), DynArrayIterator a#)
dynArrayIteratorWithElement f (DynArrayIterator (#Share index, array#)) =
  case dynArrayWithElement index f array of
    (#result, array'#) ->
      (#result, DynArrayIterator (#Share index, array'#)#)

dynArrayIteratorNext :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorNext (DynArrayIterator (#Share (DynArrayIndex (#tier, index#)), DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)) =
  case tier of
    DynTierLow ->
      if index < lcount then
        DynArrayIterator (#Share (DynArrayIndex (#DynTierLow, index + 1#)), DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)
      else
        DynArrayIterator (#Share (DynArrayIndex (#DynTierHigh, 0#)), DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)
    DynTierHigh ->
      DynArrayIterator (#Share (DynArrayIndex (#DynTierHigh, index + 1#)), DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)

dynArrayIteratorFree :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorFree iter =
  case iter of
    DynArrayIterator (#Share index, array#) ->
      case dynArrayDelete index array of
        DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#) ->
          case index of
            DynArrayIndex (#tier, _#) ->
              case tier of
                DynTierLow ->
                  if lcount > 0 then
                    DynArrayIterator (#Share index, DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)
                  else
                    DynArrayIterator (#Share (DynArrayIndex (#DynTierHigh, 0#)), DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)
                DynTierHigh ->
                  DynArrayIterator (#Share index, DynArray (#DynTier (#lcap, Share lcount, lhwm, lptr#), DynTier (#hcap, Share hcount, hhwm, hptr#)#)#)


--------------------
-- PolyThunks
--------------------
data PolyThunkState = PolyThunkAlloc | PolyThunkInit | PolyThunkEval
data PolyThunk a    = PolyThunk (#Ptr (), Ptr (), a, PolyThunkState, Share Float#)
-- UpdateState, CopyState, Arg, ThunkState, SampleOffset

dynDeepCopy :: a -> *(#Ptr (), Share a#)
dynDeepCopy x =
  primUndefined

dynDeepCopyInto :: *Ptr () -> a -> *(#Ptr (), Share a#)
dynDeepCopyInto copyState x =
  primUndefined

polyThunkAlloc :: a -> Float -> () -> *PolyThunk (Share a)
polyThunkAlloc x sampleOffset u =
  case dynDeepCopy x of
    (#copyState, x'#) ->
      PolyThunk (#primUndefined, copyState, x', PolyThunkAlloc, Share sampleOffset#)

polyThunkInit :: a -> Float -> *PolyThunk (Share a) -> *PolyThunk (Share a)
polyThunkInit x sampleOffset (PolyThunk (#updateState, copyState, _, _, _#))  =
  case dynDeepCopyInto copyState x of
    (#copyState', x'#) ->
      PolyThunk (#updateState, copyState', x', PolyThunkInit, Share sampleOffset#)

polyThunkEvalGo :: (a -> b) -> a -> b
polyThunkEvalGo f x =
  case f x of
    result ->
      result

polyThunkEval :: (a -> b) -> *PolyThunk (Share a) -> *(#Share b, PolyThunk (Share a)#)
polyThunkEval f t =
  let
    dummy = polyThunkEvalGo f primUndefined
  in
    primUndefined

----------------------
-- Poly
----------------------
class Finite a where
  isRunning :: a -> Bool

instance Finite Channel where
  isRunning c =
    case c of
      ChannelEnd -> True
      _          -> False

instance Finite a => Finite (Mono a) where
  isRunning (Mono x) = isRunning x

instance Finite a => Finite (Stereo a) where
  isRunning (Stereo (#l, r#)) = isRunning l && isRunning r

-- TODO: Finish
-- instance AudioFormat f => Finite (Audio f) where
--   isRunning (Audio cs) = mapChannels

class (Monoid p, Finite p) => Poly p where

instance Poly Channel where
instance Poly (Mono a) where
instance Poly (Stereo a) where
instance Poly (Audio f) where

calculateAudioSampleOffset :: Rational -> Rational -> Float
calculateAudioSampleOffset valueTime tickTime =
  (fromInt n / fromInt d) * audioBlockSizeF
  where
    Rational (#n, d#) = valueTime - tickTime

poly :: Poly b => (a -> b) -> Seq a -> b
poly f s =
  case mutRefTake (\_ -> dynArrayEmpty 8) of
    (#thunks0, mref#) ->
      let
        tick ~ 0                      = tick + blockDelta
        (#_, _, Share acc', thunks4#) =
          loop (#Share cont, Share time, Share acc, thunks1#) = (#Share True, Share 0, Share mempty, dynArrayIterator thunks0#) while cont do
            let nextValueTime ~ 0 = nextValueTime + time in
              if nextValueTime < tick then
                case runSeq s () of
                  SeqValue (#t, _, Just x#) ->
                    (#Share True, Share t, Share acc, dynArrayIteratorEmplaceOrAppend (polyThunkInit x (calculateAudioSampleOffset nextValueTime tick)) (polyThunkAlloc x (calculateAudioSampleOffset nextValueTime tick)) thunks1#)
                  SeqValue (#t, _, _#) ->
                    (#Share True, Share t, Share acc, thunks1#)
              else
                case dynArrayIteratorWithElement (polyThunkEval f) thunks1 of
                  (#Share maybeEvalResult, thunks2#) ->
                    case maybeEvalResult of
                      Just evalResult ->
                        if isRunning evalResult then
                          (#Share True, Share 0, Share (append acc evalResult), dynArrayIteratorNext thunks2#)
                        else
                          (#Share True, Share 0, Share acc, dynArrayIteratorFree thunks2#)
                      _ ->
                        (#Share False, Share 0, Share acc, thunks2#)
      in
        case mutRefPut (dynArrayIteratorEnd thunks4) mref of
          _ -> acc'

----------------------
-- Seq continued
----------------------

instance Num a => Num (Seq a) where
  fromInt i = Seq (\_ -> pure (fromInt i))
  add sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 add x y)
  sub sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 sub x y)
  mul sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 mul x y)
  signum x  = Seq (\_ -> map signum (runSeq x ()))
  abs x     = Seq (\_ -> map abs (runSeq x ()))

instance Fractional a => Fractional (Seq a) where
  fromRational r = Seq (\_ -> pure (fromRational r))
  div sx sy      = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 div x y)
  recip x        = Seq (\_ -> map recip (runSeq x ()))

instance Semigroup (Seq a) where
  append sx sy = [sx sy]

instance Monoid (Seq a) where
  mempty = Seq (\_ -> SeqValue (#1, SeqPure, nothing#))

instance Alternative Seq where
  empty             = Seq (\_ -> SeqValue (#1, SeqPure, nothing#))
  alternative sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in alternative x y)

-- TODO: <|>

-- Biased BinOps
-- +@  @+  +
-- -@  @-  -
-- *@  @*  *
-- /@  @/  /
-- <@  @< @<@
-- >@  @> @>@

leftConst :: a -> b -> a
leftConst x _ = x

rightConst :: a -> b -> b
rightConst _ y = y

addSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
addSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 add l r)

addSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
addSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 add l r)

subSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
subSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 sub l r)

subSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
subSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 sub l r)

mulSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 mul l r)

mulSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 mul l r)

divSeqOnLeft :: Fractional a => Seq a -> Seq a -> Seq a
divSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 div l r)

divSeqOnRight :: Fractional a => Seq a -> Seq a -> Seq a
divSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 div l r)

leftConstSeqOnLeft :: Seq a -> Seq b -> Seq a
leftConstSeqOnLeft ls _ = ls

leftConstSeqOnRight :: Seq a -> Seq b -> Seq a
leftConstSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 leftConst l r)

rightConstSeqOnLeft :: Seq a -> Seq b -> Seq b
rightConstSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 rightConst l r)

rightConstSeqOnRight :: Seq a -> Seq b -> Seq b
rightConstSeqOnRight _ rs = rs

leftConstSeqOnBoth :: Seq a -> Seq b -> Seq a
leftConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 leftConst l r)

rightConstSeqOnBoth :: Seq a -> Seq b -> Seq b
rightConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 rightConst l r)

-- addSeqOnLeftTest :: Seq Int
-- addSeqOnLeftTest =
--   [1 _ <2 3>] @+ [4 <5 6> <7 8 9>] *@ [1 2 _ 5] @- <3 4 5> @> fromInt mouseX

-- mouseBeat :: Seq Float
-- mouseBeat = fromInt mouseX <@ coolBeat

-- addSeqOnRightTest :: SeqValue Int
-- addSeqOnRightTest = runSeq (rightConstSeqOnLeft 1 2) ()

restSeqValue :: SeqValue a
restSeqValue =
  SeqValue (#1, SeqPure, nothing#)

rest :: Seq a
rest =
  Seq (\_ -> restSeqValue)

seqValueDurationMul :: Rational -> SeqValue a -> SeqValue a
seqValueDurationMul speed (SeqValue (#t, c, v#)) =
  SeqValue (#t * speed, c, v#)

recipRational :: Rational -> Rational
recipRational (Rational (#n, d#)) = d // n

seqSpeed :: Rational -> Seq a -> Seq a
seqSpeed speed seq = Seq (\_ -> seqValueDurationMul (recipRational speed) (runSeq seq ()))

bpm :: Int -> Rational
bpm tempoInBPM = tempoInBPM // 60

toSeq :: SeqValue a -> Seq a
toSeq sv = Seq (\_ -> sv)

-- altTest :: SeqValue Int
-- altTest = runSeq (alternative [0 1 _ 3] [_ <2 9> 55 _]) ()

-- seqLoop :: (Seq a -> Seq a) -> Seq a
-- seqLoop sf = Seq (\_ -> let x ~ default = runSeq (sf (toSeq x)) () in x)

-- myRecSeq :: Seq Int
-- myRecSeq = seqLoop <| \x ->
--   [1 2 <(x * 4) _ 4>]

seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  if (slot + 1) < maxSlot then
    SeqNormal
  else
    SeqLoopEnd

-- Combining nested case statements with case literals seems to break...
slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue (#t, c, v#) ->
      case c of
        SeqNormal -> (#slot, sv#)
        _         -> (#remInt (slot + 1) maxSlot, SeqValue (#t, controlIfNotNormal, v#)#)

seqTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
seqTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) sv

tupleTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
tupleTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (seqValueDurationMul (1 // maxSlot) sv)

interleaveTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot sv =
  slotTick slot maxSlot SeqLoopEnd sv

-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

-- percSaw :: Audio Mono -> Audio Mono
-- percSaw freq = saw freq |> perc 0.1 3 1

-- TODO: Test new poly scheme
percSynth :: Audio Mono -> Audio Mono -> Audio Mono
-- percSynth = poly percSaw [440 220 _ <110 55 _ 330>]
percSynth = poly (saw .> perc 0.1 3 1 .> mul 0.1) [440 220 _ <110 55 _ 330>]
-- percSynth = poly (\f -> saw f |> perc 0.1 3 1) [440 220 _ <110 55 _ 330>]

panTest :: Audio Mono
panTest = saw 440 |> pan 0.25

-- myCoolSynth2 :: Audio Mono
-- myCoolSynth2 =
--   poly (\f -> saw (offset + offset2 + f)) [440 220 _ <110 55 _ 330>]
--   where
--     offset  = myLocalSawThing 220
--     offset2 = 40


-- + poly (fromInt .> saw) [1 2 3]

-- data FFT a = FFT

-- poly2 :: Poly c => (a -> b -> c) -> Seq a -> Seq b -> c
-- poly2 f x y = poly (uncurry' f) <| map2 (\x' y' -> (#x', y'#)) x y

-- coolMultiSaw :: Audio Mono
-- coolMultiSaw = poly2 multiSaw freq filterFreq

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- tupleTestGo :: SeqValue Float
-- tupleTestGo = runSeq tupleTest ()

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- interleaveTestGo :: SeqValue Float
-- interleaveTestGo = runSeq interleaveTest ()

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- seqTest1Go :: SeqValue Float
-- seqTest1Go = runSeq seqTest1 ()

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 _ 4>]

-- seqTest2Go :: SeqValue Float
-- seqTest2Go = runSeq seqTest2 ()

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]

-- proceduralBeat :: Seq Float
-- proceduralBeat = Seq <| \_ ->
--   let
--     tick ~ 0 = tick + 1
--     value    = tick * 100 + fromInt mouseY * fromInt mouseX
--   in
--     SeqValue (#2, SeqNormal, Just value#)

-- -- Simplification is getting out of hand, current setup is n^2 which is....bad.
-- seqTest :: Seq Float
-- seqTest =
--   [x 100 200 <300 x> [400:500]]
--   where
--     x = <30 40 <50 60 70> 80> + 3

-- coolBeat :: Seq Float
-- coolBeat =
--   [
--     x y (y+y) z
--     _ x <5 z> x
--     _ 0 <1 2> y
--   ] * 2
--   where
--     x = <0 5 <1 2> 1>
--     y = 3
--     z = fromInt mouseX * 100

-- properFraction :: (Fractional a, Integral b) -> a -> (b, b)

-- TODO:
-- accumulatePulse :: F64 -> F64 -> F64 -> (#F64, F64#)
-- accumulatePulse width freq acc =
--   (#acc3, out#)
--   where
--     acc2 = fma freq recipSampleRate acc
--     acc3 = acc2 - fastFloor acc2
--     out  = fma (fromInt (boolToInt (acc3 > width))) 2.0 (-1.0)
--
-- pulse :: AudioFormat f => Audio f -> Audio f
-- pulse freq = accumulateAudio2 accumulatePulse freq

-- Sound ideas
--     * Percussive simulations
--     * Strange attractors in FFT?
--     * Cool FFT effects we used: Convolution with voices, Long time stretching

-- TODO: mod (%) function

-- TODO: Write to log file, perhaps class Log a similar to class Print a
-- TODO: endAfterTick IO combinator: endAfterTick :: *World -> *World
-- TODO: Some complex number support
-- TODO: Heterogenous data structures?
-- TODO: No attribute propagation in type signatures?
-- TODO: Immutable and Mutable (Unique) FFT API
-- TODO: FFT generated signals, pure FFT
-- TODO: Writing audio files
-- TODO: Nested case literals seem broken!

-- TODO: Concept of Constant Values somehow being worked into the type system for things like default and mutRef
-- TODO: Inline compose operators! .> and <.
-- TODO: Perhaps function caching is getting off, need more accurate check for HOF caching!
-- TODO: Replace Default with Monoid?
-- TODO: Need partial recursive values to get rid of monoid here
-- TODO: Partially recursive values
-- TODO: Use List type syntax for Sequences?
-- TODO: Partially recursive values
-- TODO: Defunctionalization of function on data structures
-- TODO: Stateful Pattern assignment
-- TODO: 64-bit issue Chad was having

