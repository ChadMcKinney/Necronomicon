coolPattern :: Event Audio
coolPattern = pattern times values
    where
        times  = seq [0.25, 0.5, 0.25]
        values = seq [countUp, mouseX |> take 1, countDown]

mouseX    = {0, 100, 200..N*100}
countUp   = {1,2}
countDown = { -1, -2 }

-- Embed coeffects DIRECTLY into language, akin to two ways of approaching monads,
-- as presented by Moggi and coeffects thesis

-- coolPattern used in context 1:
stream time = { 0, 1, 2,    3,  4, 5, 6,   7,  8,  9 }
item  time  = { 0, 1, 0,    0,  1, 0, 1,   0,  0,  1 }
globaltime  = { 0, 1, 2,    3,  4, 5, 6,   7,  8,  9 }
values      = { 1, 2, 200, -1, -2, 1, 2, 700, -1, -2 }

-- coolPattern used in context 2:
stream  time = { 0, 1, 2,    3,  4,  5,  6,    7,  8,  9 }
item  time   = { 0, 1, 0,    0,  1,  0,  1,    0,  0,  1 }
global time  = { 5, 6, 7,    8,  9, 10, 11,   12, 13, 14 }
values       = { 1, 2, 700, -1, -2,  1,  2, 1200, -1, -2 }

-- Cool, semantically that works, but how does this affect
-- reuse and variable binding?
-- Values are now associated with a context comprised of TWO time streams: static time and dynamic time
-- Static time is the time of the scope where the was value declared.
-- Dynamic time is the time of the scope where the value is being used.
-- Thus when a value is constructed it is can be stored as such:
-- coolPattern 1: [(0, 0), (1, 1), (2, 2)]
-- coolPattern 2: [(0, 5), (1, 6), (2, 7)]
-- The semantics are still pure as multiple accesses to the same stream within the same context
-- always provide the same result

-- Ok, but does that work with feedback:
countUp    = {1,2}
countDown  = {9,8}
mouseX     = {0, 100, 200..N*100}

feedBack    = seq [countUp, countDown, feedBack]
stream time = {0, 1, 2, 3, 4, 5}
item time   = {0, 1, 0, 1, 0, 1}
global time = {0, 1, 2, 3, 4, 5}
values      = {1, 2, 9, 8, 1, 2}

feedBack2   = seq [countUp, countDown, feedBack]
stream time = {0, 1, 2, 3, 4, 5}
item time   = {0, 1, 0, 1, 0, 1}
global time = {5, 6, 7, 8, 9, 10}
values      = {1, 2, 9, 8, 1, 2}

feedBack3   = seq [countUp, mouseX |> take 1, countDown, feedBack]
stream time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
item time   = {0, 1,   0, 0, 1, 0, 1,   2, 3, 4}
global time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
values      = {1, 2, 200, 9, 8, 1, 2, 200, 9, 8}

noFeedback  = seq [countUp, mouseX |> take 1, countDown]
stream time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
item time   = {0, 1,   0, 0, 1, 0, 1,   2, 3, 4}
global time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
values      = {1, 2, 200, 9, 8, 1, 2, 200, 9, 8}

-- New idea:
-- Use Monad to enforce current value, everything else is a pure lazy stream.
-- No need for keeping track of "Contexts" or clocks
-- Needs garbage collection, but naturally handles feed back, cycles, and "current" values
-- Prevents top level "current" computations
-- Resolves ambiguity of "current" value times (value is from the time at which it was bound)
-- Enforces purity (the current value is bound to a single value which can be shared).
-- Don't need to record entire history of inputs
-- Feeback can still cause large thunk chains, but I think this is fine and akin to needing to understand that foldr can blow up on infinite lists
-- Need to check against global time of cached value in thunk?!?!?!!?

current :: CurrentMonad m => a -> m a

semantics then become:
data Stream a = Stream  (Maybe a) (Stream a) --value, next
              | End
              | Constant a


-- | Current IORef a

feedBack3   = seq [countUp, mouseX |> take 1, countDown, feedBack]
noFeedback  = seq [countUp, mouseX |> take 1, countDown]

countDownBase = Stream 9 (Stream 8 End)

next :: Stream a -> (a, Stream a)
next = undefined

mkSequence :: Array (Stream a) -> Stream a
mkSequence streams = sequence 0 streams (Array.empty (Array.size streams))
    where
        sequence index streams newStreams =

take :: Stream a -> Stream Int -> Stream a
take stream numStream = go stream ystream 0
    where
         go (Stream streamVal streamCont) (Stream numVal numCont) count = if count >= numVal
            then Stream Nothing          (go streamCont numCont 0)
            else Stream (Just streamVal) (go streamCont numCont (count + 1))

countUp   = Stream (Just 1) (Stream (Just 2) End))
countDown = Stream (Just 9) (Stream (Just 8) End))
feedBack3 =

data StreamIO a = StreamIO (World -> (a, StreamIO (), World))

instance Monad StreamIO where
    x >>= f = StreamIO $ \world -> case demand x of
        (xVal, xCont) -> case f xVal of
            StreamIO ff -> case ff world of
                (gVal, gCont, world2) -> (gVal, xCont >> gCont, world2)

current :: Stream a -> StreamIO (Stream a)
current (Stream val cont) = StreamIO $ \world ->
    case mkCurrentRef val world of
        (ref, world2) -> let refStream     = Stream (Just (unsafeRead ref)) stream
                             refCont cont' = StreamIO (\world3 -> let (contVal, contCont) = demand cont' in let world4 = writeCurrentRef contVal in ((), refCont' contCont, world4))
                         in  StreamIO (refStream, refCont, world2)

-- Non-Strict, No Circular References, is it possible:
feedback = seq [0, 1 + feedback]

values   = {0, 1, 2, 3}
refs     = {[ref 0, ref 1 + ref feedback[0]]}

feedback[0] = Sequence ()


main :: IO ()
main = do
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 synths

-- Comonadic semantics for effects idea:
-- Comonadic do idea
-- Extraction is a safe opeartion in the main Necro Language
current :: a -> {a}

-- Injection is an unsafe operation in the main Necro language
-- constant :: {a} -> a -- UNSAFE!!!

rand :: Num a => a -> a -> {a}

(=>>) :: a -> (a -> {b}) -> b
mapC :: (a -> {b}) -> [a] -> {[b]}

sin 440 =>> current
sin 440 =>> simpleRand

main :: {()}
main = do
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 synths

randSynth :: Audio -> Audio -> {Audio}
randSynth low high = do
    r1 <- rand low high
    r2 <- rand low high
    r1 + r2 |> current

-equivalant to-

randSynth :: Audio -> Audio -> {Audio}
randSynth low' high' = current
    (low'         =>> \low  ->
    high'         =>> \high ->
    rand low high =>> \r1   ->
    rand low high =>> \r2   ->
    current (r1 + r2))

current :: Stream a -> a
current (Stream aVal aCont) = aVal

rand :: Stream Audio -> Stream Audio -> Audio
rand (Stream lowVal _ lowState) (Stream highVal _ highState) = genRandWithSeed (mergeRand lowState highState + 1)

instance Comonad Stream where
    current (Stream aVal _ _) = aVal
    stream =>> f = Stream (f stream) (cont stream =>> f)

-- Need State parameter for things like rand to get threaded through...how?