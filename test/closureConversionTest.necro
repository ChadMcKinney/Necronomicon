-- data Both a b = Both a b
-- data List a   = Cons a (List a) | Nil
--
-- main :: Int
-- -- main = bombGoesBoom (FBomb addOne)
-- -- main = polyBoom (FBomb addOne) 665
-- main = doit countList coolList
--
-- countList :: List a -> Int
-- countList xs =
--     case xs of
--         Cons _ xs' -> 1 + countList xs'
--         Nil        -> 0
-- coolList :: List ()
-- coolList = Cons () (Cons () Nil)
--
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
--
-- addOne :: Int -> Int
-- addOne x = x + 1
--
-- addOne' :: Int -> Int
-- addOne' = addOne
--
-- useAddOne' :: Int
-- useAddOne' = addOne' 666
--
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
--
-- addTwo' :: Int -> Int -> Int
-- addTwo' x = addTwo x
--
-- addTwo'' :: Int -> Int -> Int
-- addTwo'' = addTwo
--
-- useAddTwo' :: Int -> Int -> Int
-- useAddTwo' = addTwo'
--
-- useAddTwo'2 :: Int
-- useAddTwo'2 = addTwo' 100 200
--
-- useUseAddTwo' :: Int
-- useUseAddTwo' = useAddTwo' 100 200
--
-- useAddTwo'' :: Int
-- useAddTwo'' = addTwo'' 33 44
--
-- addThree :: Int -> Int -> Int -> Int
-- addThree x y z = x + y + z
--
-- useAddThree :: Int -> Int -> Int -> Int
-- useAddThree = addThree
--
-- useAddThree' :: Int -> Int -> Int -> Int
-- useAddThree' x = addThree x
--
-- useAddThree'' :: Int -> Int -> Int
-- useAddThree'' x = addThree x 100
--
-- data FBomb a = FBomb a
-- -- -- data FBomb = FBomb (Int -> Int)
--
-- setTheBomb :: FBomb (Int -> Int)
-- setTheBomb = FBomb (addTwo 1)
--
-- bombGoesBoom :: FBomb (Int -> Int) -> Int
-- bombGoesBoom f =
--     case f of
--         FBomb b -> b 1
--
-- doubleBoom :: FBomb ((Int -> Int) -> Int -> Int) -> Int -> Int
-- doubleBoom f =
--     case f of
--         FBomb b -> b addOne
--
-- -- TODO: proper type class dictionary handling
-- -- polyBoom :: Num a => FBomb (a -> a) -> a -> a
-- polyBoom :: FBomb (a -> a) -> a -> a
-- polyBoom f x =
--     case f of
--         FBomb b -> b x
--
-- plentyOfArgs :: Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> ()
-- plentyOfArgs a b c d e f g h i j k l = ()
--
-- plentyOfCurries :: Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> ()
-- plentyOfCurries = plentyOfArgs
--
-- plentyOfCurries' :: Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> ()
-- plentyOfCurries' = plentyOfArgs 0
--
-- plentyOfApplies :: ()
-- plentyOfApplies = plentyOfCurries 0 1.0 2 3.0 4 5.0 6 7.0 8 9.0 10 11.0
--
-- plentyOfApplies' :: ()
-- plentyOfApplies' = plentyOfCurries' 1.0 2 3.0 4 5.0 6 7.0 8 9.0 10 11.0
--
-- curriedJustice :: Int -> Both Float Int
-- curriedJustice = Both 9.9
--
-- pointwiseJustice :: Both Float Int
-- pointwiseJustice = curriedJustice (getMouseX world)
--
-- constantJustice :: Both (Both Float Int) (Both Float Int)
-- constantJustice = Both (curriedJustice 10) (curriedJustice 10)
--
-- -- TODO: Prim operators need to be compiled into NecroMachine AST
-- -- pipesPlease :: Int -> Int
-- -- pipesPlease x = x |> addOne
-- --
-- -- pipesPlease2 :: Int -> Int
-- -- pipesPlease2 x = x |> addTwo 1
--
-- payloadOnly :: ((Int -> Int) -> Int -> Int) -> Int -> Int
-- payloadOnly f = f addOne

-- -- TODO: Correct arity with type classes!
-- -- addTwo :: Int -> Int -> Int
-- -- addTwo = (+)

-- -- TODO: Handle statefulness correctly
-- -- TODO: Handle GC correctly
-- main :: Int
-- main = nestedF addSome
-- addSome :: Int -> Int
-- addSome x = x + 100
-- nestedF :: (Int -> Int) -> Int
-- nestedF f = nestedF' f + nestedF' f
-- nestedF' :: (Int -> Int) -> Int
-- nestedF' f = feed where
--     feed ~ 0 = f feed

-- TODO: map like recursive function test

-- -----------------------------------------
-- -- Under saturated test
-- -----------------------------------------
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (doit addTwo 10) 100

-- -----------------------------------------
-- -- Saturated test
-- -----------------------------------------
-- addThree :: Int -> Int -> Int -> Int
-- addThree x y z = x + y * z
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (addThree 100 200) 300

-- -----------------------------------------
-- -- Over saturated test
-- -----------------------------------------
-- data FBomb a = FBomb a
-- bombsAway :: FBomb (() -> FBomb (Int -> Int -> Int)) -> Int -> Int -> Int
-- bombsAway fb1 =
--     case fb1 of
--         FBomb fb2 ->
--             case fb2 () of
--                 FBomb fb -> fb
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- thunkBomb :: () -> FBomb (Int -> Int -> Int)
-- thunkBomb u = FBomb addTwo
-- main :: Int
-- main = bombsAway (FBomb thunkBomb) 2 10

-- -----------------------------------------
-- -- Pointwise Test
-- -----------------------------------------
-- data FBomb a = FBomb a
-- counter :: Int
-- counter ~ 0 = counter + 1
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- app :: (a -> b) -> a -> b
-- app f x = f x
-- theBomb :: FBomb (Int -> Int)
-- theBomb = FBomb (addTwo counter)
-- main :: Int
-- main =
--     case theBomb of
--         FBomb f -> f 1000000

-----------------------------------------
-- Map, fold, sum Test
-----------------------------------------
data List a = Cons a (List a) | Nil
fmap :: (a -> b) -> List a -> List b
fmap f xs =
    case xs of
        Nil        -> Nil
        Cons x xs' -> Cons (f x) (fmap f xs')
foldl :: (b -> a -> b) -> b -> List a -> b
foldl f accu xs =
    case xs of
        Nil        -> accu
        Cons x xs' -> foldl f (f accu x) xs'
-- raw 'add' function here isn't correctly being turned into a closure during cc!
-- without the xs this SHOULD become a stateful closure, but right now stateful closures aren't supported
sum :: List Int -> Int
sum xs = foldl addTwo 0 xs
coolList :: List ()
coolList = Cons () (Cons () (Cons () (Cons () Nil)))
counter :: Int
counter ~ 0 = counter + 1
transmogrify :: a -> Int
transmogrify x = 1000000 + counter
addTwo :: Int -> Int -> Int
addTwo x y = x + y
intList :: List Int
intList = fmap transmogrify coolList
main :: Int
main = sum intList

-- -----------------------------------------
-- -- Many Closure Calculations test
-- -----------------------------------------
-- -- It's...complicated
-- addSome :: Int -> Int
-- addSome x = x + 1
-- addSomeMore :: Int -> Int -> Int
-- addSomeMore x y = x + y
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- integrate :: (Int -> Int) -> Int
-- integrate f = feed where
--     feed ~ 0 = doit (addSomeMore 6) feed
-- tenTimes :: (Int -> Int) -> Int
-- tenTimes n =
--     integrate n + integrate n + integrate n + integrate n + integrate n +
--     integrate n + integrate n + integrate n + integrate n + integrate n
-- oneHundredTimes :: (Int -> Int) -> Int
-- oneHundredTimes n =
--     tenTimes n + tenTimes n + tenTimes n + tenTimes n + tenTimes n +
--     tenTimes n + tenTimes n + tenTimes n + tenTimes n + tenTimes n
-- oneThousandTimes :: (Int -> Int) -> Int
-- oneThousandTimes n =
--     oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n +
--     oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n
-- tenThousandTimes :: (Int -> Int) -> Int
-- tenThousandTimes n =
--     oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n +
--     oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n
-- oneHundredThousandTimes :: (Int -> Int) -> Int
-- oneHundredThousandTimes n =
--     tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n +
--     tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n
-- oneMillionTimes :: (Int -> Int) -> Int
-- oneMillionTimes f =
--     oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f +
--     oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f
-- main :: Int
-- main = oneHundredThousandTimes addSome

