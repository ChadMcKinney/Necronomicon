-- -----------------------------------------
-- -- Under saturated test: 2000
-- -----------------------------------------
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (doit addTwo 1000) 1000

-- -----------------------------------------
-- -- Under saturated Pointwise test: 2000 + mouseX
-- -----------------------------------------
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y + getMouseX world
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (doit addTwo 1000) 1000

-- -----------------------------------------
-- -- Under saturated Stateful test: 2000 + counter
-- -----------------------------------------
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y + (let c ~ 0 = c + 1 in c)
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (doit addTwo 1000) 1000

-- -----------------------------------------
-- -- Saturated test: 600
-- -----------------------------------------
-- addThree :: Int -> Int -> Int -> Int
-- addThree x y z = x + y + z
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (addThree 100 200) 300

-- -----------------------------------------
-- -- Saturated test: 600 + mouseX
-- -----------------------------------------
-- addThree :: Int -> Int -> Int -> Int
-- addThree x y z = x + y + z + getMouseX world
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (addThree 100 200) 300

-- -----------------------------------------
-- -- Saturated test: 600 + counter
-- -----------------------------------------
-- addThree :: Int -> Int -> Int -> Int
-- addThree x y z = x + y + z + (let c ~ 0 = c + 1 in c)
-- doit :: (a -> b) -> a -> b
-- doit f x = f x
-- main :: Int
-- main = doit (addThree 100 200) 300

-- -----------------------------------------
-- -- Over saturated test: 1100
-- -----------------------------------------
-- giveMeClosure :: () -> Int -> Int
-- giveMeClosure u = add 100
-- nestedClosure :: () -> Int -> Int
-- nestedClosure = giveMeClosure
-- main :: Int
-- main = nestedClosure () 1000

-- -----------------------------------------
-- -- Over saturated test: 1000 + mouseX
-- -----------------------------------------
-- giveMeClosure :: () -> Int -> Int
-- giveMeClosure u = add (getMouseX world)
-- nestedClosure :: () -> Int -> Int
-- nestedClosure = giveMeClosure
-- main :: Int
-- main = nestedClosure () 1000

-- -----------------------------------------
-- -- Over saturated test: 1000 + counter
-- -----------------------------------------
-- giveMeClosure :: () -> Int -> Int
-- giveMeClosure u = add (let c ~ 0 = c + 1 in c)
-- nestedClosure :: () -> Int -> Int
-- nestedClosure = giveMeClosure
-- main :: Int
-- main = nestedClosure () 1000

-- -----------------------------------------
-- -- Data member test: 1002
-- -----------------------------------------
-- data FBomb a = FBomb a
-- bombsAway :: FBomb (() -> FBomb (Int -> Int -> Int)) -> Int -> Int -> Int
-- bombsAway fb1 =
--     case fb1 of
--         FBomb fb2 ->
--             case fb2 () of
--                 FBomb fb -> fb
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- thunkBomb :: () -> FBomb (Int -> Int -> Int)
-- thunkBomb u = FBomb addTwo
-- main :: Int
-- main = bombsAway (FBomb thunkBomb) 2 1000

-- -----------------------------------------
-- -- Data member Pointwise test: 1000 + mouseX
-- -----------------------------------------
-- data FBomb a = FBomb a
-- bombsAway :: FBomb (() -> FBomb (Int -> Int)) -> Int -> Int
-- bombsAway fb1 =
--     case fb1 of
--         FBomb fb2 ->
--             case fb2 () of
--                 FBomb fb -> fb
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- thunkBomb :: () -> FBomb (Int -> Int)
-- thunkBomb u = FBomb (add (getMouseX world))
-- main :: Int
-- main = bombsAway (FBomb thunkBomb) 1000

-- -----------------------------------------
-- -- Data member Stateful test: 1000 + counter
-- -----------------------------------------
-- data FBomb a = FBomb a
-- bombsAway :: FBomb (() -> FBomb (Int -> Int)) -> Int -> Int
-- bombsAway fb1 =
--     case fb1 of
--         FBomb fb2 ->
--             case fb2 () of
--                 FBomb fb -> fb
-- addTwo :: Int -> Int -> Int
-- addTwo x y = x + y
-- thunkBomb :: () -> FBomb (Int -> Int)
-- thunkBomb u = FBomb (add (let c ~ 0 = c + 1 in c))
-- main :: Int
-- main = bombsAway (FBomb thunkBomb) 1000

-- -----------------------------------------
-- -- Switch Constant Constant Test
-- -----------------------------------------
-- mouseF :: Int -> Int
-- mouseF =
--   if getMouseX world > 80
--     then add 10
--     else add 1000
-- main :: Int
-- main = mouseF 2

-- -----------------------------------------
-- -- Switch Stateful Constant Test
-- -----------------------------------------
-- addS :: Int -> Int
-- addS x = x + c where c ~ 0 = c + 1
-- mouseF :: Int -> Int
-- mouseF =
--   if getMouseX world > 80
--     then addS
--     else add 1000
-- main :: Int
-- main = mouseF 2

-----------------------------------------
-- Switch Stateful Stateful Test
-----------------------------------------
addS :: Int -> Int
addS x = x + c where c ~ 0 = c + 1
addT :: Int -> Int
addT x = x + c where c ~ 0 = c + 2
mouseF :: Int -> Int
mouseF =
  if getMouseX world > 80
    then addS
    else addT
main :: Int
main = mouseF 2

-- -----------------------------------------
-- --Map, fold, sum Test
-- -----------------------------------------
-- data List a
--   = Cons a (List a)
--   | Nil
--
-- fmap :: (a -> b) -> List a -> List b
-- fmap f xs =
--   case xs of
--     Nil ->
--       Nil
--
--     Cons x xs' ->
--       Cons (f x) (fmap f xs')
--
-- foldl :: (b -> a -> b) -> b -> List a -> b
-- foldl f accu xs =
--   case xs of
--     Nil ->
--       accu
--
--     Cons x xs' ->
--       foldl f (f accu x) xs'
--
-- foldr :: (a -> b -> b) -> b -> List a -> b
-- foldr f accu xs =
--   case xs of
--     Nil ->
--       accu
--
--     Cons x xs' ->
--       f x (foldr f accu xs')
--
-- -- raw 'add' function here isn't correctly being turned into a closure during cc!
-- -- without the xs this SHOULD become a stateful closure, but right now stateful closures aren't supported
-- sum :: List Int -> Int
-- sum xs =
--   foldl addTwo 0 xs
--
-- coolList :: List ()
-- coolList =
--   Cons () (Cons () (Cons () (Cons () Nil)))
--
-- counter :: Int
-- counter ~ 0 =
--   counter + 1
--
-- transmogrify :: a -> Int
-- transmogrify x =
--   1000000 + counter
--
-- addTwo :: Int -> Int -> Int
-- addTwo x y =
--   x + y
--
-- main :: Int
-- main =
--   -- sum (fmap transmogrify coolList)
--   foldl addTwo 0 (fmap transmogrify coolList)

-- -----------------------------------------
-- -- Many Closure Calculations test
-- -----------------------------------------
-- -- 100,000 stateful closure allocations and applications: 21% cpu, 2.3ms GC (approx  3x slower than non-stateful)
-- -- 100,000 stateful closure applications:                 15% cpu,          (approx 10x slower than non-stateful)
-- -- 100,000 closure allocations and applications:           8% cpu,
-- -- 100,000 closure applications:                         0.1% cpu,
-- -- 100,000 reg function applications:                    0.1% cpu,
-- addSome :: Int -> Int
-- addSome x =
--   x + 1
-- addSomeMore :: Int -> Int -> Int
-- addSomeMore x y =
--   x + y
-- doit :: (a -> b) -> a -> b
-- doit f x =
--   f x
-- integrate :: (Int -> Int) -> Int
-- integrate f =
--   feed where
--     feed ~ 0 = doit (addSomeMore 6) feed
--     -- feed ~ 0 = f feed
-- tenTimes :: (Int -> Int) -> Int
-- tenTimes n =
--   integrate n + integrate n + integrate n + integrate n + integrate n +
--   integrate n + integrate n + integrate n + integrate n + integrate n
-- oneHundredTimes :: (Int -> Int) -> Int
-- oneHundredTimes n =
--   tenTimes n + tenTimes n + tenTimes n + tenTimes n + tenTimes n +
--   tenTimes n + tenTimes n + tenTimes n + tenTimes n + tenTimes n
-- oneThousandTimes :: (Int -> Int) -> Int
-- oneThousandTimes n =
--   oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n +
--   oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n + oneHundredTimes n
-- tenThousandTimes :: (Int -> Int) -> Int
-- tenThousandTimes n =
--   oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n +
--   oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n + oneThousandTimes n
-- oneHundredThousandTimes :: (Int -> Int) -> Int
-- oneHundredThousandTimes n =
--   tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n +
--   tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n + tenThousandTimes n
-- oneMillionTimes :: (Int -> Int) -> Int
-- oneMillionTimes f =
--   oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f +
--   oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f + oneHundredThousandTimes f
-- main :: Int
-- main = let f = addSome in
--   oneHundredThousandTimes f

----------------------
-- Random TODO
----------------------
-- -- TODO: proper type class dictionary handling
-- -- polyBoom :: Num a => FBomb (a -> a) -> a -> a
-- polyBoom :: FBomb (a -> a) -> a -> a
-- polyBoom f x =
--     case f of
--         FBomb b -> b x
-- -- TODO: Prim operators need to be compiled into NecroMachine AST
-- -- pipesPlease :: Int -> Int
-- -- pipesPlease x = x |> addOne
-- -- TODO: Correct arity with type classes!

