data Both a b = Both a b

main :: Int
main = 0

addOne :: Int -> Int
addOne x = x + x

addOne' :: Int -> Int
addOne' = addOne

useAddOne' :: Int
useAddOne' = addOne' 666

addTwo :: Int -> Int -> Int
addTwo x y = x + y

addTwo' :: Int -> Int -> Int
addTwo' x = addTwo x

addTwo'' :: Int -> Int -> Int
addTwo'' = addTwo

useAddTwo' :: Int -> Int -> Int
useAddTwo' = addTwo'

useAddTwo'2 :: Int
useAddTwo'2 = addTwo' 100 200

useUseAddTwo' :: Int
useUseAddTwo' = useAddTwo' 100 200

useAddTwo'' :: Int
useAddTwo'' = addTwo'' 33 44

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

useAddThree :: Int -> Int -> Int -> Int
useAddThree = addThree

useAddThree' :: Int -> Int -> Int -> Int
useAddThree' x = addThree x

useAddThree'' :: Int -> Int -> Int -> Int
useAddThree'' x y = addThree x y

data FBomb a = FBomb a
-- data FBomb = FBomb (Int -> Int)

setTheBomb :: FBomb (Int -> Int)
setTheBomb = FBomb (addTwo 1)

bombGoesBoom :: FBomb (Int -> Int) -> Int
bombGoesBoom f =
    case f of
        FBomb b -> b 1

doubleBoom :: FBomb ((Int -> Int) -> Int -> Int) -> Int -> Int
doubleBoom f =
    case f of
        FBomb b -> b addOne

polyBoom :: Num a => FBomb (a -> a) -> a -> a
polyBoom f x =
    case f of
        FBomb b -> b x

plentyOfArgs :: Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> ()
plentyOfArgs a b c d e f g h i j k l = ()

plentyOfCurries :: Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> ()
plentyOfCurries = plentyOfArgs

plentyOfCurries' :: Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> Int -> Float -> ()
plentyOfCurries' = plentyOfArgs 0

plentyOfApplies :: ()
plentyOfApplies = plentyOfCurries 0 1.0 2 3.0 4 5.0 6 7.0 8 9.0 10 11.0

plentyOfApplies' :: ()
plentyOfApplies' = plentyOfCurries' 1.0 2 3.0 4 5.0 6 7.0 8 9.0 10 11.0

curriedJustice :: Int -> Both Float Int
curriedJustice = Both 9.9

pointwiseJustice :: Both Float Int
pointwiseJustice = curriedJustice (getMouseX world)

constantJustice :: Both (Both Float Int) (Both Float Int)
constantJustice = Both (curriedJustice 10) (curriedJustice 10)

-- -- pipesPlease :: Int -> Int
-- -- pipesPlease x = x |> addOne
-- --
-- -- pipesPlease2 :: Int -> Int
-- -- pipesPlease2 x = x |> addTwo 1
--
-- -- payloadOnly :: ((Int -> Int) -> Int -> Int) -> Int -> Int
-- -- payloadOnly f = f addOne
-- --
-- -- -- TODO: Correct arity with type classes!
-- -- -- addTwo :: Int -> Int -> Int
-- -- -- addTwo = (+)
-- --
-- -- -- Closure info table:
-- -- -- { farity, num_pargs }
-- -- -- farity:    function arity
-- -- -- num_pargs: number of partially applied args
-- -- -- (implied)
-- -- -- carity:    closure arity
-- --
-- -- -- TODO: check how recursion affects things
