-- -- TODO: Mututally recursive bindings are not functioning in core!?!?
-- mutualRec :: Int
-- mutualRec = death where
--     death = toAll + 1
--     toAll = death + 1

-- -- TODO: Nested functions don't work in core!?!?!
-- nested :: Int
-- nested = f 0 + f 1 where
--     f x = x + 2

-- -- TODO: Support anonymous functions!
-- lambdaTest :: Int
-- lambdaTest = (\x -> x) 1

-- funTest :: Int -> Int
-- funTest x = x + y where
--     y = 2 * 3

-- funTest2 :: Int -> Int -> Int
-- funTest2 x y = x + y + z + w where
--     z = 4
--     w = z + x + y
--
-- -- TODO: App Temps
-- -- TODO: Stateless optimization...how!?
-- -- Only need app temp if:
-- --     * The function applied carries state or
-- --     * The function or one of its members carries state
-- --     * The function is arrived at indirectly through a branch or modulating variable of somesort
-- --     * The function returns another function
-- appTest :: Nullary
-- appTest = id (id (id Nullary))
--
-- -- TODO: App type to LLVM type
-- id :: a -> a
-- id x = x

-- TODO: Finish!
data Nullary = Nullary
doubleID :: a -> b -> a
doubleID x y = x

doubleTest :: Int
doubleTest = doubleID 0 Nullary

-- numTest :: Num a => a -> a -> a
-- numTest x y = x + y

-- data Doom a = Doom a Int
-- appliedDoom :: () -> Int -> Doom ()
-- appliedDoom x i = Doom x i

-- selfRec :: Int
-- selfRec = y + selfRec where
--     y = 3

-- deadSimple :: Int
-- deadSimple = onlyOne where
--     onlyOne = 1

-- soManyInsaneBinds :: Int
-- soManyInsaneBinds = a * x + y - soManyInsaneBinds where
--     a = 33
--     x = z + w where
--         z = 4 + w
--         w = 3
--     y = u + v + x where
--         u = 5
--         v = 6 + a

-- -- TODO: TEMP NODES!!!!!
-- data Doom a = Doom a Int
-- doomsday :: Doom (Doom Int)
-- doomsday = Doom (Doom left right) 0 where
--     left  = 1
--     right = 2

-- -- TODO: TEMP NODES!!!!!
-- -- If all owned nodes are cached at the very top level node
-- -- Then it is simple to capture variables, even for functions!?
-- doomsday :: Int
-- doomsday = x + y + z + doomsday where
--     x = 1 + 3
--     y = 2 + x + w where w = 4
--     z = 3 + y

-- anotherFloat :: Float
-- anotherFloat = l + r / 3 where
--     l = 4
--     r = 5

-- -- Init function needs to be passed all captured variable node
-- -- AND all captured variable node for each owned node
-- -- If we inline all owned node instances perhaps we can obviate the need for captured variables in values (but not functions)
-- twoLevelsDown :: Int
-- twoLevelsDown = levelOne where
--     levelOne = levelTwo where
--         levelTwo = levelThree where
--             levelThree = levelOne + levelTwo

-- floatTest :: Float
-- floatTest = 4.321
--
-- rationalTest :: Rational
-- rationalTest = 987654321
--
-- audioTest :: Audio
-- audioTest = 987654321
--
-- unitTest :: ()
-- unitTest = ()
--
-- data Nullary = Nullary
--
-- nullaryTest :: Nullary
-- nullaryTest = Nullary
--
-- data ThereCanBeOnlyOne = ThereCanBeOnlyOne Int
--
-- thereCanBeOnlyOneTest :: ThereCanBeOnlyOne
-- thereCanBeOnlyOneTest = ThereCanBeOnlyOne 0
--
-- data CakeOrDeath = Cake Int | Death () Float
--
-- cake :: CakeOrDeath
-- cake = Cake 0
--
-- death :: CakeOrDeath
-- death = Death () 3.3
--
-- data Polymorph a = Polymorph a a | Newt
--
-- polymorph :: Polymorph Int
-- polymorph = Polymorph 0 0
--
-- newt :: Polymorph Int
-- newt = Newt
--
-- testUntilYouDie :: Polymorph ()
-- testUntilYouDie = x where x = Newt
--
-- data Lopsided = Light () | Heavy Int Int Int Int Int | Empty
--
-- lopsidedTest :: Lopsided
-- lopsidedTest = Light ()
--
