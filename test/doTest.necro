-- data Maybe  a   = Just a | Nothing
--
-- data Either a b = Left a | Right b
-- data Higher f a = Higher (f a)
-- data HigherM a  = HigherM (Higher Maybe a)
-- data SuperH f g x = SuperH (f g (g x))
--
-- -- Type checks with or without type signature
-- -- super :: (Maybe Int -> f Maybe (Maybe Int)) -> SuperH f Maybe Int
-- super f = SuperH (f (Just 10))
--
-- higher :: Maybe Int -> Higher Maybe (Maybe Int)
-- higher x = Higher (Just x)
--
-- data ListFunctor f a = Nil | Cons a (f a)
--
-- -- maybeList0 :: ListFunctor Int Int -- This should NOT type check!
-- -- maybeList0 = Nil
--
-- maybeList1 :: ListFunctor (ListFunctor (ListFunctor Maybe)) Int -- this should typecheck!
-- maybeList1 = Cons 1 (Cons 0 Nil)
--
-- maybeList2 :: ListFunctor Maybe Int
-- maybeList2 = Nil
--
-- hTest :: f a -> f a
-- hTest x = x
--
-- ht1 = hTest (Just 10)
-- ht2 = hTest (Right True)
--
-- -- Phantom based subtyping
-- data Phantom a = Phantom
-- data P2      a = P2
-- data P3      a = P3
--
-- as :: a -> a -> a
-- as _ y = y
--
-- top :: Phantom a
-- top = Phantom
--
-- sub1 :: Phantom (P2 a)
-- sub1 = as top Phantom
--
-- sub2 :: Phantom (P3 a)
-- sub2 = as top Phantom
--
-- data MutA a    = MutA (MutB a)
-- data MutB b    = MutB (MutA b)
--
-- data Yep    a   = Yep (Maybe a) (Yep a) (Either a ())
-- data FU     a b = FU (a -> b)
--
-- class MyCoolClass a where
--     coolMethod :: a -> [a]
--
-- class MyCoolClass a => SubCoolClass a
--
-- aCoolTest x = coolMethod x
--
-- -- DONE:
-- -- * Proper dependency analysis for declarations
-- -- * Accumulated constraints FIXED
-- -- * Fixed strange do statement bug in maybeTest
-- -- * Fixed type class instance bugs
--
-- -- TODO:
-- -- * Monomorphism restriction
-- -- * Defaulting occurs after the entire thing has been type checked
-- -- * Followed by type class translation
-- -- * Ambiguous Type classes check
-- -- * Attach types to every single AST node???
-- -- * Constructor constraints...
-- -- * Type class constraints on functions...
-- -- * Proper kind inference system...likely requires dependency analysis for data types
--
-- class NoMethods a
--
-- instance Eq a => Eq (Maybe a) where
--     eq  (Just x) (Just y) = x == y
--     eq  Nothing  Nothing  = True
--     eq  _        _        = False
--     neq x        y        = not (eq x y)
--
-- not :: Bool -> Bool
-- not True  = False
-- not False = True
--
-- instance Functor Maybe where
--     map f (Just x) = Just (f x)
--
-- instance Applicative Maybe where
--     pure x               = Just x
--     ap (Just f) (Just x) = Just (f x)
--     ap _        _        = Nothing
--
-- instance Monad Maybe where
--     bind (Just x) f = f x
--     bind Nothing  _ = Nothing
--
-- -- Test let in here!
-- maybeTest :: Audio -> Maybe Audio
-- maybeTest z = do
--     x      <- Just 1
--     y      <- Just (x + z)
--     (u, v) <- Just (0, 1)
--     Nothing
--     Just 2 >>= Just >>= pure >>= \x -> pure (x + 1)
--     Just (2 + u)
--     map (\x -> x) (Just True)
--     x <- map (+1) (Just 0)
--     map (+1) (Just 0)
--     ap (map add (Just 3)) (Just 5)
--     pure (y - v)
--
-- eitherTest z = do
--     pure z
--
-- maybeInt n = ap (map add Nothing) n
-- maybeAdd = map (+1) (Just 4)
--
-- -- Need: &&, ||, <<, =<<, !!
-- numBinOps  x y = x + y - x / 4 * 3
-- eqBinOps1  x y = x == y
-- eqBinOps2  x y = x /= y
-- ltTest     x y = x < y
-- gtTest     x y = x > y
-- lteTest    x y = x <= y
-- gteTest    x y = x >= y
-- bindTest   x y = x >>= y
-- appendTest x y = x <> y
-- fpipeTest  x y = x |> y
-- bpipeTest  x y = x <| y
-- dotTest    x y = x . y
-- thenTest   x y = x >> y
-- consTest (x : y) = x : x : y
--
-- sectionTest1   = (Just 10 >>=)
-- sectionTest2   = (>>= pure)
-- sectionTest3   = (Just 10 >>=) pure
-- sectionTest4   = (>>= pure) (Just 10)
-- sectionTest5   = (|>) (10) (\x -> x)
-- sectionTest6   = (>>=) (Just 10) pure
--
-- -- Dependency analysis testing
-- class Show a where
--     show :: a -> [Char]
--
-- -- Both g1 and g2 properly infer types of forall a. (Ord a, Eq a, Show a) => a -> a -> [Char]
-- f x =
--     let g1 x y = if x > y then show x else g2 y x
--         g2 p q = g1 q p
--     in  g2 x x
--
-- -- Even without type signatures this produces the most general types
-- foo x = foo (bar 0)
-- bar x = x
--
-- -- These can both be used with id without needing type signatures to get the most principal type
-- idTest1 = id (3 == 4)
-- idTest2 = id (4 + 5)
--
-- -- With or without the type signature this will still be inferred with the most general type
-- -- id :: a -> a
-- id x = x
--
-- seqTest x = seq {0, 1, seq {4, 5, 6}, 3 + x}
--
-- caseSeqTest x = case x of
--     0 -> seq {2, 3}
--     _ -> seq {x, 5}
--
-- instantTest = x where
--     x = seq {0, x + 1}
--
-- patSeq = (x, y) where
--     (x, y) = seq {(0, 1), (y, x)}
--
-- listTake :: Int -> [a] -> [a]
-- listTake n xs = go n xs where
--     go 0  _        = []
--     go n (x : xs') = x : go (n - 1) xs'
--
-- -- Creates a sliding window which moves over time
-- -- i.e. potentially infinite data structures ARE useful
-- slidingWindow x = xs where
--     xs = x : seq {[], xs} |> listTake 4
--
-- fix :: (a -> a) -> a
-- fix f = f (fix f)
--

data Maybe a = Just a | Nothing

-- class TestClass a where
--     go :: Num b => a -> b -> a
--     no :: a -> Int -> Int
--
-- instance (Num a, Eq a) => TestClass (Maybe a) where
--     go (Just i) _ = Just (i + 1)
--     go Nothing  _ = Just 0
--     no _ i = i
--
-- testGo  = go Nothing
--
-- data Always a = Always a
--
-- instance TestClass a => TestClass (Always a) where
--     go (Always x) b = Always (go x b)
--     no _ i = i
--
-- alwaysTest = Always (Just 0)
-- goTest = go alwaysTest 1
--
class SupremeClass a where
    supremeMethod :: a -> ()

class SuperClass a where
    superMethod :: a -> Int

class (SuperClass a, SupremeClass a) => SubClass a where
    subMethod :: Int -> a

instance Num a => SuperClass (Maybe a) where
    superMethod (Just _) = 0

instance (Fractional a, Eq a) => SupremeClass (Maybe a) where
    supremeMethod _ = ()

instance (Fractional a, Ord a) => SubClass (Maybe a) where
    subMethod i = subMethod (superMethod (Just (fromInt i)))

instance Functor Maybe where
    map f (Just x) = Just (f x)
    map _ Nothing  = Nothing

instance Applicative Maybe where
    pure                 = Just
    ap (Just f) (Just x) = Just (f x)
    ap _        _        = Nothing

subTest :: Maybe Float
subTest = subMethod 0

subTest2 :: (Fractional a, Ord a) => Int -> Maybe a
subTest2 x = subMethod x

-- subTest3 :: Int -> Maybe Audio
-- subTest3 :: (Fractional a, Ord a) => Int -> Maybe a
subTest3 x = subTest2 x

-- x :: Maybe Audio
x :: (Fractional a, Ord a, Fractional b, Ord b) => (Maybe a, Maybe b)
x = (subMethod 9, subMethod 0)

y = Nothing

-- -- This shouldn't type check!!! Wtf!?!?!
-- Probably related to numeric overloading, need to implement type class translation
-- coolSynth :: Audio -> Audio
-- coolSynth freq = osc (freq * 2) + 1 where
--     osc _ = 220

-- -- simpleTest :: Int
-- simpleTest = notF 0 where
--     notF _ = 1
