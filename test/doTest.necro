data Maybe  a   = Just a | Nothing
data Either a b = Left a | Right b

-- TODO:
-- * Proper dependency analysis for declarations
-- * Higher-kinded type constructor arguments
-- * Monomorphism restriction
-- * Defaulting occurs after the entire thing has been type checked
-- * Followed by type class translation
-- * Ambiguous Type classes check
-- * Fix strange do statement bug in maybeTest
-- * Attach types to every single AST node

-- I believe things like this are failing because of the ordering of type checking
-- The proper fix is a correct dependency analysis....

instance Eq a => Eq (Maybe a) where
    eq  (Just x) (Just y) = x == y
    eq  Nothing  Nothing  = True
    eq  _        _        = False
    neq x y = not (eq x y) -- Fixed this! ordering of type signatures was wrong!

not :: Bool -> Bool
not True  = False
not False = True

instance Functor Maybe where
    map f (Just x) = Just (f x)

instance Applicative Maybe where
    pure x               = Just x
    ap (Just f) (Just x) = Just (f x)
    ap _        _        = Nothing

instance Monad Maybe where
    bind (Just x) f = f x
    bind Nothing  _ = Nothing

maybeTest :: Audio -> Maybe Audio
maybeTest z = do
    x      <- Just 1
    y      <- Just (x + z)
    (u, v) <- Just (0, 1)
    Nothing
    Just 2 >>= Just >>= pure >>= \x -> pure (x + 1)
    Just (2 + u)
    -- TODO: Fix!!!
    -- ap (map add Nothing) Nothing
    pure (y - v)

eitherTest z = do
    pure z

-- Need: &&, ||, <<, =<<, !!
numBinOps  x y = x + y - x / 4 * 3
eqBinOps1  x y = x == y
eqBinOps2  x y = x /= y
ltTest     x y = x < y
gtTest     x y = x > y
lteTest    x y = x <= y
gteTest    x y = x >= y
bindTest   x y = x >>= y
appendTest x y = x <> y
fpipeTest  x y = x |> y
bpipeTest  x y = x <| y
dotTest    x y = x . y
thenTest   x y = x >> y
consTest (x : y) = x : x : y

sectionTest1 = (Just 10 >>=)
sectionTest2 = (>>= pure)
sectionTest3 = (Just 10 >>=) pure
sectionTest4 = (>>= pure) (Just 10)
sectionTest5 = (>>=) (Just 10) pure

class Show a where
    show :: a -> [Char]

-- Both g1 and g2 properly infer types of forall a. (Ord a, Eq a, Show a) => a -> a -> [Char]
f x =
    let g1 x y = if x > y then show x else g2 y x
        g2 p q = g1 q p
    in  g2 x x

data ListFunctor f a = Nil | Cons a (f a) -- List SHOULD have the kind (* -> *) -> * -> *, but right now has the kind * -> * -> *
data Phantom f a = Phantom a              -- Phantom SHOULD have the kind ? -> * -> *, but right now has kind * -> * -> *

maybeList2 :: ListFunctor Int Int -- This should NOT type check!
maybeList2 = Nil

maybeList1 :: ListFunctor (ListFunctor (ListFunctor Maybe)) Int -- this should typecheck!
maybeList1 = Cons 1 (Cons 0 Nil)

phantom1 :: Phantom Int Int --Kind should be flexible
phantom1 = Phantom 10

phantom2 :: Phantom Maybe Int --Kind should be flexible
phantom2 = Phantom 10

-- TODO: To get something like this to work we need constructor constraints!
-- type should be: (Monad m, Num (m a)) => (a -> m b) -> m b
-- But we don't support constraints of the form Num (m a) currently
-- sectionTest0 = (10 >>=)
