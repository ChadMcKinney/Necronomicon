latch :: a -> Event a -> a
latch x _ = x

poly :: Num a => (a -> a) -> Event a -> a
poly _ _ = 0

id :: a -> a
id x = x

speed :: Rational -> Pattern a -> Pattern a
speed _ x = x

-- psample :: a -> Pattern a

-- play :: Pattern a -> Event a
-- play _

-- coolSynth :: Audio
-- coolSynth = poly id <| play patTest

-- TODO: Pattern list/Tuples

-- seq vs pat:
-- seq is a series of patterns, each pattern plays out before moving to the next
-- beat is a series of patterns, where each slot is played for the duration of that beat before moving on to the next
-- par is a series of patterns, where each  slots is playing in parallel and you get the value of that beat at that moment
-- TODO: How to implement?!?!?!
-- Via reification by 'play'
-- play :: Pattern a -> Tempo -> a

-- Wrong semantics
patTest :: Pattern Audio
patTest = beat
    0 z _ x
    _ 3 y z
    where
        x = 0.5 * 2
        y = beat 0 _ 1 _
        z = 666 * 323

-- Using "Demand" types
patTest :: Demand (Pattern Audio)
patTest = beat
    0 z _ x
    _ 3 y z
    where
        x = 0.5 * 2
        y = beat 0 _ 1 _
        z = 666 * 323

-- Using "Call by Name" semantics
patTest :: Pattern Audio
patTest = seq
    0 z _ x
    _ 3 y z
    where
        x = 0.5 * 2
        y ~= seq 0 _ 1 _
        z = 666 * 323

patTest :: Pattern Audio
patTest = do
    x <- 0.5 * 2
    y <- beat 0 _ 1 _
    z <- 666 * 323
    beat 0 z _ x
         _ 3 y z

-- Applicative functor form / syntax with actual sharing between slots
patTest :: Pattern Audio
patTest = beat
    0 z _ x
    _ 3 y z
    demand
        x =  0.5 * 2
        y <- 666 * 323
        z =  beat 0 _ 1 _

patTest :: Pattern Audio
patTest <=
    0 z _ x
    _ 3 y z |
        x <= 0.5 * 2
        y <= 0 _ 1 _
        z <= 666 * 323
        w <= m n o _ p q

-- True lazy via types with pat syntax desugaring
-- lazy types, but where memo chains are broken at frame end to prevent space leaks and incorrect evaluation.
-- Like Idris, lazy and force are implicitly inserted by compiler to make things easier
beatTest :: Music Audio
beatTest =
    beat
        0 z _ x
        _ 3 y z
    where
        x = 0.5 * 2
        y = beat 0 _ 1 _
        z = 666 * 323

poly :: (a -> b) -> Music a -> b
beat :: [Lazy (Music a)] -> Music a

synth :: Audio -> Audio
synth freq = osc
    where
        osc = 440 * mouseX + freq * 0 `fby` osc |> sinOsc

coolBeat :: Music Audio
coolBeat = d2f minor <| beat
    x y (y+y) z
    _ x [5 z] x
    _ 0 [1 2] y
    where
        x = beat 0 _ [1 2] -1
        y = 3
        z = sample mouseX / 100

main :: Audio
main = poly synth coolBeat

desugarBeat :: Pattern Audio
desugarBeat = beat x y x 1 where
    x = beat 1 2 3 4
    y = beat 4 3 2 1

-- -- New idea, simple and naive call-by-name patterns with stateful functions
-- -- Should actually return a vec of values
-- data Pat a
--   = Pat (Time -> PatternState a)
--
-- data PatternState  a
--   = PatternPlaying a
--   | PatternYield
--   | PatternRest
--   | PatternDone
--
-- playPat :: Pat a -> Maybe a
-- playPat p =
--   case p of
--     Pat f ->
--       case f (Just 1) of
--         PatternPlaying x -> Just x
--         PatternYield     -> Nothing
--         PatternRest      -> Nothing
--         PatternDone      -> Nothing
--
-- data Maybe a = Just a | Nothing
--
-- counterPattern :: Maybe Int -> PatternState Int
-- counterPattern m =
--   case m of
--     Nothing -> PatternRest
--     Just _  ->
--       let x ~ 0 = x + 1
--       in  PatternPlaying x
--
seqPat :: Maybe Int -> PatternState a
seqPat m =
  case m of
    Nothing -> PatternRest
    Just t  ->
      let
        -- We could really use pat assignment with partial initializers
        x     = patX (maybeAnd (s == 0 || s == 2)) m
        y     = patY (maybeAnd 1) m
        s ~ 0 = s + 1
      in
        case squishPat (x, y) of
          (Just x, Just y) ->
            case s of
              0 -> x
              1 -> y
              2 -> x
              3 -> 1

          _ ->
            PatternYield

counterPat :: Pat Int
counterPat = Pat counterPattern

