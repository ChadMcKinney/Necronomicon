-- data Either a b = Either a b
data Maybe a = Just a | Nothing

class Functor f where
    map :: (a -> b) -> f a -> f b

-- map :: (a -> b) -> f a -> f a b
-- map f fa = f fa

class Functor f => Applicative f where
    pure :: a -> f a
    ap   :: f (a -> b) -> f a -> f b

-- class Applicative m => Monad m where
--     bind :: m a -> (a -> m b) -> m b
--

-- instance Functor Maybe where
--     map f (Just x) = Just (f x)
--
-- instance Applicative Maybe where
--     pure x               = Just x
--     ap (Just f) (Just x) = Just (f x)
--     ap _        _        = Nothing
--
-- instance Monad Maybe where
--     bind (Just x) f = f x
--     bind Nothing  _ = Nothing

-- class Semigroup a where
--     append :: a -> a -> a
--
-- class Eq a => Num a where
--     add :: a -> a -> a
--
-- class Eq a where
--     eq :: a -> a -> Bool
--
-- class Eq a => Ord a where
--     gt :: a -> a -> Bool
--
-- instance Num Int where
--     add x y = x + y
--
-- instance Ord Int where
--     gt x y = eq x y
--
-- instance Eq Int where
--     eq x y = x == y
--
--
-- class Foo a
-- class Foo a => Bar a
--
-- instance Eq a  => Foo (Maybe a)
-- instance Num a => Bar (Maybe a)
--
-- conTest :: Monad m => a -> m a
-- conTest = pure
--
--
-- class HigherKinded a where
--     highGround :: a b c d -> (a b c d -> e) -> e
