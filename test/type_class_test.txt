data Either l r = Either l r
data Maybe a = Just a | Nothing

class Functor f => Applicative f where
    pure :: a -> f a
    ap   :: f (a -> b) -> f a -> f b

class Functor f where
    map :: (a -> b) -> f a -> f b

class Applicative m => Monad m where
    bind :: m a -> (a -> m b) -> m b

instance Functor Maybe where
    map f (Just x) = Just (f x)

instance Applicative Maybe where
    pure x               = Just x
    ap (Just f) (Just x) = Just (f x)
    ap _        _        = Nothing

instance Monad Maybe where
    bind (Just x) f = f x
    bind Nothing  _ = Nothing

instance Monoid a => Functor (Either a) where
    map f (Either a b) = Either a (f b)

class Semigroup a where
    append :: a -> a -> a

class Semigroup a => Monoid a where
    mempty :: a

instance Semigroup a => Semigroup (Maybe a) where
    append (Just x) (Just y) = Just (append x y)
    append (Just x) _        = Just x
    append _        (Just y) = Just y
    append _        _        = Nothing

instance Monoid a => Monoid (Maybe a) where
    mempty = Nothing

class Eq a => Num a where
    add :: a -> a -> a

class Eq a where
    eq :: a -> a -> Bool

class Eq a => Ord a where
    gt :: a -> a -> Bool

instance Num Int where
    add x y = x + y

instance Ord Int where
    gt x y = eq x y

instance Eq Int where
    eq x y = x == y

class Foo a
class Foo a => Bar a

instance Eq a  => Foo (Maybe a)
instance Ord a => Bar (Maybe a)

conTest :: Monad m => a -> m a
conTest = pure

class HigherKinded a where
    highGround   :: a b c d -> (a b c d -> e) -> e
    higherGround :: a b c d -> b

data KindSlaver a b c d = Kind a b c d | NotKind

instance Num a => HigherKinded (KindSlaver a) where
    highGround k f = f k
    higherGround (Kind _ x _ _) = x

apTest fa (Just 0) = ap fa Nothing

(Just x) = x
x = 11
