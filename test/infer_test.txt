id :: a -> a
id x = x

idTest1 = id (3 == 4)
idTest2 = id (4 + 5)

one = 1
two = 2
tupleTest = (one, two)

-- x = x x

a = a

f x = let g y z = ([x, y], z)
      in (g 3, g 3)

foo x = foo (bar 0)
bar x = x

inferTest  = inferDeath + 2 + 2

inferDeath =
    let y = 2 + 666
        z = inferDeath + 100
    in  y + inferTest - z

boolTest = inferTest > (inferDeath + 2) && boolTest && ifTest
    where
        x      = 2
        ifTest = if boolTest
            then 2 > 3
            else 3 < 2

left  = (-1)
right = 1
tup   = (left, right)
add   = [left, right]

tupleAllTheWayDown = (tuplesPlease, tupleTest, 666.0)
    where
        tuplesPlease = (3.0, inferDeath, if boolTest then 5 else 7, tuplesAreTurles, 0)
            where
                tuplesAreTurles = (3 == 3, 5 + 6 * 7, 0.0)

listTest1     = []
listTest2     = [id 0]
listTest3 x   = [x]
tuplesXY  x y = (x, y)

compareTest = (3 == 4, 5 == 7)
boolTest2   = 3 == 4
boolTest3   = 4 == 4 && boolTest2

add2 0 x _ = x + 0

three = 3
four  = 4
five  = 5
six   = 6
seven = 7
eight = 8
nine  = 9
ten   = 10
tupleDoom = (one, two, three, four, five, six, seven, eight, nine, ten)

-- occursError = let bottom = (1, occursError) in (0, bottom)
-- occursError = let bottom = (100, 200, occursError) in (1, 2, bottom)

-- listsAllTheWayDown = listsPlease
--     where
--         listsPlease = [listsAllTheWayDown]

lambda  = \x _ 0 -> x
lambda2 z _ = \x -> \y -> (x + y - z) > 3 && (4 == 5)
    where
        f = \hey there -> hey || there && f hey there

letArithmetic = [1,5..11]

patTest x 0 _ [y, z] (w, 2, 3.3) = 0 + w / y

caseTest :: (Float, (a, b, c)) -> Float
caseTest x = case x of
    (y, (_, _, _)) -> y
    (_, z)         -> 123.4

coolList :: a -> b -> [a]
coolList x y = xs
    where
        xs = [x]

coolMaybe :: a -> Maybe a
coolMaybe x = if 3 > 4
    then Just x
    else Nothing

data Maybe  a   = Just a | Nothing
data Either a b = Left a | Right b
data Both a b   = Both a b | Neither

maybeTest :: Maybe Int -> Int
maybeTest m = case m of
    Just x  -> x
    Nothing -> 0

eitherTest :: Either a b -> Maybe a
eitherTest e = case e of
    Left  x -> Just x
    Right _ -> Nothing

patternTest :: Either (Maybe Float) a -> Either Float ()
patternTest (Left (Just _)) = Right ()

infixPatternTestBecauseIHateMyself :: Both a b -> (a, b)
infixPatternTestBecauseIHateMyself (x `Both` y) = (x, y)

caseInfixTest :: Both a b -> Both Int Float
caseInfixTest b = case b of
    x `Both` y -> Neither
    Neither    -> Both 0 0.0

twoTimes :: Maybe a -> Int
twoTimes (Just _) = 1
twoTimes Nothing  = 0

data Nested a = Epsilon | Cons a (Nested [a])

size :: Nested a -> Int
size Epsilon     = 0
size (Cons _ xs) = 1 + size xs

