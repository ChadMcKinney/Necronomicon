-- Patterns: Lazy types with implicitly memo ref cell parameter, provided by immediate outermost branch scope
accumulateNewAudio1 :: Default s => (Float -> s -> UPair Float s) -> Audio -> Audio

updateSinOscState :: Float -> SinOscState -> UPair Float SinOscState
updateSinOscState freq (SinOscState phase) =
  (value, SinOscState phase')
  where
    phase' = phase + freq * inverseSampleRateDelta
    value  = waveTableLookup phase' sinOscWaveTable

sinOsc :: Audio -> Audio
sinOsc freq = accumulateNewAudio1 updateSinOscState freq

-- OTHER SHIT --
-- Prev
speed :: Float -> Float -> Float
speed x y =
  dx * dx + dy * dy
  where
    dx = x - prev x
    dy = y - prev y

prev :: Default a => a -> a
prev x = cx
  where
    (px <- default, cx) = (x, px)

main :: World -> World
main =
  outAudio 1 synths
  >> outputFrame scene
  >> recordAudio fileName synths

-- More implicit Uniqueness typing (with more things left for both the typing system and the programmer to infer)
--  a --> NonUnique type variable
-- *a --> Unique type variable
-- .a --> Type variable with polymorphic uniqueness
-- Type variables must use the same uniqueness attribute throughout, otherwise type error
-- Arrow attributes are inferred. Constructor propagation is inferred.

-- Uniqueness Types
accumulateNewAudio1 :: (Default s) => (Float -> *s -> (Float, *s)) -> Audio -> Audio
updateSinOscState   :: Float -> *SinOscState -> (Float, *SinOscState)
writeArray          :: Int -> a -> *Array n a -> *Array n a
freezeArray         :: *Array n a -> Array n a -- no copying
thawArray           :: Array  n a -> *Array n a -- copying
fst                 :: (a, .b) -> .a
swap                :: (.a, .b) -> (.b, .a)
const               :: .a -> .b -> .a
(<<)                :: (.b -> .c) -> (.a -> .b) -> .a -> .c
(|>)                :: .a -> (.a -> .b) -> .b
maybe               :: .b -> (.a -> .b) -> Maybe .a -> .b
either              :: (.a -> .c) -> (.b -> .c) -> Either .a .b -> .c
(==)                :: .a -> .a -> Bool
apply               :: (.t -> .s) -> .t -> .s

updateSinOscState   :: Float -> SinOscState -> (Float, SinOscState)
                    :  u     -> *           -> * u *

-- Data declarations desugar to constructor functions with type variables that are polymoprhically unique
-- Data declaration and arrow uniqueness follows Clean style attribute propagation
data Either a b = Either a b

-- Implicit
Left  :: .a -> Either .a .b
Right :: .b -> Either .a .b
-- Explicit
Left  :: u:a -> u|v:Either u:a v:b
Right :: v:b -> u|v:Either u:a v:b

-- Implicit
const :: .a -> .b -> .a
-- Explicit
const :: u:a -> u:(v:b -> u:a)

-- kind based (Currently winning...)
-- * Rules: UniqueType types can only be stored in UniqueType types
-- Pros:
--     * Stays the fuck out of the way when not in use.
--     * Using them in the straightforward way is in fact very straightforward
--     * Type signatures are less cluttered
--     * Performance should be good.
--     * Better for hot swapping: The number of a thing and whether or not we can optimize it won't change from underneath unless the type itself changes, which necessitates a full reload anyways.
-- Cons:
--     * Code duplication... The code duplication is real.
--     * Using them in less straightforward ways can be unintuitive.
--     * Plays OK with type classes, not great, not horrible.
--     * Kinds are a somewhat advanced concept.
-- In the background uses an attribute system.
-- Type is sugar for a type with a NonUnique type attribute
-- UniqueType is sugar for a type with a Unique type attribute
-- UPolyType is sugar for a type with a polymorphic type attribute
-- Because of this, a type alone is enough to know the uniqueness of a value, since it's defined at declaration instead of use site.
-- Type variables applied to type constructors can have their attributes inferred.
-- Uniqueness signatures for arrows are automatically inferred and don't need to be spelled out (uses boolean unification system).
data SinOscState                             :: UniqueType = SinOscState Float

data Array (n :: Nat) a                                    = Array (Ptr a)
data UArray (n :: Nat) a                     :: UniqueType = UArray (Ptr a)

data (,) a b                                               = (a, b)
data UPair (a :: UPolyType) (b :: UPolyType) :: UniqueType = UPair a b

data Maybe a                                               = Just a | Nothing
data UMaybe (a :: UPolyType)                 :: UniqueType = UJust a | UNothing

accumulateNewAudio1 :: Default s => (Float -> s -> UPair Float s) -> Audio -> Audio
updateSinOscState   :: Float -> SinOscState -> UPair Float SinOscState
writeArray          :: Int -> a -> UArray n a -> UArray n a
readArray           :: Int -> UArray n a -> UPair (UArray n a) a
freezeArray         :: UArray n a -> Array n a -- no copying
thawArray           :: Array n a -> UArray n a -- via copying
main                :: World -> World
const               :: (a, b :: UPolyType) => a -> b -> a
(|>)                :: (a, b :: UPolyType) => a -> (a -> b) -> b
(<<)                :: (a, b, c :: UPolyType) => (b -> c) -> (a -> b) -> a -> c
outAudio            :: Int -> Audio -> World -> World
umaybe              :: (a, b :: UPolyType) => b -> (a -> b) -> UMaybe a -> b
ueither             :: (a, b, c :: UPolyType) => (a -> c) -> (b -> c) -> UEither a b -> c

-- Unique and NonUnique types can both instance the same class, with restrictions:
-- All types must satisfy the kind signature of a class (which includes information about uniqueness).
-- This pretty much necessitates that the class head be some form of UPoly if you want to use both Types and UniqueTypes

-- Classes have some ability to remove code duplication, with some caveats
class Tuple (t :: UPolyType -> UPolyType -> UPolyType) where
    fst   :: t a b -> a
    swap  :: t a b -> t b a
    tuple :: a b -> t a b
instance Tuple (,) where
    fst  (x, y) = x
    swap (x, y) = (y, x)
    tuple x y   = (x, y)
instance Tuple UPair where
    fst  (UPair x y) = x
    swap (UPair x y) = UPair y x
    tuple x y        = UPair x y

-- But there's a downside. Now instances of that class have Kind UPolyType, which must be used uniquely.
badDupTuple :: Tuple t => t a b -> t a a -- BROKEN!!!!! WON'T COMPILE!!!!
badDupTuple t = tuple (fst t) (fst t)    -- BAD! t is referred to twice, and Tuple class instance has UPolyType!

-- This won't work either, since the members of the tuple class are ALSO UPolyType
badDupTuple' :: Tuple t => t a b -> t a a   -- BROKEN!!!!! WON'T COMPILE!!!!
badDupTuple' t = let x = fst t in tuple x x -- BAD! x is referred to twice, and Tuple class instance has UPolyType!

-- However, as long as we stick to using these functions with their respective monomorphic types things will be fine.
--


------------------------------
-- Data declared Uniqueness Attributes...
------------------------------
-- Rule: Only unique types can contain unique types
-- Rule: The attribute of a data type will be solely inferrable from its type.

-- Type Unique
data * (always unique)
data SinOscState p       = SinOscState Float
data World               = World
data UArray (n :: Nat) a = Array (Ptr a)
data Shared a              = Shared a

-- Type Non-Unique
data Float              = Float
data Array (n :: Nat) a = Array (Ptr a)
data ()                 = ()

-- Type p
data p:(,)    p:a p:b = (a, b)
data p:Maybe  p:a     = Just a | Nothing
data p:Nested p:a     = Nested (Maybe a) (Maybe a)

data (,) a b = (a, b)
-- desugars into
u:a -> u:b -> u:(a, b)

(->) :: Type p -> Type q -> Type w

-- We have to do some inference to figure out the kind of the arrows in a function
dropAllThat         :: (a:p, b:q, c:w) => a -> b -> c -> ()

-- Desugars into:
dropAllThat         :: a:p ->:NonUnique b:q ->:p c:w ->:p|q ()
-- via the Free var collection method.
-- Inference assumes that higher order functions (the function values themselves) have multiplicity NonUnique.
-- If you want otherwise, you'll need to explicitly annotate that
-- This would also require the boolean algebra unification system.
-- That or we could say fuck it and do syntactic unification on boolean equations...would mean that p|q and q|p are different, but is that important?

-- Hardest part of all of this is the requirement for true kind generalization and kind instantiation.
-- and absolutely bullet proof kind story.
-- Would also need to change Type into Type p

accumulateNewAudio1 :: (Default s) => (Float -> s -> (Shared Float, s)) -> Audio -> Audio
updateSinOscState   :: Float -> SinOscState -> (Shared Float, SinOscState)
newUArray           :: a -> UArray n a
writeArray          :: Int -> a -> UArray n a -> UArray n a
readArray           :: Int -> UArray n a -> (UArray n a, Shared a)
freezeArray         :: UArray n a -> Array n a -- no copying
thawArray           :: Array n a -> UArray n a -- via copying
main                :: World -> World
fst                 :: (a:p)           => (a, b) -> a
const               :: (a:p, b:q)      => a -> b -> a
(|>)                :: (a:p, b:q)      => a -> (a -> b) -> b
(<<)                :: (a:p, b:q, c:w) => (b -> c) -> (a -> b) -> a -> c
maybe               :: (a:p, b:q)      => b -> (a -> b) -> Maybe a -> b
either              :: (a:p, b:p, c:q) => (a -> c) -> (b -> c) -> Either a b -> c
outAudio            :: Int -> Audio -> World -> World

-- How things play with classes is a bit more subtle...
-- Here f has kind: Type -> Type
class Functor f where
    map :: (a -> b) -> f a -> f b
    lmap :: (a:p, b:q) => (a -> b) -> f a -> f b

main :: World -> World
main =
    outAudio 1 synths
    >> outputFrame scene
    >> recordAudio fileName synths


-----------------------
-- When errors strike
-----------------------

-- Example #1
-- UniquenessTypesOverSimplified: ERROR: x is Unique but has been used two times! Here (Loc1) and Here (Loc2)
main :: *World -> *World
main w = w2
  where
    x       = 0
    y       = x
    (w2, _) = (w, x)

-- Example #2
-- UniquenessTypesOverSimplified: No Error
getCharAt :: Int -> *World -> *(World, Shared Char)
main :: *World -> *World
main w = w3
  where
      n             = 0
      (w2, Shared c1) = getChar n w
      (w3, Shared c2) = getChar n w2
------------------------------
-- Uniqueness Types...Fix the notation problem somehow
------------------------------

fst                 :: (a, b) -> a                             : w u v -> u
swap                :: (a, b) -> (b, a)                        : w u v -> w v u
const               :: a -> b -> a                             : u -> v -u> u
maybe               :: b -> (a -> b) -> Maybe a -> b           : u -> v (w -> u) -u> w x -u|v> u
(==)                :: a -> a -> Bool                          : u -> v -u> w
(|>)                :: a -> (a -> b) -> b                      : u -> v (u -> w) -u> w
(<<)                :: (b -> c) ->   (a -> b) -> a -> c        : u (v -> w) -> x (y -> v) -u> y -u|x> w
either              :: (a -> c) -> (b -> c) -> Either a b -> c
main                :: World -> World                          : Unique -> Unique

(|>)                :: u:a -> v:(u:a -> w:b) u:-> b
maybe               :: u:b -> v:(w:a -> u:b) u:-> x:Maybe w:a u|v:-> u:b

(|>)                :: a -> (a -> b) ->  b
                    :  u -> (u -v> w) -u> w

updateSinOscState   :: Float  -> SinOscState -> (SinOscState, Float)
                    :  Shared -> Unique      -> Unique Unique Shared

maybe               :: b -> (a -> b) -> Maybe a -> b
                     : u -> (w -v> u) -u> x w -u|v> u

data Apply a b = Apply (a -> b) a

-- This
(|>) :: .a -> .(.a -> .b) -> .b
-- Desugars into
(|>) :: u:a -> v:(u:a -> w:b) u:-> b



---------------------------
-- Linear (Perhaps affine?) arrows
-- (based on: "Linear Haskell: Practical Linearity in a Higher Order Polymorphic Language")
---------------------------
accumulateNewAudio1 :: Default s => (Float -> s ->. (s, Read Float)) ->. Audio ->. Audio
updateSinOscState   :: Float -> SinOscState ->. (SinOscState, Read Float)
writeArray          :: Int ->. a ->. UArray n a ->. UArray n a
readArray           :: Int ->. UArray n a ->. (UArray n a, Read a)
freezeArray         :: UArray n a ->. Read (Array n a)
withMutableArray    :: (UArray n a ->. Read b) ->. Read b

fst                 :: (a, b) ->. a
const               :: a ->. b ->. a
swap                :: (a, b) ->. (b, a)
main                :: World ->. World

maybe               :: b -> (a ->.p b) -> Maybe a ->.p b
(|>)                :: a ->.p (a ->.p b) ->. b
(<<)                :: (b ->.p c) ->. (a ->.q b) -> a ->.p*q c
outAudio            :: Int -> Audio -> World ->. World
main :: World ->. World
main =
  outAudio 1 synths
  >> outputFrame scene
  >> recordAudio fileName synths


------------------------------
-- Poly Kinded Uniqueness Types...Currently winning?
-- or.... MonoKinded Uniqueness Types, with ad-hoc class based polymorphism
------------------------------
-- Separate the world of Unique and NonUnique via kinds.
-- Type now becomes: Type u, where u: u :: Uniqueness

-- By default, Kind Polymorphic
data Float              = Float
data ()                 = ()
data Array (n :: Nat) a = Array (Ptr a)
data Maybe a            = Just a | Nothing
data (,)   a b          = (a, b)
data (,)   a b :: forall u. Type u -> Type v -> Type (u|v) = (a, b)

data Float :: Type Copy = Float
data ()    :: Type Copy = Float

data Maybe (a :: Type NonUnique) :: Type NonUnique = Just a | Nothing
data (,)   a b          = (a, b)

data UMaybe (a :: Type Unique) :: Type Unique = UJust a | UNothing
data (#,#)  (a :: Type Unique) (b :: Type Unique) = (#,#) a b

Mk(,) :: (u :: Uniqueness) (a :: Type u) (b :: Type u) -> a -> b -> (,) a b
-- (,) has kind: forall u. Type u -> Type u -> Type (u|v)
-- Note that all the types line up.

-- You can override this with specialized type uniqueness kinds if so desired.
data SinOscState                  :: Type Unique = SinOscState Float
data World                        :: Type Unique = World
data Shared (a :: Type NonUnique) :: Type Unique = Shared a
-- There's  few rules we have to enforce for safety:
-- A NonUnique type may not contain Unique types or polymorphically unique types
-- A Polymorphically unique type may only contain NonUnique Types and Types which share the same unique kind variable.
-- Unique types may contain anything.

-- Sugar?
(a:u, b:v, c:w) =>
-- Is sugar for
forall (u :: Uniqueness) (v :: Uniqueness) (w :: Uniqueness) (a :: Type u) (b :: Type v) (c :: Type w).

-- This is the kind of the arrow. Which doesn't say a lot on its own.
(->) :: forall (u :: Uniqueness) (v :: Uniqueness) (w :: Uniqueness). Type u -> Type v -> Type w
-- In reality the kinds of the arrows will have to be inferred from signatures
-- Will use the free var inference method, such that each successive arrow gains uniqueness via the boolean unification of previous arguments:
(a:u, b:v, c:w) => a -> b -> c -> ()
-- Desugars into
forall (u :: Uniqueness) (v :: Uniqueness) (w :: Uniqueness)  (a :: Type u) (b :: Type v) (c :: Type w).
       a -> (b -> (c -> () :: Type (u|v)) :: Type u) :: Type NonUnique
-- Kind of lame, but this should be only part that requires boolean kind unification.

-- Hardest part of all of this is the requirement for true kind generalization and kind instantiation.
-- and absolutely bullet proof kind story.
-- Would also need to change Type into Type p

accumulateNewAudio1 :: (Default s) => (Float -> s -> (s, Shared Float)) -> Audio -> Audio
updateSinOscState   :: Float -> SinOscState -> (SinOscState, Shared Float)

newArray            :: forall (a::Type u). a -> Array n a
writeArray          :: forall (a::Type Unique). Int -> a -> Array n a -> Array n a
readArray           :: Int -> Array n (Shared a) -> (Array n a, Shared a)
freezeArray         :: (Array n a :: Type u) -> (Array n a :: Type NonUnique) -- no copying


-- MonoKinds
newUArray           :: a -> UArray n a
writeUArray         :: Int -> a -> UArray n a -> UArray n a
readUArray          :: Int -> UArray n a -> (#UArray n a, Shared a#)
freezeArray         :: UArray n a -> Array n a -- no copying
thawArray           :: Array n a -> UArray n a -- via copying

main                :: World -> World
fst                 :: (a:u, b:v). (a, b) -> a
const               :: (a:u, b:v). a -> b -> a
maybe               :: (a:u, b:v). b -> (a -> b) -> Maybe a -> b
(|>)                :: (a:u, b:v). a -> (a -> b) -> b
either              :: (a:u, b:u, c:v). (a -> c) -> (b -> c) -> Either a b -> c
(<<)                :: (a:u, b:v, c:w). (b -> c) -> (a -> b) -> a -> c
outAudio            :: Int -> Audio -> World -> World

(->) :: forall u v w. Type u -> Type v -> Type w

class Tuple (t :: Type u -> Type u -> Type u) where
  fst :: t a b -> a
instance Tuple (,) where
    fst (x, _) = x
instance Tuple (#,#) where
    cst (#x, _#) = x

class MaybeClass (m :: Type u -> Type u) where
    maybe :: b -> (a -> b) -> m a -> b

instance MaybeClass Maybe where
    maybe b f m =
      case m of
        Just a  -> f a
        Nothing -> b

instance MaybeClass UMaybe where
    maybe b f m =
      case m of
        UJust a  -> f a
        UNothing -> b

-- Remember, instance data type must match the kind of the class head exactly, including uniqueness!
-- Class heads will not monomorphize uniqueness kinds.
-- This does mean classes will reject data types which are monomorphic in the uniqueness, but they are not common.
-- Here f has kind: Type u -> Type u
-- Despite the fact that it's only used as Type u -> Type u
class Functor f where
    map :: (a -> b) -> f a -> f b

-- Here f has kind: Type u -> Type u
class UFunctor f where
    umap :: (a:u, b:u) => (a -> b) -> f a -> f b

main :: World -> World
main =
    outAudio 1 synths
    >> outputFrame scene
    >> recordAudio fileName synths



--------------------------------------
-- Thieving Arrows
-- ->   Sharing Arrow
-- ->!  Thieving Arrow
-- ->.  Anonymous Polymorphic Arrow
-- ->.p Named Polymorphic Arrow
--
-- Ownership: Shared, Owned, Non-rigid TypeVar, Rigid TypeVar
-- Unique values start off as Non-rigid TypeVar
-- Polymorphic arrows default to Owned

data Float     = Float
data ()        = ()
data Maybe a   = Just a | Nothing
data (,)   a b = (a, b)
-- All data constructors use the poly arrow internally:
(,) :: a ->. b ->. (a, b)
-- This means they can be used for either owned or shared values.
-- They are, however, homogenous in their ownership.

-- Destructive API
newArray   :: Clone a => a ->! Array n a           -- Creates a fresh unique array, guaranteed to be unshared.
writeArray :: Int ->- a ->! Array n a ->! Array n a -- Destructively update the array in place, consuming the original.
readArray  :: Int ->- Array n a ->! (Array n a, Shared a)

-- Immutable API
newArray'   :: Clone a => a -> Array n a          -- Creates an array which is shared.
writeArray' :: Int -> a -> Array n a -> Array n a -- Writes into the array by producing a copy with an adjustment
readArray'  :: Int -> Array n a -> a              -- Get a read only reference from a read only array

-- Prelude functions
fst      :: (a, b) ->. a
swap     :: (a, b) ->. (b, a)
const    :: b ->. a ->. a
outAudio :: Int -> Audio ->- World ->! World
main     :: World ->! World

either   :: (a ->. c) ->. (b ->. c) ->. Either a b ->. c
(<<)     :: (b ->. c) ->. (a ->. b) ->. a ->. c
(>>)     :: (a ->. b) ->. (b ->. c) ->. a ->. c
maybe    :: (a ->. b) ->. Maybe a ->. b ->. b
(|>)     :: a ->. (a ->. b) ->. b

class Clone a where
  clone :: Clone a => a ->- a

instance (Clone a, Clone b) => Clone (a, b) where
  clone (a, b) = (clone a, clone b)

-- Share with arrow in data constructor
newtype Shared :: Type -> Type where
  Shared :: a ->- Shared a
-- The a value under Shared is always shared, even if the Shared value itself is Owned, this means the value a can never be consumed.
-- This allows us to destructively update containers which contain immutable references to shared objects safely!

-- Since data type are uniformly homogenous in their uniqueness polymorphism we can ignore that constraint for type classes.
class Functor f where
  map :: (a -> b) -> f a -> f b

class AFunctor f where
  amap :: (a ->. b) ->. f a ->. f b

main :: World ->! World
main =
  outAudio 1 synths
  >> outputFrame scene
  >> recordAudio fileName synths

getChar :: World ->! (World, Shared Char)
snd     :: (a, b) ->. b

takeAndGive :: Bool ->- Array n a ->! Maybe (Shared a)
takeAndGive test array1 =
  if test then
    readArray 0 array1
    |> snd
    |> Just
  else
    readArray 1 array1
    |> snd
    |> Just

data AndOr a b = AndOrLeft a | AndOrRight b | AndOrBoth a b

gimmeBoth :: a ->! b ->! AndOr a b
gimmeBoth x y = AndOrBoth x y

takeAndGive :: Bool ->- Array n a ->! Maybe (Array n a)
takeAndGive test array1 =
  if test then
    Just array1
  else
    readArray 0 array1
    |> fst
    |> Just

-- Error!
branchesOfDoom :: Bool ->- Array n a ->! (Maybe (Array n a), Maybe (Array n a))
branchesOfDoom test array1 =
  if test then
    let array2 = newArray 0
    in (array2, array2)
  else
    (Just array1, Nothing)

main :: World ->! World
main world =
  world
  |> outAudio 1 synths
  |> outputFrame scene
  |> recordAudio fileName synths
  |> print "Hello world"

-- 1. Error! Ownership Mismatch: Expected Owned, Found Shared at: getChar n w2
getCharAt :: Int ->- World ->! (World, Shared Char)
main :: World ->! World
main w = w2
  where
    n                 = 0
    (w2, Shared c1 _) = getChar n w
    (w3, Shared c2 _) = getChar n w2

-- ThievingArrows error: ERROR: Ownership Mismatch - Expected Owned, but Found Shared. -- 6| (w2, _) = (w, x)
main :: World ->! World
main w = w2
  where
    x       = 0
    y       = x
    (w2, _) = (w, Shared x)

-- Passes:
-- 1. Usage analysis:   Mark values as Shared or Non-Shared usage.
-- 2. Type checking:    Infer expression Ownership as: Shared, Owned, Non-Rigid Var, Rigid Var.
--
-- Notes:
-- All Inhabited types have an additional Ownership Type (similar to how they have an additional kind).
-- NecroAliasAnalysis, Introduce new scope at Branches, ... where else?

-- Data declarations with Higher Order functions cannot use the anonymous Poly Arrow, must use explicit Poly Arrow, with the var appearing in the data type!.
data HigherArrow a p b = HigherArrow (a -p> b)

data SVal a     = SVal Time a | SRest Time | SYield
data Sequence a = Sequence (Time -> SVal a)
mouse      :: Sequence (Int, Int)
show       :: a -> Sequence Char
myCoolBeat :: Sequence Audio

updateSinOscState :: Float ->- SinOscState ->! (SinOscState, Shared Float)
updateSinOscState freq (SinOscState phase) =
  (SinOscState (clone phase'), Shared value)
  where
    phase' = share phase + freq * inverseSampleRateDelta
    value  = waveTableLookup phase' sinOscWaveTable

updateSinOscState :: Float ->- SinOscState ->! (SinOscState, Shared Float)
updateSinOscState freq (SinOscState phase) =
  let phase' = share phase + freq * inverseSampleRateDelta
      value  = waveTableLookup phase' sinOscWaveTable
  in (SinOscState (clone phase'), Shared value)

(|>) :: a ->. (a ->. b) ->. b

-- Clone vs Copy?
clone     :: a ->- a
getCharAt :: Int ->- World ->! (World, Shared Char)
share     :: a ->! Shared a -- This probably requires compiler magic, but it should be possible without any copying at all.

-- Primary
-- NOTE: Closure type always matches Domain type!
--                 Domain    Codomain  Closure
Sharing   (->)  :: Shared -> Shared -> Shared
Stealing  (->!) :: Owned  -> Owned  -> Owned
Poly      (->.) :: p      -> p      -> p -- Note, all ->. instances in the same signature share the same anonymous variable.
-- Less Common but useful
ShareWith (->-) :: Shared -> p      -> Shared

-- Disjunct Closures
--                 Domain    Codomain  Closure
Sharing   (->)  :: Shared -> Shared -> Shared
Stealing  (->!) :: Owned  -> Owned  -> p
Poly      (->.) :: q      -> q      -> p -- Note, all ->. instances in the same signature share the same anonymous variable.
Full    (u-c>v) :: u      -> v      -> c

getCharAt :: Int -> World ->! (World, Shared Char)
(|>) :: a u1-c1>v1 (a u1-c2> b) v-w>q b

(>>) :: (a u-f>v b) f-f1>w (b v-f2>x c) ->. a ->. c

------------------------------
-- Uniqueness Types Over Simplified
------------------------------
-- Data types are homogenously polymorphic in their uniqueness
data Float     = Float
data ()        = ()
data Maybe a   = Just a | Nothing
data (,)   a b = (a, b)
-- Propagation is not a part of the data declaration, but instead constructor functions and type inference.
(,) :: u:a -> u:b u:-> u:(a, b)
-- Constructors are monmorphic in their uvars.

-- Naively Higher order functions there work like?
data App a b = App (a -> b) a
-- Completely constructor based. If inner function needs uvars, the type must provide them itself.

-- Example:
dropAllThat :: .a -> .b -> .c -> .()

dropAllThat :: u:a -> v:b -> w:c -> z:()

-- Desugars into:
dropAllThat :: u:a -> v:b u:-> w:c u|v:-> z:()

-- Example:
replaceEither :: .a -> .b -> .Either a b -> .(a, b)

replaceEither :: u:a -> u:b -> u:Either a b -> u:(a, b)

-- Desugars into
replaceEither :: u:a -> u:b u:-> u:Either u:a u:b u:-> u:(u:a, u:b)


-- Arrows get their uniqueness type via the the free var collection method.
-- Use syntactic unification.

-- Example:
arrowExample :: .a -> .Int -> .Bool -> .(a, a)
-- Desugars into
arrowExample :: u:a -> v:Int u:-> w:Bool u|v:-> u:(a, a)

accumulateNewAudio1 :: (Default s) => (Float -> s -> (s, Shared Float)) -> Audio -> Audio : (& -> * -> *) -> & -> &
updateSinOscState   :: Float -> SinOscState -> (SinOscState, Shared Float) : & -> * -> *

newArray            :: a -> Array n a : u -> u
writeArray          :: Int -> a -> Array n a -> Array n a : & -> * -> * -> *
readArray           :: Int -> Array n (Shared a) -> (Array n a, Shared a) : & -> * -> * -> *

freeze              :: a -> a : * -> u            -- no copying
clone               :: Clone a => a -> a : & -> u -- via copying

main                :: World -> World : * -> *
outAudio            :: Int -> Audio -> World -> World : & -> & -> * -> *

fst                 :: .(a, b) -> .a
swap                :: .(a, b) -> .(b, a)
const               :: .a -> .b -> .a
(|>)                :: .a -> .(.a -> .b) -> .b
(<<)                :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
maybe               :: .b -> .(.a -> .b) -> .Maybe a -> .b
either              :: .(.a -> .c) -> .(.b -> .c) -> .Either a b -> .c

(<<)                :: (b -> c) -> (a -> b) -> a -> c
                       (u -v> w) -> (x -y> u) -v> x -v|y> w

(<<)                :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
-- Desugars into
(<<)                :: u:(v:b -> w:c) -> x:(y:a -> v:b) u:-> y:a u|x:-> w:c

(<<)                :: (v:b u:-> w:c) -> (y:a x:-> v:b) u:-> y:a u|x:-> w:c

-- NO PROPAGATION AT ALL.
-- Completely driven by constructor functions (for construction and pattern matching).


maybe               :: u:b -> (w:a v:-> u:b) u:-> w:Maybe a u|v:-> u:b

-- Since data type are uniformly homogenous in their uniqueness polymorphism we can ignore that constraint for type classes.
class Functor f where
    map :: (a -> b) -> f a -> f b

class UFunctor f where
    umap :: .(.a -> .b) -> .f a -> .f b
    umap :: (a ->  b) -> f a ->  f b
          : (u -v> w) -> u   -v> w

main :: *World -> *World
main =
  outAudio 1 synths
  >> outputFrame scene
  >> recordAudio fileName synths

-- New idea: Glyph vars
(|>) :: a p-&>u (a p-z>q b) v-u>q b

(|>) :: a -> (a -> b) -> b
(|>) :: a¹ -> (a¹ -> b²)³ -> b²

(|>) :: a -> (a -> b) -> b
      : u -> (u -v> w) -u> w

(<<) :: (b ->  c) -> (a ->  b) ->  a ->    c
      : (u -v> w) -> (x -y> u) -v> x -v|y> w

maybe :: b -> (a ->  b) ->  Maybe a ->    b
       : u -> (v -w> u) -u> v       -u|w> u

maybe :: u.b -> (v.a w.-> u.b) u.-> v.Maybe a u|w.-> u.b
maybe :: u:b -> (v:a w:-> u:b) u:-> v:Maybe a u|w:-> u:b

maybe :: .b -> (..a ...-> .b) .-> ..Maybe a .|...-> .b
maybe :: .b -> (.a -> .b) .-> ..Maybe a .|...-> .b

maybe :: b¹ -> (a² -> b¹)³ -> Maybe a² -> b¹
maybe :: u:b -> w:(v:a -> u:b) -> v:Maybe a -> u:b

maybe :: .b -> .(.a -> .b) -> .Maybe a -> .b


-- First arrow always considered NonUnqiue, unless otherwise noted (by marking the function argument as a whole). After that, free var collection method.
(<<)  :: (b -> c) -> (a -> b) -> a -> c

(<<)  :: u:(v:b -> w:c) -> x:(y:a -> w:b) -> y:a -> w:c

-- Need to: Remove (at least at the shallowest point) unique arrow stuff
-- Lex/Parse/Ast support for *
-- Support for printing out uvars
-- Work out system for uniqueness propagation across types (following what's mentioned in Dot syntax).
-- Reintroduce uniqueness inference, based on this system, ignoring functions at first.
-- Free var collection method, 'Or' attribute, Simple syntactic unification of Ors.
--

-------------------------
    -- Homogenous Propagation and Dot Syntax (Completely type driven).
-------------------------
-- Propagation:
--     * Rule 1: Uniqueness is homogenous for a type and all its propagating arguments.
--     * Rule 2: A type argument is propagating if it has kind Type.
-- Decoration:
--     * Rule 1: Undecorated Types are NonUnique
--     * Rule 2: Types decorated by * are Unique
--     * Rule 3: Types decorated by . are polymorphic in their uniqueness and follow the dot syntax rules
-- Dot Syntax:
--     * Rule 1: A dot decorated type is assigned a uvar which is consistently used everywhere that type is decorated with a dot.
--     * Rule 2: A type with type arguments follows the propagation rules. This may cause some dot created uvars to bind to eachother.
--     * Rule 3: A dot decorated type must remain polymorphic after propagation.
-- Function Uniqueness:
--     * Rule 1: Functions are only as unique as they are required to be.
--     * Rule 2: "As unique as they are required to be" is determined by unioning the uniqueness of the free variables of the function.
--     * Rule 3: This is implicit. A function may optionally be given an initial uniqueness. This is then used as the starting basis for further functions.

data Float     = Float
data ()        = ()
data Maybe a   = Just a | Nothing

-- This
data (,)   a b = (a, b)
-- Desugars into this
data u:(,) u:a u:b = (a, b)
(,) :: u:a -> u:b u:-> u:(a, b)

-- This
data App a b = App (a -> b) a
-- Desugars into this
data u:App u:a u:b = App u:(u:a -> u:b) u:a
App :: u:(u:a -> u:b) -> u:a u:-> u:App a b

-- Let's say you want an App, but don't want the inner function to become unique if App is Unique. use Shared
-- This
data App a b = App (Shared (a -> b)) a
-- Desugars into this
data u:App u:a u:b = App u:(Shared (u:a -> u:b)) u:a
App :: u:(Shared (u:a -> u:b)) -> u:a u:-> u:App a b

-- Here m is Non-Propagating, because it is has Kind (Type -> Type)
data MonadT (m :: Type -> Type) a = MonadT (m a)
data u:MonadT m u:a = MonadT u:(m a)
MonadT :: u:(m a) -> u:MonadT m a

maybe :: .b -> .(.a -> .b) -> .Maybe a -> .b
maybe :: u:b -> v:(w:a -> u:b) -> w:Maybe a -> u:b

-- This
(<<)  :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
-- Desugars into this
(<<)  :: u:(v:b -> w:c) -> u:(x:(y:a -> w:b) -> u|x:(y:a -> w:c))

tripleDown :: .(a -> b -> c -> d) -> ()
tripleDown :: u:(a -> u:(b -> u:(c -> d))) -> ()

tripleDown' :: .(.a -> .b -> .c -> .d) -> ()
tripleDown' :: u:(v:a -> u|v:(w:b -> u|v|w:(x:c -> z:d))) -> ()

-- APIs
updateSinOscState   :: Float -> *SinOscState -> *(SinOscState, Shared Float)

-- Array
newArray   :: .a -> .Array n a
writeArray :: Int -> *a -> *Array n a -> .Array n a
readArray  :: Int -> *Array n (Shared a) -> .(Array n a, Shared a)

clone      :: Clone a => a -> .a

-- World
main       :: *World -> *World
outAudio   :: Int -> Audio -> *World -> *World

-- Prelude
(<<)  :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
maybe :: .b -> .(.a -> .b) -> .Maybe a -> .b

------------------------------
-- Poly Kinded 3.0?
------------------------------
-- As above, but instead of Uniqueness Attributes, we have an additional paramter to Type constructor (Like Levity polymorphism)
-- As above, but with disjoint container and argument uniqueness, with constraints based on boolean ors.

-- Defaults to poly kinded as: Type u
data Float = Float
data ()    = ()

data Maybe a = Just a | Nothing
data Array a = Array (Ptr a)

-- Specified kinds
data World                        :: Type Unique = World
data SinOscState                  :: Type Unique = SinOscState Float
data Shared (a :: Type NonUnique) :: Type Unique = Shared a

-- This
data (,)   a b = (a, b)
-- Desugars into this
(,) :: (u:a, u:b) => a -> b -> (a, b)

-- This
data App a b = App (a -> b) a
-- Desugars into this
App :: (u:a, u:b) => u:(a -> b) -> a u:-> App a b

-- APIs
updateSinOscState :: Float -> SinOscState -> (SinOscState, Shared Float)

-- Array
newArray    :: (u:a) => a -> Array n a
writeArray  :: (U:a) => Int -> a -> Array n a -> Array n a
readArray   :: Int -> Array n (Shared a) -> (Array n (Shared a), Shared a)
freezeArray :: Array n (Shared a) -> Array n a -- Under the hood will be a no-op, as Shared will be implemented as a newtype

-- TODO: Shared implementation?
-- TODO: (Later): newtype implementation

-- World
main     :: World -> World
outAudio :: Int -> Audio -> World -> World

-- Prelude
maybe  :: (u:a, v:b)      => b -> w:(a -> b) -> Maybe a -> b
either :: (u:a, u:b, v:c) => w:(a -> c) -> x:(b -> c) -> Either a b -> c
(<<)   :: (u:a, v:b, w:c) => x:(b -> c) -> y:(a -> b) -> a -> c


----------------------------------
-- Type driven Uniqueness
----------------------------------
-- As above, but type variables have fixed uniqueness
-- As above, but with disjoint container and argument uniqueness, with constraints based on boolean ors.

-- NonUnique
data Float     = Float
data ()        = ()

-- Unique
data 1:World       = World
data 1:SinOscState = SinOscState Float

data Maybe a = Just a | Nothing
data Array a = Array (Ptr a)

-- This
data (,)   a b = (a, b)
-- Desugars into this
data u:(,) u:a u:b = (a, b)
(,) :: u:a -> u:b u:-> u:(a, b)

-- This
data App a b = App (a -> b) a
-- Desugars into this
data u:App u:a u:b = App u:(u:a -> u:b) u:a
App :: u:(u:a -> u:b) -> u:a u:-> u:App a b
-- Desugars into this:
data u:App v:a w:b = u:App x:(v:a -> w:b) v:a
App :: forall u v w x y a b. (u<=x, u<=v, u<=w, y<=x) => x:(v:a -> w:b) -> v:a y:-> u:App v:a w:b
App :: .(.a -> .b) -> .a -> App .a .b







-- APIs
updateSinOscState :: Float -> *SinOscState -> *(SinOscState, Shared Float)

-- Array
newArray     :: .a -> .Array n a
writeArray   :: Int -> *a -> *Array n a -> *Array n a
readArray    :: Int -> *Array n (Shared a) -> *(Array n (Shared a), Shared a)
freezeShared :: *Array n (Shared a) -> Array n a

consume :: *a -> ()

-- World
main     :: *World -> *World
outAudio :: Int -> Audio -> *World -> *World

-- Prelude
maybe  :: .b -> .(.a -> .b) -> .Maybe a -> .b
either :: .(.a -> .c) -> .(.b -> .c) -> .Either a b -> c
(<<)   :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
fst    :: .(a, b) -> .a

class Freeze a where
  freeze :: (a ~ a1) => *a -> a1

death :: .a -> .b -> c -> d -> ()
death :: forall u v w x a b. (w<=u, x<=u, x<=v) => u:a -> w:(v:b -> x:(c -> d -> ()))

-- uvars tied to tyvars
-- boolean unification vs coercions

-- TODO: Shared implementation?
-- TODO: (Later): newtype implementation
-- Unique, NonUnique

