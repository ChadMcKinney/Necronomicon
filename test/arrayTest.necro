-----------------------------------------
-- Array thoughts
-----------------------------------------
-- data Array a = Array Int (Ptr a)
--
-- -- TODO: Base .necro compiling system?
-- -- State Analysis with stateful closure detection / type checking !?!?!
--
-- -- Some thoughts:
-- -- 1. Mapping stateful closures can have unintuitive consequences
-- --    and seem something of an anti-pattern unless you know what you are doing (i.e. how they would be used in poly)
-- -- 2. Stateful closures have a performance burden
-- -- Possible Conclusion:
-- -- Closures by default are "Pointwise", have "Stateful" closures, but you have to opt in to them.
-- -- This would be checked statically
--
-- mapv :: (a -> b) -> Array a -> Array b
-- mapv f v = mapvgo f (unsafeMalloc (len v)) (ptr v) (len v) (len v + 1)
--
-- mapvgo :: (a -> b) -> Ptr a -> Ptr b -> Int -> Int -> Array b
-- mapvgo f prevPtr newPtr len i =
--   case i of
--     0 ->
--       Array len newPtr
--     _ ->
--       mapvgo f prevPtr (unsafePoke i (f (unsafePeek i prevPtr)) newPtr) len (i - 1)
--
-- sinOsc :: Array Float
-- sinOsc = map (waveTableLookup sinOscTable) phases where
--   (accu ~ 0, phases) = accumulate (\a -> a + recipDeltaTime) accu blockSize

-- data Maybe a = Just a | Nothing
--
-- makeVec3 :: a -> a -> a -> Array a
-- makeVec3 x y z = Array 3 ptr''' where
--   ptr    = unsafeMalloc 3
--   ptr'   = unsafePoke 0 x ptr
--   ptr''  = unsafePoke 1 y ptr'
--   ptr''' = unsafePoke 2 z ptr''
--
-- lookup :: Int -> Array a -> Maybe a
-- lookup i v =
--   case v of
--     Array l p ->
--       Just (unsafePeek i p)
--
-- lookupOr :: a -> Int -> Array a -> a
-- lookupOr x i v = unwrapOr x (lookup i v)
--
-- unsafeLookup :: Int -> Array a -> a
-- unsafeLookup i v =
--   case v of
--     Array l p ->
--       unsafePeek i p
--
-- intVec :: Array Int
-- intVec = makeVec3 1 2 3
--
-- intVecVec :: Array (Array Int)
-- intVecVec = makeVec3 intVec intVec intVec
--
-- unwrapOr :: a -> Maybe a -> a
-- unwrapOr o m =
--   case m of
--     Just x ->
--       x
--     Nothing ->
--       o
--
-- main :: Int
-- main =
--   lookupOr 0 1 intVec

-- -----------------------------------------
-- -- Numeric case statements
-- -----------------------------------------
-- main :: Int
-- -- main = 0
-- -- main = lookupOr 0 2 (mapv doubleIt intVec)
-- main = lookupOr 0 2 (doubleMapVec intVec)
--
-- -- loopTest :: Int -> Int
-- -- loopTest x =
-- --   case x of
-- --     0 -> 0
-- --     1 -> 100
-- --     2 -> 200
-- --     _ -> loopTest (x - 1)
--
-- -- mapv :: (a -> b) -> Array a -> Array b
-- -- mapv f v =
-- --   case v of
-- --     Array l p ->
-- --       Array l (mapptr f p (unsafeMalloc l) (l - 1))
--
-- -- mapptr :: (a -> b) -> Ptr a -> Ptr b -> Int -> Ptr b
-- -- mapptr f prevPtr newPtr i =
-- --   case i of
-- --     -1 ->
-- --       newPtr
-- --     _ ->
-- --       mapptr f prevPtr (unsafePoke i (f (unsafePeek i prevPtr)) newPtr) (i - 1)
--
-- fillptr :: Int -> a -> Ptr a -> Ptr a
-- fillptr i x ptr =
--   case i of
--     -1 -> ptr
--     _  -> fillptr (i - 1) x (unsafePoke i x ptr)
--
-- replicatev :: Int -> a -> Array a
-- replicatev i x =
--   Array i (fillptr (i - 1) x (unsafeMalloc i))
--
-- intVec :: Array Int
-- intVec = replicatev 1000000 100
--
-- doubleMapVec :: Array Int -> Array Int
-- doubleMapVec v =
--   case v of
--     Array l p ->
--       Array l (doubleMapPtr p (unsafeMalloc l) (l - 1))
--
-- doubleMapPtr :: Ptr Int -> Ptr Int -> Int -> Ptr Int
-- doubleMapPtr prev new i =
--   case i of
--     -1 -> new
--     _  -> doubleMapPtr prev (unsafePoke i (doubleIt (unsafePeek i prev)) new) (i - 1)
--
-- doubleIt :: Int -> Int
-- doubleIt x = x + x
--
-- data Maybe a = Just a | Nothing
--
-- lookup :: Int -> Array a -> Maybe a
-- lookup i v =
--   case v of
--     Array l p ->
--       Just (unsafePeek i p)
--
-- lookupOr :: a -> Int -> Array a -> a
-- lookupOr x i v = unwrapOr x (lookup i v)
--
-- unwrapOr :: a -> Maybe a -> a
-- unwrapOr o m =
--   case m of
--     Just x  -> x
--     Nothing -> o
--
-- -- -- TODO / Note for Chad: Core doesn't handle top level alt variables.
-- -- -- TODO / Note for Chad: Core doesn't handle nested alt numeric values.
-- -- justNum :: Maybe Int -> Int
-- -- justNum m =
-- --   case m of
-- --     Just 0  -> 100
-- --     Just 1  -> 200
-- --     Nothing -> 300
-- --     _       -> 400
