----------------------------------
-- Uniqueness Typing Oversimplified
----------------------------------
-- Type variables have fixed uniqueness
-- Homogenously unique container types
-- All inhabited types propagate uniqueness, even higher kinded ones, and ones in the codomain of functions
-- All types follow the same uniqueness rules
-- Use coercions and free variable collection method for functions

-- This
data (,)   a b = (a, b)
-- Desugars into this
data u:(,) u:a u:b = (a, b)
(,) :: u:a -> u:b u:-> u:(a, b)

-- This
data App a b = App (a -> b) a
-- Desugars into this
data u:App u:a u:b = App u:(u:a -> u:b) u:a
App :: u:(u:a -> u:b) -> u:a u:-> u:App a b
-- Desugars into this:
data u:App v:a w:b = u:App x:(v:a -> w:b) v:a
App :: forall u v w x y a b. (u<=x, u<=v, u<=w, y<=x) => x:(v:a -> w:b) -> v:a y:-> u:App v:a w:b
App :: .(.a -> .b) -> .a -> App .a .b

-- APIs
updateSinOscState :: Float -> *SinOscState -> *(SinOscState, Shared Float)

-- Array
newArray     :: .a -> .Array n a
writeArray   :: Int -> *a -> *Array n a -> *Array n a
readArray    :: Int -> *Array n (Shared a) -> *(Array n (Shared a), Shared a)
freezeShared :: *Array n (Shared a) -> Array n a

consume :: *a -> ()

-- World
main     :: *World -> *World
outAudio :: Int -> Audio -> *World -> *World

-- Prelude
maybe  :: .b -> .(.a -> .b) -> .Maybe a -> .b
either :: .(.a -> .c) -> .(.b -> .c) -> .Either a b -> c
(<<)   :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
fst    :: .(a, b) -> .a
(|>)   :: .a -> .(.a -> .b) -> .b

fst :: .(a, b) -> .a
fst (x, _) = x

snd :: .(a, b) -> .b
snd (_, y) = y

class Freeze a where
  freeze :: (a ~ a1) => *a -> a1

death :: .a -> .b -> c -> d -> ()
death :: forall u v w x a b. (w<=u, x<=u, x<=v) => u:a -> w:(v:b -> x:(c -> d -> ()))

-- TODO: Shared implementation?
-- TODO: (Later): newtype implementation
--

-- Loop ?
loopTest :: .Array n Float
loopTest = a' where
  (feed ~ 0, a') =
    for each (feed, empty) loop i (x, a) ->
      (x * 100, writeArray i x a)

-- New, non-poly Range API
each               :: Range n
slidingWindow      :: Index n -> Range m -> Range m
offsetRange        :: UInt -> Range n -> Range n
_unsafeUninitArray :: *Array n a
freezeArray        :: *Array n (Shared a) -> Array n a
readArray          :: Index n -> Array n a -> a
readArray'         :: Index n -> *Array n (Shared a) -> *(Array n (Shared a), Shared a)
writeArray         :: Index n -> *a -> *Array n a -> *Array n a

map :: (a -> b) -> Array n a -> Array n b
map f a =
    freezeArray <|
        for each _unsafeUninitArray loop i b ->
            let aVal = readArray i a
                bVal = Shared (f aVal)
            in writeArray i bVal b

mapU :: (*a -> *b) -> *Array n a -> *Array n b
mapU f arrayA =
  for each _unsafeUninitArray loop i arrayB ->
    let
      valA = readArray i arrayA
      valB = f valA
    in
      writeArray i valB arrayB

each :: Range n
each = Range 0 1 0

accumulate :: Array n Float -> Float
accumulate a =
  for each 0 loop i x ->
    x + (index i a)

test :: Int
test a =
  for each 0 loop i x ->
    x + 1

coolArray :: Array 2 (Maybe Float)
coolArray = { Just 666, Just 1 }

printInt :: Int -> *World -> *World
putChar :: Char -> *World -> *World

main :: *World -> *World
main w = printInt 0 w

delayTest :: Int
delayTest = z where
    x ~ (Just 0, Just 0) =
        case y of
            (yl, Just yr) -> (yl, Just yr + 1)
    y ~ (Just 0, Just 0) =
        case x of
            (xl, Just xr) -> (Just xr + 1, xl)

loopTest :: Array n Float
loopTest = a' where
  (feed ~ 0, a') =
    for each (feed, empty) loop i (x, a) ->
      (x * 100, writeArray i x a)


counter :: Maybe Int
counter = x where
  x ~ Nothing =
    case x of
      Nothing -> Just 0
      Just i  -> Just (i + 1)

feedTest :: ((Int, Int), (Int, Int))
feedTest = x where
  x ~ ((0, 1), (2, 3)) =
    case (gt mouseX 50, x) of
      (True,  ((x, y), r)) -> (r, (y, x))
      (False, ((z, w), r)) -> ((w, z), r)

