----------------------------------
-- Uniqueness Typing Oversimplified
----------------------------------
-- Type variables have fixed uniqueness
-- Homogenously unique container types
-- All inhabited types propagate uniqueness, even higher kinded ones, and ones in the codomain of functions
-- All types follow the same uniqueness rules
-- Use coercions and free variable collection method for functions

-- This
data (,)   a b = (a, b)
-- Desugars into this
data u:(,) u:a u:b = (a, b)
(,) :: u:a -> u:b u:-> u:(a, b)

-- This
data App a b = App (a -> b) a
-- Desugars into this
data u:App u:a u:b = App u:(u:a -> u:b) u:a
App :: u:(u:a -> u:b) -> u:a u:-> u:App a b
-- Desugars into this:
data u:App v:a w:b = u:App x:(v:a -> w:b) v:a
App :: forall u v w x y a b. (u<=x, u<=v, u<=w, y<=x) => x:(v:a -> w:b) -> v:a y:-> u:App v:a w:b
App :: .(.a -> .b) -> .a -> App .a .b

-- APIs
updateSinOscState :: Float -> *SinOscState -> *(SinOscState, Shared Float)

-- Array
newArray     :: .a -> .Array n a
writeArray   :: Int -> *a -> *Array n a -> *Array n a
readArray    :: Int -> *Array n (Shared a) -> *(Array n (Shared a), Shared a)
freezeShared :: *Array n (Shared a) -> Array n a

consume :: *a -> ()

-- World
main     :: *World -> *World
outAudio :: Int -> Audio -> *World -> *World

-- Prelude
maybe  :: .b -> .(.a -> .b) -> .Maybe a -> .b
either :: .(.a -> .c) -> .(.b -> .c) -> .Either a b -> c
(<<)   :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
fst    :: .(a, b) -> .a
(|>)   :: .a -> .(.a -> .b) -> .b

fst :: .(a, b) -> .a
fst (x, _) = x

snd :: .(a, b) -> .b
snd (_, y) = y

class Freeze a where
  freeze :: (a ~ a1) => *a -> a1

death :: .a -> .b -> c -> d -> ()
death :: forall u v w x a b. (w<=u, x<=u, x<=v) => u:a -> w:(v:b -> x:(c -> d -> ()))

-- TODO: Shared implementation?
-- TODO: (Later): newtype implementation
--

-- Loop ?
loopTest :: .Array n Float
loopTest = a' where
  (feed ~ 0, a') =
    for each (feed, empty) loop i (x, a) ->
      (x * 100, writeArray i x a)

each          :: Range n (Index n)
slidingWindow :: Range m (Range n (Index n))
offsetRange   :: Int -> Range n (Index n) -> Range n (Index n)
writeArray    :: Index n -> *a -> *Array n a -> *Array n a


-- New, non-poly Range API
each          :: Range n
slidingWindow :: Index n -> Range m -> Range m
offsetRange   :: UInt -> Range n -> Range n
writeArray    :: Index n -> *a -> *Array n a -> *Array n a

data Range n = Range UInt UInt UInt --Start, Increment, End (Or perhaps, trim amount)

each :: Range n
each = Range 0 1 0

accumulate :: Array n Float -> Float
accumulate a =
  for each 0 loop i x ->
    x + (index a i)

