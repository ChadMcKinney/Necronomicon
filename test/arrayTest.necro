----------------------------------
-- Uniqueness Typing Oversimplified
----------------------------------
-- Type variables have fixed uniqueness
-- Homogenously unique container types
-- All inhabited types propagate uniqueness, even higher kinded ones, and ones in the codomain of functions
-- All types follow the same uniqueness rules
-- Use coercions and free variable collection method for functions

-- This
data (,)   a b = (a, b)
-- Desugars into this
data u:(,) u:a u:b = (a, b)
(,) :: u:a -> u:b u:-> u:(a, b)

-- This
data App a b = App (a -> b) a
-- Desugars into this
data u:App u:a u:b = App u:(u:a -> u:b) u:a
App :: u:(u:a -> u:b) -> u:a u:-> u:App a b
-- Desugars into this:
data u:App v:a w:b = u:App x:(v:a -> w:b) v:a
App :: forall u v w x y a b. (u<=x, u<=v, u<=w, y<=x) => x:(v:a -> w:b) -> v:a y:-> u:App v:a w:b
App :: .(.a -> .b) -> .a -> App .a .b

-- APIs
updateSinOscState :: Float -> *SinOscState -> *(SinOscState, Shared Float)

-- Array
newArray     :: .a -> .Array n a
writeArray   :: Int -> *a -> *Array n a -> *Array n a
readArray    :: Int -> *Array n (Shared a) -> *(Array n (Shared a), Shared a)
freezeShared :: *Array n (Shared a) -> Array n a

consume :: *a -> ()

-- World
main     :: *World -> *World
outAudio :: Int -> Audio -> *World -> *World

-- Prelude
maybe  :: .b -> .(.a -> .b) -> .Maybe a -> .b
either :: .(.a -> .c) -> .(.b -> .c) -> .Either a b -> c
(<<)   :: .(.b -> .c) -> .(.a -> .b) -> .a -> .c
fst    :: .(a, b) -> .a
(|>)   :: .a -> .(.a -> .b) -> .b

fst :: .(a, b) -> .a
fst (x, _) = x

snd :: .(a, b) -> .b
snd (_, y) = y

-- Loop ?
loopTest :: .Array n Float
loopTest = a' where

  (feed ~ 0, a') =
    for range (feed, empty) loop i (x, a) ->
      (x * 100, writeArray i x a)

range              :: Range n (Index n)
slidingWindowRange :: Range m (Range n (Index n))
wrangeRange        :: Int -> Range n (Index n)

writeArray :: Index n -> *a -> *Array n a -> *Array n a

range :: Range n (Index n)
writeArray :: *a -> Index n -> *Array n a -> *Array n a

class Freeze a where
  freeze :: (a ~ a1) => *a -> a1

death :: .a -> .b -> c -> d -> ()
death :: forall u v w x a b. (w<=u, x<=u, x<=v) => u:a -> w:(v:b -> x:(c -> d -> ()))

-- TODO: Shared implementation?
-- TODO: (Later): newtype implementation
